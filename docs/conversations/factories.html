<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>conversationkg.conversations.factories API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>conversationkg.conversations.factories</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np
import json
from tqdm import tqdm

from functools import reduce

# topic modelling
from sklearn.decomposition import LatentDirichletAllocation

# named entity recognition
import spacy
import stanza

# keyword extraction
from rake_nltk import Rake


#from .ledger import Universe
from .entities import Entity, StringEntity
from .entities import Topic, TopicInstance
from .entities import Person, Organisation
from .entities import KeyWord

from sklearn.feature_extraction.text import TfidfVectorizer as tfidf
from sklearn.feature_extraction.text import CountVectorizer as count


class FactoryChain:
    &#34;&#34;&#34;
    Not Implemented (yet). Idea is to wrap a sequence of factory classes into this FactoryChain
    which runs the factories on a corpus. 
    Most important use: Some factories depend on the output of others (e.g. TopicFactory depends on VectorFactory), 
    so the FactoryChain could help ensure that factories are executed in the correct order and produce meaningful
    error messages if this is not the case (rather than pure AttributeErrors).
    Other uses: FactoryChain could keep track of the factories that have been applied, gather statistics,
    help parallelisation, preform preparation and postprocessing tasks, etc.
    &#34;&#34;&#34;
    def __init__(*classes, **keyword_args):
        &#34;&#34;&#34;
        FactoryChain is initialised with a list of factory classes and keyword arguments, where
        each key is expected to be the name of a factory class and the value is a dict of parameters
        for that factory, e.g. CountVectoriser=dict(max_df=0.7, min_df=5). 
        &#34;&#34;&#34;
#        no_dependencies = {c for c in classes if getattr(c, &#34;depends_on&#34;, None) is None}
        for c in classes:
            if c.depends_on not in classes:
                raise ValueError(f&#34;Factory {c} depends on {c.depends_on} but the latter&#34;
                                 f&#34;is not in the given chain of classes!&#34;)
                



from joblib import Parallel, delayed

class Factory:
    &#34;&#34;&#34;
    The base class for any specialised factory family, such as VectorFactory, TopicFactory, etc.
    Use this class as base class to create a new factory family; perhaps for instance a StatsFactory 
    for a family of factories which observe statistics about emails and conversations and attach those to both.
    
    TODO:
        - default __init__? -&gt; perhaps for checks if subclassing factory family is well-defined?
        - default __call__ function with basic functionality (that factories override if necessary)
        - parallelisation (including parameters)
    &#34;&#34;&#34;
    
    def __init__(self):
        raise NotImplementedError
    
    
    def process_conversation(self, conversation):
        raise NotImplementedError
    
    def process_email(self, email):
        raise NotImplementedError
        
        
    def parallelise_call(self, conversation_iter, n_jobs=-1, processing_function=None):
        if processing_function is None:
            processing_function = self.process_conversation
        delayed_func = delayed(processing_function)
        # Parallel(n_jobs=n_jobs, require=&#39;sharedmem&#39;)
        return Parallel(n_jobs=n_jobs)(delayed_func(conv) for conv in conversation_iter)
    
    
    def __call__(self, corpus, parallel=True, n_jobs=-1):
        progressbar = tqdm(corpus, 
                           desc=f&#34;{self.__class__.__name__} iterating conversations&#34;
                                f&#34; {&#39;in parallel&#39; if parallel else &#39;&#39;}&#34;)
        
        if parallel:
            return self.parallelise_call(progressbar, n_jobs)
        else:
            processed_conversations = list(map(self.process_conversation, progressbar))
            
        return processed_conversations
        
    
    
    @staticmethod
    def combine_processors(*processors):
        &#34;&#34;&#34;
        Convenience function which combines a list of processors (i.e. functions) into a single one, equivalent to
        mathematical function composition. In terms of call order, the function at the first index of the list 
        is called last, while the function at the last index is called first (**unlike** the convention in 
        function composition).
        May be unsafe to use if the given functions take and return different numbers and types of arguments.
        
        Usage example:
            to_lower = str.lower
            remove_outer_whitespace = str.strip
            remove_comma = lambda s: s.replace(&#34;,&#34;, &#34;&#34;)
            str_normaliser = Factory.combine_processors([remove_comma, remove_outer_whitespace, to_lower])
        &#34;&#34;&#34;
        return reduce(lambda f, g: lambda x: f(g(x)), processors, lambda x: x)
#        return reduce(lambda f, g: lambda *x, **y: f(g(*x, **y)), processors, lambda *x, **y: (x, y))


class VectorFactory(Factory):
    def __init__(self, corpus, vectoriser_algorithm, add_matrix_to_corpus=True, **vectoriser_kwargs):
        default_args = dict(max_df=0.7, min_df=5)
        default_args.update(vectoriser_kwargs)

        self.fitted_corpus = corpus
        self.add_matrix = add_matrix_to_corpus
        
        self.vectoriser = vectoriser_algorithm(**default_args)
        self.matrix = self.vectoriser.fit_transform([
                            email.body.normalised for email in corpus.iter_emails()
                        ])
        self.conversation_matrix = self.vectoriser.transform(
                                    [conv.get_email_bodies(attr=&#34;normalised&#34;, join_str=&#34; &#34;) for conv in corpus]
                                    )        
        
        self.vocabulary = self.vectoriser.get_feature_names()
        

    def process_conversation(self, conversation):
        conversation.vectorised = next(self.conv_iter)
        for email in conversation:
            email_vector = self.process_email(email)
        return conversation.vectorised
    
    def process_email(self, email):
        email.body.vectorised = next(self.email_iter)
        return email.body.vectorised


    def __call__(self, corpus=None, **kwargs):
        if not corpus:
            corpus = self.fitted_corpus
        
        if self.add_matrix:
            corpus.vectorised_vocabulary = self.vocabulary
            corpus.vectorised = self.matrix
            corpus.conversations_vectorised = self.conversation_matrix        
        
        self.conv_iter = iter(self.conversation_matrix)
        self.email_iter = iter(self.matrix)
        
        return super().__call__(corpus, **kwargs)
        

#        if not corpus:
#            corpus = self.fitted_corpus
#        conv_matrix = self.conversation_matrix
#        email_ind = 0
#        for i, conv in enumerate(corpus):
#            conv.vector = conv_matrix[i]
#            for email in conv:
#                email.body.vectorised = self.matrix[email_ind]
#                email_ind += 1
#                
#        if self.add_matrix:
#            corpus.vectorised_vocabulary = self.vocabulary
#            corpus.vectorised = self.matrix
#            corpus.conversations_vectorised = self.conversation_matrix
                

class CountVectorizer(VectorFactory):
    &#34;&#34;&#34;
    Wrapper for scikit-learn&#39;s equally-named [CountVectorizer](https://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.CountVectorizer.html).
    
    &#34;&#34;&#34;
    def __init__(self, corpus, **vectoriser_kwargs):
        super().__init__(corpus, count, **vectoriser_kwargs)

               
class TfidfVectorizer(VectorFactory):
    &#34;&#34;&#34;
    Wrapper for scikit-learn&#39;s equally-named [TfidfVectorizer](https://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.TfidfVectorizer.html).
    
    &#34;&#34;&#34;    
    def __init__(self, corpus, **vectoriser_kwargs):
        super().__init__(corpus, tfidf, **vectoriser_kwargs)


        
class TopicFactory(Factory):
    depends_on = VectorFactory
    def __init__(self, corpus, n_topics):
        if not hasattr(self, &#34;word_distribution&#34;):
            raise AttributeError(&#34;TopicFactory needs a word distribution to be well-defined!&#34;)    
        if not hasattr(self, &#34;predict&#34;) or not callable(self.predict):
            raise AttributeError(&#34;TopicFactory needs a prediction function to be well-defined!&#34;)            

        self.fitted_corpus = corpus
        self.word_distribution = self.word_distribution/self.word_distribution.sum(axis=1)[:, np.newaxis]
        self.topics = [Topic(i, dist, corpus.vectorised_vocabulary)
                            for i, dist in enumerate(self.word_distribution)]
    
    
    def get_topic(self, topic_dist):
        max_prob_ind = topic_dist.argmax()
        return TopicInstance(self.topics[max_prob_ind], topic_dist[max_prob_ind])
    
    
    def process_conversation(self, conversation):
        conversation.topic = self.get_topic(next(self.conv_iter))    
        for email in conversation:
            email_topic = self.process_email(email)
        return conversation.topic

    def process_email(self, email):
        email.topic = self.get_topic(next(self.email_iter))
        return email.topic
            
    
    
    
    def __call__(self, corpus=None, **kwargs):
        if not corpus:
            corpus = self.fitted_corpus
        
        self.conv_iter = iter(self.predict(corpus.conversations_vectorised))
        self.email_iter = iter(self.predict(corpus.vectorised))
        
        return super().__call__(corpus, **kwargs)
        
        
#        email_ind = 0 
#        for i, conv in tqdm(enumerate(corpus), 
#                         desc=f&#34;{self.__class__.__name__} iterating conversations&#34;,
#                         total=len(corpus)):
#            convo_topic_ind = convo_topic_dists[i].argmax()
#            conv.topic = TopicInstance(self.topics[convo_topic_ind], 
#                                       convo_topic_dists[i][convo_topic_ind])
#            
#            for email in conv:
#                email_topic_ind = email_topic_dists[email_ind].argmax()
#                email.topic = TopicInstance(self.topics[email_topic_ind], 
#                                            email_topic_dists[email_ind][email_topic_ind])
#                email_ind += 1


class SKLearnLDA(TopicFactory):
    def __init__(self, corpus, n_topics, **kwargs):
        self.model_args = dict(n_components=n_topics, max_iter=20, learning_method=&#39;batch&#39;,
                               random_state=0, verbose=1, n_jobs=-1)
        self.model_args.update(learning_offset=self.model_args[&#34;max_iter&#34;]//100*10)
        self.model_args.update(dict(evaluate_every=self.model_args[&#34;max_iter&#34;]//10))
        self.model_args.update(kwargs)
        model = LatentDirichletAllocation(**self.model_args)
        model.fit(corpus.vectorised)

        self.word_distribution = model.components_
        self.predict = model.transform
        
        super().__init__(corpus, n_topics)
        
        
    def determine_n_components(self, ns_to_search, corpus=None):
        if not corpus:
            corpus = self.corpus_fitted
        models = {}
        for n in ns_to_search:
            cur_args = {**self.model_args, **dict(n_components=n)}
            cur_model = LatentDirichletAllocation(**cur_args).fit(corpus.vectorised)
            models[n] = cur_model
            
        print(&#34;Perplexities:&#34;, [(n, models[n].bound_) for n in ns_to_search])
        return models
    
    
class GensimLDA(TopicFactory):
    def __init__(self, email_corpus, n_topics, **kwargs):
        raise NotImplementedError(&#34;LDA with Gensim not implemented yet, please feel free to add!\n&#34;
                                  &#34;Make sure to add attrs word_distribution and predict(), &#34;
                                  &#34;as required by the parent TopicFactory.&#34;)


        

class NamedEntityFactory(Factory):
    def __init__(self, corpus, preprocessors=[], postprocessors=[]):
        self.product_type = Entity
        self.product_name = &#34;entities&#34;
        
        self.pre = self.combine_processors(*preprocessors)
        self.post = self.combine_processors(self.string_to_class, *postprocessors)
        
#        super().__init__(self, corpus, preprocessors, postprocessors)
    
    
    @staticmethod
    def string_to_class(entity_list):
        label_class_map = {&#34;PERSON&#34;: lambda name: Person(name, &#34;&#34;),
                           &#34;ORG&#34;: lambda name: Organisation(name, &#34;&#34;)}
        
        return [(label_class_map[l](e)) if l in label_class_map else NamedEntityFactory.entity_from_NER_label(e, l)
                for e, l in entity_list]
        
    @staticmethod 
    def entity_from_NER_label(entity_string, label):
        cls = type(label.title(), (StringEntity, ), dict(class_dynamically_created=True))
        return cls(entity_string)


    def process_conversation(self, conversation):
        conversation.entities = []
        for email in conversation:
            email_entities = self.process_email(email)
            conversation.entities.append(email_entities)
        return conversation.entities
    
    def process_email(self, email):
        email.entities = list(filter(None, self.post(self.get_entities_with_labels(self.pre(email.body.normalised)))))
        return email.entities
    
#    def __call__(self, corpus):
#        for conv in tqdm(corpus, 
#                         desc=f&#34;{self.__class__.__name__} iterating conversations&#34;):
#            all_entities = []
#            for email in conv:
#                email.entities = list(filter(None, 
#                                             self.post(self.get_entities_with_labels(self.pre(email.body.normalised)))
#                                             ))
#                all_entities.extend(email.entities)
#            conv.entities = all_entities
    
    
class SpaCyNER(NamedEntityFactory):
    def __init__(self, preprocessors=[], postprocessors=[]):
        self.nlp = spacy.load(&#34;en_core_web_md&#34;)
        super().__init__(preprocessors, postprocessors)
        
    def get_entities(self, text):
        return [str(e) for e in self.nlp(text).ents]
    
    def get_entities_with_labels(self, text):
        return [(str(e), e.label_) for e in self.nlp(text).ents] 
        
    
class StanzaNER(NamedEntityFactory):
    def __init__(self, preprocessors=[], postprocessors=[]):
        self.nlp = stanza.Pipeline(&#39;en&#39;, processors=&#34;tokenize, mwt, ner&#34;)
        super().__init__(preprocessors, postprocessors)
        
    def get_entities(self, text):
        return [d.text for d in self.nlp(text).ents]
    
    def get_entities_with_labels(self, text):
        return [(d.text, d.type) for d in self.nlp(text).ents]            



class KeyWordFactory(Factory):
    def __init__(self, preprocessors=[], postprocessors=[]):
        self.product_type = KeyWord
        self.product_name = &#34;keywords&#34;
        
        self.pre = self.combine_processors(*preprocessors)
        self.post = self.combine_processors(self.output_to_class, *postprocessors)
        
#        # set to False if process_conversation calls process_email, to True otherwise
#        self.process_emails_separately = False
        
#        super().__init__(self, corpus=None, preprocessors, postprocessors)


    def process_conversation(self, conversation):
        conversation.keywords = []
        for email in conversation:
            email_keywords = self.process_email(email)
            conversation.keywords.append(email_keywords)
        return conversation.keywords

    def process_email(self, email):
        email.keywords = list(filter(None, self.post(self.get_keywords(self.pre(email.body.normalised)))))
        return email.keywords


#    def __call__(self, corpus):
#        for conv in tqdm(corpus, 
#                         desc=f&#34;{self.__class__.__name__} iterating conversations&#34;):
#            all_keywords = []
#            for email in conv:
#                email.keywords = list(filter(None,
#                                             self.post(self.get_keywords(self.pre(email.body.normalised)))
#                                    ))
#                all_keywords.extend(email.keywords)
#            conv.keywords = all_keywords
    
    
    @staticmethod
    def output_to_class(keyword_list):
        return [KeyWord(s) for s in keyword_list]
    
    
    
class RakeKeyWordExtractor(KeyWordFactory):
    def __init__(self, preprocessors=[], postprocessors=[]):
        self.rake = Rake()
        postprocessors = [self.remove_low_scores, *postprocessors]  # self.combine_processors(self.remove_low_scores, *postprocessors)
        super().__init__(preprocessors, postprocessors)
    
    @staticmethod    
    def remove_low_scores(keyword_list, score=1.0):
        return [phrase for score, phrase in keyword_list if score &gt; 1.0]
    
    
    
    def get_keywords(self, text):
        self.rake.extract_keywords_from_text(text)
        return self.rake.get_ranked_phrases_with_scores()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="conversationkg.conversations.factories.CountVectorizer"><code class="flex name class">
<span>class <span class="ident">CountVectorizer</span></span>
<span>(</span><span>corpus, **vectoriser_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper for scikit-learn's equally-named <a href="https://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.CountVectorizer.html">CountVectorizer</a>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CountVectorizer(VectorFactory):
    &#34;&#34;&#34;
    Wrapper for scikit-learn&#39;s equally-named [CountVectorizer](https://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.CountVectorizer.html).
    
    &#34;&#34;&#34;
    def __init__(self, corpus, **vectoriser_kwargs):
        super().__init__(corpus, count, **vectoriser_kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="conversationkg.conversations.factories.VectorFactory" href="#conversationkg.conversations.factories.VectorFactory">VectorFactory</a></li>
<li><a title="conversationkg.conversations.factories.Factory" href="#conversationkg.conversations.factories.Factory">Factory</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="conversationkg.conversations.factories.VectorFactory" href="#conversationkg.conversations.factories.VectorFactory">VectorFactory</a></b></code>:
<ul class="hlist">
<li><code><a title="conversationkg.conversations.factories.VectorFactory.combine_processors" href="#conversationkg.conversations.factories.Factory.combine_processors">combine_processors</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="conversationkg.conversations.factories.Factory"><code class="flex name class">
<span>class <span class="ident">Factory</span></span>
</code></dt>
<dd>
<div class="desc"><p>The base class for any specialised factory family, such as VectorFactory, TopicFactory, etc.
Use this class as base class to create a new factory family; perhaps for instance a StatsFactory
for a family of factories which observe statistics about emails and conversations and attach those to both.</p>
<h2 id="todo">Todo</h2>
<ul>
<li>default <strong>init</strong>? -&gt; perhaps for checks if subclassing factory family is well-defined?</li>
<li>default <strong>call</strong> function with basic functionality (that factories override if necessary)</li>
<li>parallelisation (including parameters)</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Factory:
    &#34;&#34;&#34;
    The base class for any specialised factory family, such as VectorFactory, TopicFactory, etc.
    Use this class as base class to create a new factory family; perhaps for instance a StatsFactory 
    for a family of factories which observe statistics about emails and conversations and attach those to both.
    
    TODO:
        - default __init__? -&gt; perhaps for checks if subclassing factory family is well-defined?
        - default __call__ function with basic functionality (that factories override if necessary)
        - parallelisation (including parameters)
    &#34;&#34;&#34;
    
    def __init__(self):
        raise NotImplementedError
    
    
    def process_conversation(self, conversation):
        raise NotImplementedError
    
    def process_email(self, email):
        raise NotImplementedError
        
        
    def parallelise_call(self, conversation_iter, n_jobs=-1, processing_function=None):
        if processing_function is None:
            processing_function = self.process_conversation
        delayed_func = delayed(processing_function)
        # Parallel(n_jobs=n_jobs, require=&#39;sharedmem&#39;)
        return Parallel(n_jobs=n_jobs)(delayed_func(conv) for conv in conversation_iter)
    
    
    def __call__(self, corpus, parallel=True, n_jobs=-1):
        progressbar = tqdm(corpus, 
                           desc=f&#34;{self.__class__.__name__} iterating conversations&#34;
                                f&#34; {&#39;in parallel&#39; if parallel else &#39;&#39;}&#34;)
        
        if parallel:
            return self.parallelise_call(progressbar, n_jobs)
        else:
            processed_conversations = list(map(self.process_conversation, progressbar))
            
        return processed_conversations
        
    
    
    @staticmethod
    def combine_processors(*processors):
        &#34;&#34;&#34;
        Convenience function which combines a list of processors (i.e. functions) into a single one, equivalent to
        mathematical function composition. In terms of call order, the function at the first index of the list 
        is called last, while the function at the last index is called first (**unlike** the convention in 
        function composition).
        May be unsafe to use if the given functions take and return different numbers and types of arguments.
        
        Usage example:
            to_lower = str.lower
            remove_outer_whitespace = str.strip
            remove_comma = lambda s: s.replace(&#34;,&#34;, &#34;&#34;)
            str_normaliser = Factory.combine_processors([remove_comma, remove_outer_whitespace, to_lower])
        &#34;&#34;&#34;
        return reduce(lambda f, g: lambda x: f(g(x)), processors, lambda x: x)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="conversationkg.conversations.factories.KeyWordFactory" href="#conversationkg.conversations.factories.KeyWordFactory">KeyWordFactory</a></li>
<li><a title="conversationkg.conversations.factories.NamedEntityFactory" href="#conversationkg.conversations.factories.NamedEntityFactory">NamedEntityFactory</a></li>
<li><a title="conversationkg.conversations.factories.TopicFactory" href="#conversationkg.conversations.factories.TopicFactory">TopicFactory</a></li>
<li><a title="conversationkg.conversations.factories.VectorFactory" href="#conversationkg.conversations.factories.VectorFactory">VectorFactory</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="conversationkg.conversations.factories.Factory.combine_processors"><code class="name flex">
<span>def <span class="ident">combine_processors</span></span>(<span>*processors)</span>
</code></dt>
<dd>
<div class="desc"><p>Convenience function which combines a list of processors (i.e. functions) into a single one, equivalent to
mathematical function composition. In terms of call order, the function at the first index of the list
is called last, while the function at the last index is called first (<strong>unlike</strong> the convention in
function composition).
May be unsafe to use if the given functions take and return different numbers and types of arguments.</p>
<p>Usage example:
to_lower = str.lower
remove_outer_whitespace = str.strip
remove_comma = lambda s: s.replace(",", "")
str_normaliser = Factory.combine_processors([remove_comma, remove_outer_whitespace, to_lower])</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def combine_processors(*processors):
    &#34;&#34;&#34;
    Convenience function which combines a list of processors (i.e. functions) into a single one, equivalent to
    mathematical function composition. In terms of call order, the function at the first index of the list 
    is called last, while the function at the last index is called first (**unlike** the convention in 
    function composition).
    May be unsafe to use if the given functions take and return different numbers and types of arguments.
    
    Usage example:
        to_lower = str.lower
        remove_outer_whitespace = str.strip
        remove_comma = lambda s: s.replace(&#34;,&#34;, &#34;&#34;)
        str_normaliser = Factory.combine_processors([remove_comma, remove_outer_whitespace, to_lower])
    &#34;&#34;&#34;
    return reduce(lambda f, g: lambda x: f(g(x)), processors, lambda x: x)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="conversationkg.conversations.factories.Factory.parallelise_call"><code class="name flex">
<span>def <span class="ident">parallelise_call</span></span>(<span>self, conversation_iter, n_jobs=-1, processing_function=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parallelise_call(self, conversation_iter, n_jobs=-1, processing_function=None):
    if processing_function is None:
        processing_function = self.process_conversation
    delayed_func = delayed(processing_function)
    # Parallel(n_jobs=n_jobs, require=&#39;sharedmem&#39;)
    return Parallel(n_jobs=n_jobs)(delayed_func(conv) for conv in conversation_iter)</code></pre>
</details>
</dd>
<dt id="conversationkg.conversations.factories.Factory.process_conversation"><code class="name flex">
<span>def <span class="ident">process_conversation</span></span>(<span>self, conversation)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_conversation(self, conversation):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="conversationkg.conversations.factories.Factory.process_email"><code class="name flex">
<span>def <span class="ident">process_email</span></span>(<span>self, email)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_email(self, email):
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="conversationkg.conversations.factories.FactoryChain"><code class="flex name class">
<span>class <span class="ident">FactoryChain</span></span>
<span>(</span><span>**keyword_args)</span>
</code></dt>
<dd>
<div class="desc"><p>Not Implemented (yet). Idea is to wrap a sequence of factory classes into this FactoryChain
which runs the factories on a corpus.
Most important use: Some factories depend on the output of others (e.g. TopicFactory depends on VectorFactory),
so the FactoryChain could help ensure that factories are executed in the correct order and produce meaningful
error messages if this is not the case (rather than pure AttributeErrors).
Other uses: FactoryChain could keep track of the factories that have been applied, gather statistics,
help parallelisation, preform preparation and postprocessing tasks, etc.</p>
<p>FactoryChain is initialised with a list of factory classes and keyword arguments, where
each key is expected to be the name of a factory class and the value is a dict of parameters
for that factory, e.g. CountVectoriser=dict(max_df=0.7, min_df=5).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FactoryChain:
    &#34;&#34;&#34;
    Not Implemented (yet). Idea is to wrap a sequence of factory classes into this FactoryChain
    which runs the factories on a corpus. 
    Most important use: Some factories depend on the output of others (e.g. TopicFactory depends on VectorFactory), 
    so the FactoryChain could help ensure that factories are executed in the correct order and produce meaningful
    error messages if this is not the case (rather than pure AttributeErrors).
    Other uses: FactoryChain could keep track of the factories that have been applied, gather statistics,
    help parallelisation, preform preparation and postprocessing tasks, etc.
    &#34;&#34;&#34;
    def __init__(*classes, **keyword_args):
        &#34;&#34;&#34;
        FactoryChain is initialised with a list of factory classes and keyword arguments, where
        each key is expected to be the name of a factory class and the value is a dict of parameters
        for that factory, e.g. CountVectoriser=dict(max_df=0.7, min_df=5). 
        &#34;&#34;&#34;
#        no_dependencies = {c for c in classes if getattr(c, &#34;depends_on&#34;, None) is None}
        for c in classes:
            if c.depends_on not in classes:
                raise ValueError(f&#34;Factory {c} depends on {c.depends_on} but the latter&#34;
                                 f&#34;is not in the given chain of classes!&#34;)</code></pre>
</details>
</dd>
<dt id="conversationkg.conversations.factories.GensimLDA"><code class="flex name class">
<span>class <span class="ident">GensimLDA</span></span>
<span>(</span><span>email_corpus, n_topics, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The base class for any specialised factory family, such as VectorFactory, TopicFactory, etc.
Use this class as base class to create a new factory family; perhaps for instance a StatsFactory
for a family of factories which observe statistics about emails and conversations and attach those to both.</p>
<h2 id="todo">Todo</h2>
<ul>
<li>default <strong>init</strong>? -&gt; perhaps for checks if subclassing factory family is well-defined?</li>
<li>default <strong>call</strong> function with basic functionality (that factories override if necessary)</li>
<li>parallelisation (including parameters)</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GensimLDA(TopicFactory):
    def __init__(self, email_corpus, n_topics, **kwargs):
        raise NotImplementedError(&#34;LDA with Gensim not implemented yet, please feel free to add!\n&#34;
                                  &#34;Make sure to add attrs word_distribution and predict(), &#34;
                                  &#34;as required by the parent TopicFactory.&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="conversationkg.conversations.factories.TopicFactory" href="#conversationkg.conversations.factories.TopicFactory">TopicFactory</a></li>
<li><a title="conversationkg.conversations.factories.Factory" href="#conversationkg.conversations.factories.Factory">Factory</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="conversationkg.conversations.factories.TopicFactory" href="#conversationkg.conversations.factories.TopicFactory">TopicFactory</a></b></code>:
<ul class="hlist">
<li><code><a title="conversationkg.conversations.factories.TopicFactory.combine_processors" href="#conversationkg.conversations.factories.Factory.combine_processors">combine_processors</a></code></li>
<li><code><a title="conversationkg.conversations.factories.TopicFactory.depends_on" href="#conversationkg.conversations.factories.TopicFactory.depends_on">depends_on</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="conversationkg.conversations.factories.KeyWordFactory"><code class="flex name class">
<span>class <span class="ident">KeyWordFactory</span></span>
<span>(</span><span>preprocessors=[], postprocessors=[])</span>
</code></dt>
<dd>
<div class="desc"><p>The base class for any specialised factory family, such as VectorFactory, TopicFactory, etc.
Use this class as base class to create a new factory family; perhaps for instance a StatsFactory
for a family of factories which observe statistics about emails and conversations and attach those to both.</p>
<h2 id="todo">Todo</h2>
<ul>
<li>default <strong>init</strong>? -&gt; perhaps for checks if subclassing factory family is well-defined?</li>
<li>default <strong>call</strong> function with basic functionality (that factories override if necessary)</li>
<li>parallelisation (including parameters)</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class KeyWordFactory(Factory):
    def __init__(self, preprocessors=[], postprocessors=[]):
        self.product_type = KeyWord
        self.product_name = &#34;keywords&#34;
        
        self.pre = self.combine_processors(*preprocessors)
        self.post = self.combine_processors(self.output_to_class, *postprocessors)
        
#        # set to False if process_conversation calls process_email, to True otherwise
#        self.process_emails_separately = False
        
#        super().__init__(self, corpus=None, preprocessors, postprocessors)


    def process_conversation(self, conversation):
        conversation.keywords = []
        for email in conversation:
            email_keywords = self.process_email(email)
            conversation.keywords.append(email_keywords)
        return conversation.keywords

    def process_email(self, email):
        email.keywords = list(filter(None, self.post(self.get_keywords(self.pre(email.body.normalised)))))
        return email.keywords


#    def __call__(self, corpus):
#        for conv in tqdm(corpus, 
#                         desc=f&#34;{self.__class__.__name__} iterating conversations&#34;):
#            all_keywords = []
#            for email in conv:
#                email.keywords = list(filter(None,
#                                             self.post(self.get_keywords(self.pre(email.body.normalised)))
#                                    ))
#                all_keywords.extend(email.keywords)
#            conv.keywords = all_keywords
    
    
    @staticmethod
    def output_to_class(keyword_list):
        return [KeyWord(s) for s in keyword_list]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="conversationkg.conversations.factories.Factory" href="#conversationkg.conversations.factories.Factory">Factory</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="conversationkg.conversations.factories.RakeKeyWordExtractor" href="#conversationkg.conversations.factories.RakeKeyWordExtractor">RakeKeyWordExtractor</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="conversationkg.conversations.factories.KeyWordFactory.output_to_class"><code class="name flex">
<span>def <span class="ident">output_to_class</span></span>(<span>keyword_list)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def output_to_class(keyword_list):
    return [KeyWord(s) for s in keyword_list]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="conversationkg.conversations.factories.KeyWordFactory.process_conversation"><code class="name flex">
<span>def <span class="ident">process_conversation</span></span>(<span>self, conversation)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_conversation(self, conversation):
    conversation.keywords = []
    for email in conversation:
        email_keywords = self.process_email(email)
        conversation.keywords.append(email_keywords)
    return conversation.keywords</code></pre>
</details>
</dd>
<dt id="conversationkg.conversations.factories.KeyWordFactory.process_email"><code class="name flex">
<span>def <span class="ident">process_email</span></span>(<span>self, email)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_email(self, email):
    email.keywords = list(filter(None, self.post(self.get_keywords(self.pre(email.body.normalised)))))
    return email.keywords</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="conversationkg.conversations.factories.Factory" href="#conversationkg.conversations.factories.Factory">Factory</a></b></code>:
<ul class="hlist">
<li><code><a title="conversationkg.conversations.factories.Factory.combine_processors" href="#conversationkg.conversations.factories.Factory.combine_processors">combine_processors</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="conversationkg.conversations.factories.NamedEntityFactory"><code class="flex name class">
<span>class <span class="ident">NamedEntityFactory</span></span>
<span>(</span><span>corpus, preprocessors=[], postprocessors=[])</span>
</code></dt>
<dd>
<div class="desc"><p>The base class for any specialised factory family, such as VectorFactory, TopicFactory, etc.
Use this class as base class to create a new factory family; perhaps for instance a StatsFactory
for a family of factories which observe statistics about emails and conversations and attach those to both.</p>
<h2 id="todo">Todo</h2>
<ul>
<li>default <strong>init</strong>? -&gt; perhaps for checks if subclassing factory family is well-defined?</li>
<li>default <strong>call</strong> function with basic functionality (that factories override if necessary)</li>
<li>parallelisation (including parameters)</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NamedEntityFactory(Factory):
    def __init__(self, corpus, preprocessors=[], postprocessors=[]):
        self.product_type = Entity
        self.product_name = &#34;entities&#34;
        
        self.pre = self.combine_processors(*preprocessors)
        self.post = self.combine_processors(self.string_to_class, *postprocessors)
        
#        super().__init__(self, corpus, preprocessors, postprocessors)
    
    
    @staticmethod
    def string_to_class(entity_list):
        label_class_map = {&#34;PERSON&#34;: lambda name: Person(name, &#34;&#34;),
                           &#34;ORG&#34;: lambda name: Organisation(name, &#34;&#34;)}
        
        return [(label_class_map[l](e)) if l in label_class_map else NamedEntityFactory.entity_from_NER_label(e, l)
                for e, l in entity_list]
        
    @staticmethod 
    def entity_from_NER_label(entity_string, label):
        cls = type(label.title(), (StringEntity, ), dict(class_dynamically_created=True))
        return cls(entity_string)


    def process_conversation(self, conversation):
        conversation.entities = []
        for email in conversation:
            email_entities = self.process_email(email)
            conversation.entities.append(email_entities)
        return conversation.entities
    
    def process_email(self, email):
        email.entities = list(filter(None, self.post(self.get_entities_with_labels(self.pre(email.body.normalised)))))
        return email.entities</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="conversationkg.conversations.factories.Factory" href="#conversationkg.conversations.factories.Factory">Factory</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="conversationkg.conversations.factories.SpaCyNER" href="#conversationkg.conversations.factories.SpaCyNER">SpaCyNER</a></li>
<li><a title="conversationkg.conversations.factories.StanzaNER" href="#conversationkg.conversations.factories.StanzaNER">StanzaNER</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="conversationkg.conversations.factories.NamedEntityFactory.entity_from_NER_label"><code class="name flex">
<span>def <span class="ident">entity_from_NER_label</span></span>(<span>entity_string, label)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod 
def entity_from_NER_label(entity_string, label):
    cls = type(label.title(), (StringEntity, ), dict(class_dynamically_created=True))
    return cls(entity_string)</code></pre>
</details>
</dd>
<dt id="conversationkg.conversations.factories.NamedEntityFactory.string_to_class"><code class="name flex">
<span>def <span class="ident">string_to_class</span></span>(<span>entity_list)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def string_to_class(entity_list):
    label_class_map = {&#34;PERSON&#34;: lambda name: Person(name, &#34;&#34;),
                       &#34;ORG&#34;: lambda name: Organisation(name, &#34;&#34;)}
    
    return [(label_class_map[l](e)) if l in label_class_map else NamedEntityFactory.entity_from_NER_label(e, l)
            for e, l in entity_list]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="conversationkg.conversations.factories.NamedEntityFactory.process_conversation"><code class="name flex">
<span>def <span class="ident">process_conversation</span></span>(<span>self, conversation)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_conversation(self, conversation):
    conversation.entities = []
    for email in conversation:
        email_entities = self.process_email(email)
        conversation.entities.append(email_entities)
    return conversation.entities</code></pre>
</details>
</dd>
<dt id="conversationkg.conversations.factories.NamedEntityFactory.process_email"><code class="name flex">
<span>def <span class="ident">process_email</span></span>(<span>self, email)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_email(self, email):
    email.entities = list(filter(None, self.post(self.get_entities_with_labels(self.pre(email.body.normalised)))))
    return email.entities</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="conversationkg.conversations.factories.Factory" href="#conversationkg.conversations.factories.Factory">Factory</a></b></code>:
<ul class="hlist">
<li><code><a title="conversationkg.conversations.factories.Factory.combine_processors" href="#conversationkg.conversations.factories.Factory.combine_processors">combine_processors</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="conversationkg.conversations.factories.RakeKeyWordExtractor"><code class="flex name class">
<span>class <span class="ident">RakeKeyWordExtractor</span></span>
<span>(</span><span>preprocessors=[], postprocessors=[])</span>
</code></dt>
<dd>
<div class="desc"><p>The base class for any specialised factory family, such as VectorFactory, TopicFactory, etc.
Use this class as base class to create a new factory family; perhaps for instance a StatsFactory
for a family of factories which observe statistics about emails and conversations and attach those to both.</p>
<h2 id="todo">Todo</h2>
<ul>
<li>default <strong>init</strong>? -&gt; perhaps for checks if subclassing factory family is well-defined?</li>
<li>default <strong>call</strong> function with basic functionality (that factories override if necessary)</li>
<li>parallelisation (including parameters)</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RakeKeyWordExtractor(KeyWordFactory):
    def __init__(self, preprocessors=[], postprocessors=[]):
        self.rake = Rake()
        postprocessors = [self.remove_low_scores, *postprocessors]  # self.combine_processors(self.remove_low_scores, *postprocessors)
        super().__init__(preprocessors, postprocessors)
    
    @staticmethod    
    def remove_low_scores(keyword_list, score=1.0):
        return [phrase for score, phrase in keyword_list if score &gt; 1.0]
    
    
    
    def get_keywords(self, text):
        self.rake.extract_keywords_from_text(text)
        return self.rake.get_ranked_phrases_with_scores()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="conversationkg.conversations.factories.KeyWordFactory" href="#conversationkg.conversations.factories.KeyWordFactory">KeyWordFactory</a></li>
<li><a title="conversationkg.conversations.factories.Factory" href="#conversationkg.conversations.factories.Factory">Factory</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="conversationkg.conversations.factories.RakeKeyWordExtractor.remove_low_scores"><code class="name flex">
<span>def <span class="ident">remove_low_scores</span></span>(<span>keyword_list, score=1.0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod    
def remove_low_scores(keyword_list, score=1.0):
    return [phrase for score, phrase in keyword_list if score &gt; 1.0]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="conversationkg.conversations.factories.RakeKeyWordExtractor.get_keywords"><code class="name flex">
<span>def <span class="ident">get_keywords</span></span>(<span>self, text)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_keywords(self, text):
    self.rake.extract_keywords_from_text(text)
    return self.rake.get_ranked_phrases_with_scores()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="conversationkg.conversations.factories.KeyWordFactory" href="#conversationkg.conversations.factories.KeyWordFactory">KeyWordFactory</a></b></code>:
<ul class="hlist">
<li><code><a title="conversationkg.conversations.factories.KeyWordFactory.combine_processors" href="#conversationkg.conversations.factories.Factory.combine_processors">combine_processors</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="conversationkg.conversations.factories.SKLearnLDA"><code class="flex name class">
<span>class <span class="ident">SKLearnLDA</span></span>
<span>(</span><span>corpus, n_topics, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The base class for any specialised factory family, such as VectorFactory, TopicFactory, etc.
Use this class as base class to create a new factory family; perhaps for instance a StatsFactory
for a family of factories which observe statistics about emails and conversations and attach those to both.</p>
<h2 id="todo">Todo</h2>
<ul>
<li>default <strong>init</strong>? -&gt; perhaps for checks if subclassing factory family is well-defined?</li>
<li>default <strong>call</strong> function with basic functionality (that factories override if necessary)</li>
<li>parallelisation (including parameters)</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SKLearnLDA(TopicFactory):
    def __init__(self, corpus, n_topics, **kwargs):
        self.model_args = dict(n_components=n_topics, max_iter=20, learning_method=&#39;batch&#39;,
                               random_state=0, verbose=1, n_jobs=-1)
        self.model_args.update(learning_offset=self.model_args[&#34;max_iter&#34;]//100*10)
        self.model_args.update(dict(evaluate_every=self.model_args[&#34;max_iter&#34;]//10))
        self.model_args.update(kwargs)
        model = LatentDirichletAllocation(**self.model_args)
        model.fit(corpus.vectorised)

        self.word_distribution = model.components_
        self.predict = model.transform
        
        super().__init__(corpus, n_topics)
        
        
    def determine_n_components(self, ns_to_search, corpus=None):
        if not corpus:
            corpus = self.corpus_fitted
        models = {}
        for n in ns_to_search:
            cur_args = {**self.model_args, **dict(n_components=n)}
            cur_model = LatentDirichletAllocation(**cur_args).fit(corpus.vectorised)
            models[n] = cur_model
            
        print(&#34;Perplexities:&#34;, [(n, models[n].bound_) for n in ns_to_search])
        return models</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="conversationkg.conversations.factories.TopicFactory" href="#conversationkg.conversations.factories.TopicFactory">TopicFactory</a></li>
<li><a title="conversationkg.conversations.factories.Factory" href="#conversationkg.conversations.factories.Factory">Factory</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="conversationkg.conversations.factories.SKLearnLDA.determine_n_components"><code class="name flex">
<span>def <span class="ident">determine_n_components</span></span>(<span>self, ns_to_search, corpus=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def determine_n_components(self, ns_to_search, corpus=None):
    if not corpus:
        corpus = self.corpus_fitted
    models = {}
    for n in ns_to_search:
        cur_args = {**self.model_args, **dict(n_components=n)}
        cur_model = LatentDirichletAllocation(**cur_args).fit(corpus.vectorised)
        models[n] = cur_model
        
    print(&#34;Perplexities:&#34;, [(n, models[n].bound_) for n in ns_to_search])
    return models</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="conversationkg.conversations.factories.TopicFactory" href="#conversationkg.conversations.factories.TopicFactory">TopicFactory</a></b></code>:
<ul class="hlist">
<li><code><a title="conversationkg.conversations.factories.TopicFactory.combine_processors" href="#conversationkg.conversations.factories.Factory.combine_processors">combine_processors</a></code></li>
<li><code><a title="conversationkg.conversations.factories.TopicFactory.depends_on" href="#conversationkg.conversations.factories.TopicFactory.depends_on">depends_on</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="conversationkg.conversations.factories.SpaCyNER"><code class="flex name class">
<span>class <span class="ident">SpaCyNER</span></span>
<span>(</span><span>preprocessors=[], postprocessors=[])</span>
</code></dt>
<dd>
<div class="desc"><p>The base class for any specialised factory family, such as VectorFactory, TopicFactory, etc.
Use this class as base class to create a new factory family; perhaps for instance a StatsFactory
for a family of factories which observe statistics about emails and conversations and attach those to both.</p>
<h2 id="todo">Todo</h2>
<ul>
<li>default <strong>init</strong>? -&gt; perhaps for checks if subclassing factory family is well-defined?</li>
<li>default <strong>call</strong> function with basic functionality (that factories override if necessary)</li>
<li>parallelisation (including parameters)</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SpaCyNER(NamedEntityFactory):
    def __init__(self, preprocessors=[], postprocessors=[]):
        self.nlp = spacy.load(&#34;en_core_web_md&#34;)
        super().__init__(preprocessors, postprocessors)
        
    def get_entities(self, text):
        return [str(e) for e in self.nlp(text).ents]
    
    def get_entities_with_labels(self, text):
        return [(str(e), e.label_) for e in self.nlp(text).ents] </code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="conversationkg.conversations.factories.NamedEntityFactory" href="#conversationkg.conversations.factories.NamedEntityFactory">NamedEntityFactory</a></li>
<li><a title="conversationkg.conversations.factories.Factory" href="#conversationkg.conversations.factories.Factory">Factory</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="conversationkg.conversations.factories.SpaCyNER.get_entities"><code class="name flex">
<span>def <span class="ident">get_entities</span></span>(<span>self, text)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_entities(self, text):
    return [str(e) for e in self.nlp(text).ents]</code></pre>
</details>
</dd>
<dt id="conversationkg.conversations.factories.SpaCyNER.get_entities_with_labels"><code class="name flex">
<span>def <span class="ident">get_entities_with_labels</span></span>(<span>self, text)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_entities_with_labels(self, text):
    return [(str(e), e.label_) for e in self.nlp(text).ents] </code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="conversationkg.conversations.factories.NamedEntityFactory" href="#conversationkg.conversations.factories.NamedEntityFactory">NamedEntityFactory</a></b></code>:
<ul class="hlist">
<li><code><a title="conversationkg.conversations.factories.NamedEntityFactory.combine_processors" href="#conversationkg.conversations.factories.Factory.combine_processors">combine_processors</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="conversationkg.conversations.factories.StanzaNER"><code class="flex name class">
<span>class <span class="ident">StanzaNER</span></span>
<span>(</span><span>preprocessors=[], postprocessors=[])</span>
</code></dt>
<dd>
<div class="desc"><p>The base class for any specialised factory family, such as VectorFactory, TopicFactory, etc.
Use this class as base class to create a new factory family; perhaps for instance a StatsFactory
for a family of factories which observe statistics about emails and conversations and attach those to both.</p>
<h2 id="todo">Todo</h2>
<ul>
<li>default <strong>init</strong>? -&gt; perhaps for checks if subclassing factory family is well-defined?</li>
<li>default <strong>call</strong> function with basic functionality (that factories override if necessary)</li>
<li>parallelisation (including parameters)</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StanzaNER(NamedEntityFactory):
    def __init__(self, preprocessors=[], postprocessors=[]):
        self.nlp = stanza.Pipeline(&#39;en&#39;, processors=&#34;tokenize, mwt, ner&#34;)
        super().__init__(preprocessors, postprocessors)
        
    def get_entities(self, text):
        return [d.text for d in self.nlp(text).ents]
    
    def get_entities_with_labels(self, text):
        return [(d.text, d.type) for d in self.nlp(text).ents]            </code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="conversationkg.conversations.factories.NamedEntityFactory" href="#conversationkg.conversations.factories.NamedEntityFactory">NamedEntityFactory</a></li>
<li><a title="conversationkg.conversations.factories.Factory" href="#conversationkg.conversations.factories.Factory">Factory</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="conversationkg.conversations.factories.StanzaNER.get_entities"><code class="name flex">
<span>def <span class="ident">get_entities</span></span>(<span>self, text)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_entities(self, text):
    return [d.text for d in self.nlp(text).ents]</code></pre>
</details>
</dd>
<dt id="conversationkg.conversations.factories.StanzaNER.get_entities_with_labels"><code class="name flex">
<span>def <span class="ident">get_entities_with_labels</span></span>(<span>self, text)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_entities_with_labels(self, text):
    return [(d.text, d.type) for d in self.nlp(text).ents]            </code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="conversationkg.conversations.factories.NamedEntityFactory" href="#conversationkg.conversations.factories.NamedEntityFactory">NamedEntityFactory</a></b></code>:
<ul class="hlist">
<li><code><a title="conversationkg.conversations.factories.NamedEntityFactory.combine_processors" href="#conversationkg.conversations.factories.Factory.combine_processors">combine_processors</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="conversationkg.conversations.factories.TfidfVectorizer"><code class="flex name class">
<span>class <span class="ident">TfidfVectorizer</span></span>
<span>(</span><span>corpus, **vectoriser_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper for scikit-learn's equally-named <a href="https://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.TfidfVectorizer.html">TfidfVectorizer</a>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TfidfVectorizer(VectorFactory):
    &#34;&#34;&#34;
    Wrapper for scikit-learn&#39;s equally-named [TfidfVectorizer](https://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.TfidfVectorizer.html).
    
    &#34;&#34;&#34;    
    def __init__(self, corpus, **vectoriser_kwargs):
        super().__init__(corpus, tfidf, **vectoriser_kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="conversationkg.conversations.factories.VectorFactory" href="#conversationkg.conversations.factories.VectorFactory">VectorFactory</a></li>
<li><a title="conversationkg.conversations.factories.Factory" href="#conversationkg.conversations.factories.Factory">Factory</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="conversationkg.conversations.factories.VectorFactory" href="#conversationkg.conversations.factories.VectorFactory">VectorFactory</a></b></code>:
<ul class="hlist">
<li><code><a title="conversationkg.conversations.factories.VectorFactory.combine_processors" href="#conversationkg.conversations.factories.Factory.combine_processors">combine_processors</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="conversationkg.conversations.factories.TopicFactory"><code class="flex name class">
<span>class <span class="ident">TopicFactory</span></span>
<span>(</span><span>corpus, n_topics)</span>
</code></dt>
<dd>
<div class="desc"><p>The base class for any specialised factory family, such as VectorFactory, TopicFactory, etc.
Use this class as base class to create a new factory family; perhaps for instance a StatsFactory
for a family of factories which observe statistics about emails and conversations and attach those to both.</p>
<h2 id="todo">Todo</h2>
<ul>
<li>default <strong>init</strong>? -&gt; perhaps for checks if subclassing factory family is well-defined?</li>
<li>default <strong>call</strong> function with basic functionality (that factories override if necessary)</li>
<li>parallelisation (including parameters)</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TopicFactory(Factory):
    depends_on = VectorFactory
    def __init__(self, corpus, n_topics):
        if not hasattr(self, &#34;word_distribution&#34;):
            raise AttributeError(&#34;TopicFactory needs a word distribution to be well-defined!&#34;)    
        if not hasattr(self, &#34;predict&#34;) or not callable(self.predict):
            raise AttributeError(&#34;TopicFactory needs a prediction function to be well-defined!&#34;)            

        self.fitted_corpus = corpus
        self.word_distribution = self.word_distribution/self.word_distribution.sum(axis=1)[:, np.newaxis]
        self.topics = [Topic(i, dist, corpus.vectorised_vocabulary)
                            for i, dist in enumerate(self.word_distribution)]
    
    
    def get_topic(self, topic_dist):
        max_prob_ind = topic_dist.argmax()
        return TopicInstance(self.topics[max_prob_ind], topic_dist[max_prob_ind])
    
    
    def process_conversation(self, conversation):
        conversation.topic = self.get_topic(next(self.conv_iter))    
        for email in conversation:
            email_topic = self.process_email(email)
        return conversation.topic

    def process_email(self, email):
        email.topic = self.get_topic(next(self.email_iter))
        return email.topic
            
    
    
    
    def __call__(self, corpus=None, **kwargs):
        if not corpus:
            corpus = self.fitted_corpus
        
        self.conv_iter = iter(self.predict(corpus.conversations_vectorised))
        self.email_iter = iter(self.predict(corpus.vectorised))
        
        return super().__call__(corpus, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="conversationkg.conversations.factories.Factory" href="#conversationkg.conversations.factories.Factory">Factory</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="conversationkg.conversations.factories.GensimLDA" href="#conversationkg.conversations.factories.GensimLDA">GensimLDA</a></li>
<li><a title="conversationkg.conversations.factories.SKLearnLDA" href="#conversationkg.conversations.factories.SKLearnLDA">SKLearnLDA</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="conversationkg.conversations.factories.TopicFactory.depends_on"><code class="name">var <span class="ident">depends_on</span></code></dt>
<dd>
<div class="desc"><p>The base class for any specialised factory family, such as VectorFactory, TopicFactory, etc.
Use this class as base class to create a new factory family; perhaps for instance a StatsFactory
for a family of factories which observe statistics about emails and conversations and attach those to both.</p>
<h2 id="todo">Todo</h2>
<ul>
<li>default <strong>init</strong>? -&gt; perhaps for checks if subclassing factory family is well-defined?</li>
<li>default <strong>call</strong> function with basic functionality (that factories override if necessary)</li>
<li>parallelisation (including parameters)</li>
</ul></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="conversationkg.conversations.factories.TopicFactory.get_topic"><code class="name flex">
<span>def <span class="ident">get_topic</span></span>(<span>self, topic_dist)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_topic(self, topic_dist):
    max_prob_ind = topic_dist.argmax()
    return TopicInstance(self.topics[max_prob_ind], topic_dist[max_prob_ind])</code></pre>
</details>
</dd>
<dt id="conversationkg.conversations.factories.TopicFactory.process_conversation"><code class="name flex">
<span>def <span class="ident">process_conversation</span></span>(<span>self, conversation)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_conversation(self, conversation):
    conversation.topic = self.get_topic(next(self.conv_iter))    
    for email in conversation:
        email_topic = self.process_email(email)
    return conversation.topic</code></pre>
</details>
</dd>
<dt id="conversationkg.conversations.factories.TopicFactory.process_email"><code class="name flex">
<span>def <span class="ident">process_email</span></span>(<span>self, email)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_email(self, email):
    email.topic = self.get_topic(next(self.email_iter))
    return email.topic</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="conversationkg.conversations.factories.Factory" href="#conversationkg.conversations.factories.Factory">Factory</a></b></code>:
<ul class="hlist">
<li><code><a title="conversationkg.conversations.factories.Factory.combine_processors" href="#conversationkg.conversations.factories.Factory.combine_processors">combine_processors</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="conversationkg.conversations.factories.VectorFactory"><code class="flex name class">
<span>class <span class="ident">VectorFactory</span></span>
<span>(</span><span>corpus, vectoriser_algorithm, add_matrix_to_corpus=True, **vectoriser_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The base class for any specialised factory family, such as VectorFactory, TopicFactory, etc.
Use this class as base class to create a new factory family; perhaps for instance a StatsFactory
for a family of factories which observe statistics about emails and conversations and attach those to both.</p>
<h2 id="todo">Todo</h2>
<ul>
<li>default <strong>init</strong>? -&gt; perhaps for checks if subclassing factory family is well-defined?</li>
<li>default <strong>call</strong> function with basic functionality (that factories override if necessary)</li>
<li>parallelisation (including parameters)</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VectorFactory(Factory):
    def __init__(self, corpus, vectoriser_algorithm, add_matrix_to_corpus=True, **vectoriser_kwargs):
        default_args = dict(max_df=0.7, min_df=5)
        default_args.update(vectoriser_kwargs)

        self.fitted_corpus = corpus
        self.add_matrix = add_matrix_to_corpus
        
        self.vectoriser = vectoriser_algorithm(**default_args)
        self.matrix = self.vectoriser.fit_transform([
                            email.body.normalised for email in corpus.iter_emails()
                        ])
        self.conversation_matrix = self.vectoriser.transform(
                                    [conv.get_email_bodies(attr=&#34;normalised&#34;, join_str=&#34; &#34;) for conv in corpus]
                                    )        
        
        self.vocabulary = self.vectoriser.get_feature_names()
        

    def process_conversation(self, conversation):
        conversation.vectorised = next(self.conv_iter)
        for email in conversation:
            email_vector = self.process_email(email)
        return conversation.vectorised
    
    def process_email(self, email):
        email.body.vectorised = next(self.email_iter)
        return email.body.vectorised


    def __call__(self, corpus=None, **kwargs):
        if not corpus:
            corpus = self.fitted_corpus
        
        if self.add_matrix:
            corpus.vectorised_vocabulary = self.vocabulary
            corpus.vectorised = self.matrix
            corpus.conversations_vectorised = self.conversation_matrix        
        
        self.conv_iter = iter(self.conversation_matrix)
        self.email_iter = iter(self.matrix)
        
        return super().__call__(corpus, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="conversationkg.conversations.factories.Factory" href="#conversationkg.conversations.factories.Factory">Factory</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="conversationkg.conversations.factories.CountVectorizer" href="#conversationkg.conversations.factories.CountVectorizer">CountVectorizer</a></li>
<li><a title="conversationkg.conversations.factories.TfidfVectorizer" href="#conversationkg.conversations.factories.TfidfVectorizer">TfidfVectorizer</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="conversationkg.conversations.factories.VectorFactory.process_conversation"><code class="name flex">
<span>def <span class="ident">process_conversation</span></span>(<span>self, conversation)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_conversation(self, conversation):
    conversation.vectorised = next(self.conv_iter)
    for email in conversation:
        email_vector = self.process_email(email)
    return conversation.vectorised</code></pre>
</details>
</dd>
<dt id="conversationkg.conversations.factories.VectorFactory.process_email"><code class="name flex">
<span>def <span class="ident">process_email</span></span>(<span>self, email)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_email(self, email):
    email.body.vectorised = next(self.email_iter)
    return email.body.vectorised</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="conversationkg.conversations.factories.Factory" href="#conversationkg.conversations.factories.Factory">Factory</a></b></code>:
<ul class="hlist">
<li><code><a title="conversationkg.conversations.factories.Factory.combine_processors" href="#conversationkg.conversations.factories.Factory.combine_processors">combine_processors</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="conversationkg.conversations" href="index.html">conversationkg.conversations</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="conversationkg.conversations.factories.CountVectorizer" href="#conversationkg.conversations.factories.CountVectorizer">CountVectorizer</a></code></h4>
</li>
<li>
<h4><code><a title="conversationkg.conversations.factories.Factory" href="#conversationkg.conversations.factories.Factory">Factory</a></code></h4>
<ul class="">
<li><code><a title="conversationkg.conversations.factories.Factory.combine_processors" href="#conversationkg.conversations.factories.Factory.combine_processors">combine_processors</a></code></li>
<li><code><a title="conversationkg.conversations.factories.Factory.parallelise_call" href="#conversationkg.conversations.factories.Factory.parallelise_call">parallelise_call</a></code></li>
<li><code><a title="conversationkg.conversations.factories.Factory.process_conversation" href="#conversationkg.conversations.factories.Factory.process_conversation">process_conversation</a></code></li>
<li><code><a title="conversationkg.conversations.factories.Factory.process_email" href="#conversationkg.conversations.factories.Factory.process_email">process_email</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="conversationkg.conversations.factories.FactoryChain" href="#conversationkg.conversations.factories.FactoryChain">FactoryChain</a></code></h4>
</li>
<li>
<h4><code><a title="conversationkg.conversations.factories.GensimLDA" href="#conversationkg.conversations.factories.GensimLDA">GensimLDA</a></code></h4>
</li>
<li>
<h4><code><a title="conversationkg.conversations.factories.KeyWordFactory" href="#conversationkg.conversations.factories.KeyWordFactory">KeyWordFactory</a></code></h4>
<ul class="">
<li><code><a title="conversationkg.conversations.factories.KeyWordFactory.output_to_class" href="#conversationkg.conversations.factories.KeyWordFactory.output_to_class">output_to_class</a></code></li>
<li><code><a title="conversationkg.conversations.factories.KeyWordFactory.process_conversation" href="#conversationkg.conversations.factories.KeyWordFactory.process_conversation">process_conversation</a></code></li>
<li><code><a title="conversationkg.conversations.factories.KeyWordFactory.process_email" href="#conversationkg.conversations.factories.KeyWordFactory.process_email">process_email</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="conversationkg.conversations.factories.NamedEntityFactory" href="#conversationkg.conversations.factories.NamedEntityFactory">NamedEntityFactory</a></code></h4>
<ul class="">
<li><code><a title="conversationkg.conversations.factories.NamedEntityFactory.entity_from_NER_label" href="#conversationkg.conversations.factories.NamedEntityFactory.entity_from_NER_label">entity_from_NER_label</a></code></li>
<li><code><a title="conversationkg.conversations.factories.NamedEntityFactory.process_conversation" href="#conversationkg.conversations.factories.NamedEntityFactory.process_conversation">process_conversation</a></code></li>
<li><code><a title="conversationkg.conversations.factories.NamedEntityFactory.process_email" href="#conversationkg.conversations.factories.NamedEntityFactory.process_email">process_email</a></code></li>
<li><code><a title="conversationkg.conversations.factories.NamedEntityFactory.string_to_class" href="#conversationkg.conversations.factories.NamedEntityFactory.string_to_class">string_to_class</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="conversationkg.conversations.factories.RakeKeyWordExtractor" href="#conversationkg.conversations.factories.RakeKeyWordExtractor">RakeKeyWordExtractor</a></code></h4>
<ul class="">
<li><code><a title="conversationkg.conversations.factories.RakeKeyWordExtractor.get_keywords" href="#conversationkg.conversations.factories.RakeKeyWordExtractor.get_keywords">get_keywords</a></code></li>
<li><code><a title="conversationkg.conversations.factories.RakeKeyWordExtractor.remove_low_scores" href="#conversationkg.conversations.factories.RakeKeyWordExtractor.remove_low_scores">remove_low_scores</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="conversationkg.conversations.factories.SKLearnLDA" href="#conversationkg.conversations.factories.SKLearnLDA">SKLearnLDA</a></code></h4>
<ul class="">
<li><code><a title="conversationkg.conversations.factories.SKLearnLDA.determine_n_components" href="#conversationkg.conversations.factories.SKLearnLDA.determine_n_components">determine_n_components</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="conversationkg.conversations.factories.SpaCyNER" href="#conversationkg.conversations.factories.SpaCyNER">SpaCyNER</a></code></h4>
<ul class="">
<li><code><a title="conversationkg.conversations.factories.SpaCyNER.get_entities" href="#conversationkg.conversations.factories.SpaCyNER.get_entities">get_entities</a></code></li>
<li><code><a title="conversationkg.conversations.factories.SpaCyNER.get_entities_with_labels" href="#conversationkg.conversations.factories.SpaCyNER.get_entities_with_labels">get_entities_with_labels</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="conversationkg.conversations.factories.StanzaNER" href="#conversationkg.conversations.factories.StanzaNER">StanzaNER</a></code></h4>
<ul class="">
<li><code><a title="conversationkg.conversations.factories.StanzaNER.get_entities" href="#conversationkg.conversations.factories.StanzaNER.get_entities">get_entities</a></code></li>
<li><code><a title="conversationkg.conversations.factories.StanzaNER.get_entities_with_labels" href="#conversationkg.conversations.factories.StanzaNER.get_entities_with_labels">get_entities_with_labels</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="conversationkg.conversations.factories.TfidfVectorizer" href="#conversationkg.conversations.factories.TfidfVectorizer">TfidfVectorizer</a></code></h4>
</li>
<li>
<h4><code><a title="conversationkg.conversations.factories.TopicFactory" href="#conversationkg.conversations.factories.TopicFactory">TopicFactory</a></code></h4>
<ul class="">
<li><code><a title="conversationkg.conversations.factories.TopicFactory.depends_on" href="#conversationkg.conversations.factories.TopicFactory.depends_on">depends_on</a></code></li>
<li><code><a title="conversationkg.conversations.factories.TopicFactory.get_topic" href="#conversationkg.conversations.factories.TopicFactory.get_topic">get_topic</a></code></li>
<li><code><a title="conversationkg.conversations.factories.TopicFactory.process_conversation" href="#conversationkg.conversations.factories.TopicFactory.process_conversation">process_conversation</a></code></li>
<li><code><a title="conversationkg.conversations.factories.TopicFactory.process_email" href="#conversationkg.conversations.factories.TopicFactory.process_email">process_email</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="conversationkg.conversations.factories.VectorFactory" href="#conversationkg.conversations.factories.VectorFactory">VectorFactory</a></code></h4>
<ul class="">
<li><code><a title="conversationkg.conversations.factories.VectorFactory.process_conversation" href="#conversationkg.conversations.factories.VectorFactory.process_conversation">process_conversation</a></code></li>
<li><code><a title="conversationkg.conversations.factories.VectorFactory.process_email" href="#conversationkg.conversations.factories.VectorFactory.process_email">process_email</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>