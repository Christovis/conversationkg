      > >  > >The scalability requirements ought to be sensitive to small  > >ontologies also (or more precisely, highly granular distributed  > >ontologies) ala purvasive sensors/actuators and other small devices  > >that may describe themselves via ontology and be linked to other  > >devices where the conglomerate is also an ontology.  >  > Is, or is connected via ? The idea that a conglomerate of devices IS  > an ontology is an interesting and (to me) novel idea.  >  > >An "ontology web"  > >or "web of ontologies" has been mentioned on the list. Is scalability  > >the one word that captures all this?  >  > Yes, I wonder quite what 'scalability' is supposed to mean. Maybe an  > example of something that isn't scaleable would be helpful (?)  >  >    I can do that one! (A true story)    Suppose we are an ice cream manufacturer with subsidiaries throughout  europe.    Each subsidiary runs Oracle 8.3 (I don't whether there is such a version),  and puts their business data such as a table of wholesale and retail outlets  and the number of each product sold through each.    The table schemata are designed independently.    The table and coloumn names are of course in different languages.    They do not match up.  Even if we 'translate' them, the information in the various databases is  incompatible.    A core problem being the SKU (Stock keeping unit - approx. how many ice  creams go in a box).    A second problem being that the ice-cream consumption prediction algorithms  vary across Europe and the parameters for these algorithms vary too.    There is no viable way of wrapping the various DBs to allow  interoperability.    Result: we have spent a lot on rebranding each subsidiary to have the same  logo.  We have redesigned all our packaging to have no natural language information  on it.  It is theoretical possible to have cross border movements of ice cream, but  the information systems can't handle it.    [Cross border movements of ice-cream in Europe would be rational since  European weather is more constant than the weather in any one country].      ====    My view of the requirements is:  + we should expect different people to describe similar things in different  ways, putting emphases on different aspects.  + we enable multiple independently developed ontologies to interoperate  + we should allow/encourage the same data to be expressed in multiple ways.      Given that that is hard, simply being able to name the ontologies and all  their parts is a good thing.    I beleive that in the first instance the interoperability sought will come  from code not dissimilar to legacy wrapping code, i.e. pretty horrible.      So, in my example, I see the Italian ice-cream data being expressed in the  Italian gelato ontology. For interoperating with the French ice-cream data,  we can overlay the Italian data with additional links expressed in the  French glaces ontology. This overlay is produced (in my model) by a load of  unprincipled and essentially ad hoc code.    For me, the inconsistency issue then arises since the description of the  French glaces ontology will have arisen in a mono-cultural context, and is  likely to be self-consistent. The Italian data conforms with different  assumptions and the overlay according to the French ontology is unlikely to  be perfect. It is likely to have mistakes. If we view ontology as a  classical logic exercise every bug is fatal, since contradictions are  non-local. However, experience in integrating IT systems suggests that  conversely bugs are usually local, and that most of the time inconsistency  is bad but not fatal.    Jeremy        

        Support.      Dave Beckett wrote:    > Summary: reject  >   > The comment raised in  > http://lists.w3.org/Archives/Public/www-rdf-comments/2003JanMar/0586.html  >   > [[  >   I believe that in 7.2.19 Production parseTypeCollectionPropertyElt  >     the wording  >   >   """For each event nin s, the following statement is added to the graph:  >   >   n.string-value <http://www.w3.org/1999/02/22-rdf-syntax-ns#type>   >   <http://www.w3.org/1999/02/22-rdf-syntax-ns#List> .  >   >   >   """  >   >   adds redundant triples to the graph.  >   I believe that waste of time and space at this level in the   >   architecture is unnecessary, and that that wording should be removed   >   (and any other reference to the adding type statements for Lists where   >   a rdf:first is there).  >   >   It is trivial to restore the triples for anyone who wants them fro a   >   graph without them,  >   using  > { ?x rdf:first ?y } =>  { ?x  a rdf:List }.  > ]]  >   >   > Here is a draft response:  >   > [[  > The RDF Core WG has considered your last call comment captured in  >   >    http://www.w3.org/2001/sw/RDFCore/20030123-issues/#timbl-03  >   > (raised in  >  http://lists.w3.org/Archives/Public/www-rdf-comments/2003JanMar/0586.html  > )  >   > and decided  >   >    URL-HERE  >   > to reject it on the grounds that it is being used by OWL and could  > not be added at a higher level since it is closedly tied to an  > RDf/XML syntax abbreviation.  >   > This triple is part of the closed collection form added to the RDF  > model and RDF/XML syntax for use by OWL based on the DAML+OIL  > daml:Collection syntax extension to RDF/XML.   >   > The reason this could not be added at the OWL level is that it is  > generated by the rdf:parseType="Collection" syntax which is in the  > RDF/XML specification.  There is no "hook" to allow optional adding  > of <x> rdf:type rdf:List for the generated notes.  >   > rdf:List is refered to in several places throughtout the proposed OWL  > language and seems to have good uses:  >   >   > Example of using rdf:List explicitly for collection of datatyped literals  >   http://www.w3.org/TR/2003/WD-owl-ref-20030331/#EnumeratedDatatype  >   > As the range of these three properties:  >   owl:distinctMembers  >   owl:intersectionOf  >   owl:oneOf  >   owl:unionOf  >   > See the RDF Schema of OWL http://www.w3.org/TR/2003/WD-owl-ref-20030331/#appB  >   > typically used in the examples with rdf:parseType="Collection" form:  >   http://www.w3.org/TR/owl-guide/#EnumeratedClasses  >   http://www.w3.org/TR/owl-guide/#DisjointClasses  >   >   > Used in OWL Semantics and Abstract Syntax WD, 31 March 2003  >   >   Translation to RDF Graphs  >   http://www.w3.org/TR/2003/WD-owl-semantics-20030331/semantics-all.html#4.1  >   >   5 RDF-Compatible Model-Theoretic Semantics  >     5.2. OWL Interpretations  >   http://www.w3.org/TR/2003/WD-owl-semantics-20030331/semantics-all.html#rdf_List_rdf  >   >     if E is             then                          Note  >              SI(E)..  CEXTI(SI(E))=   and  >   >     rdf:List            IL           IL subsetof RI  This defines IL as  >                                                      the set of OWL lists.   >   > So it is needed to define OWL lists.  >   >   >   A.1 Correspondence for Descriptions (Informative)  >     Used in the proof for Lemmas 1, 4  >   >   A.2 Correspondence between OWL DL and OWL Full (Informative)  >     Used in the proof-sketch for Lemma 5  >   > ]]  >   >   > Dave  >   >         

            Pat Hayes wrote:    > We could of course offer the pragmatic advice that if ex:thing is a   > graph or a web resource, then the agent is understood to be the owner of   > that resource. But this is a work-around, seems to me, rather than a   > principled way to handle this issue.  (Can't you just hear the debates   > this will produce? People are still arguing about using homepage URIs to   > identify people.)  >   > I would like us to punt on that aspect of the whole matter, and just   > assume that there is some externally-provided way to determine if the   > agent doing the publishing is the one referred to in the graph, which is   > all that really matters. Having ex:thing be the URI of the graph or   > document is one way, but there might be others.  >     I've just tried to show how we could sketch how, ex:thing could refer to a   person or company, and then we can link the verification of sigs into   current technology (I doubt you've got there yet Pat).    However, I feel happier with a punt overall, perhaps with a short sketch   that shows how current Public Key Infrastructure can be used ...    Jeremy        

        With ARP I found three more tests that fit into our current framework  useful.    These are attached.    Two empty-property-element ones have a property element with just a  processing instruction and just a comment in.    An id-and-about one showing to give an rdf:about complementing the rdf:ID in  rdfms-difference-between-ID-and-about/test2.rdf (assuming  rdfms-difference-between-ID-and-about/test2.nt is updated to be correct).    I could add them to our test repository for consideration if people want.    Jeremy          application/x-zip-compressed attachment: foo.zip          

      Jeremy:  > >Seems like a proposal to:  > >  > >- draw the relevant XML wg's attention to difficulties in interpretating  > >xml:base with same document references, (particularly when the base is a  > >URIref).  > >  > >- select the xml:base test cases that:  > >   - test general URI resolution  > >   - test general xml:base behaviour  > >   and mark them as non-normative  Brian:  > or just delete them.  Can we have a list of the ones you think we should  > keep and we can try to decide this Friday.  >    My original message highlighted:  [[[  Test case 007 - 013      examples of the combination of a base URI and a      relative URI or same document reference, showing      various different cases.  ]]]    and the three error cases (now error001/test017 and test 15 and 16).    ===    I have difficulty with deleting these, since practically these are:  + significant  + subject to dispute    Hence, refusing to judge on this, because it is not in our competence, acts  to make the meaning of RDF/XML documents that contain XML Base (in the  dubious cases) doubtful.    The fact that they generate discussion is indicative of the need for at  least guidance from the WG; even if it is not in our competence.    Some of these test cases are no brainers, others do commit to a position.    The former are not objectionable and can be retained without much problem;  the latter are needed for a standard use of xml:base.    I am arguing a catch 22, if you want to delete these, it is because some  people disagree with them, which is why we need them. I am happy with  deleting the ones that nobody disagrees with.    cf.  http://lists.w3.org/Archives/Public/www-tag/2002Mar/0061.html    which disagrees with some of these test cases.      Jeremy        

        I had another comment:    In section 5. Infoset Conformance we say "no items are added or removed."    I think this is incorrect.    xml:lang is not described in the grammar, and can legally appear on any  element (I think).    I think xml:space is removed; I suspect all xml:* attributes are removed.      Jeremy        

          I abstained on the decision recorded, not least because I thought the rules  should be informative - and that we made the wrong call on horst-01    I am surprised to not see the record reflect a decision to make them  normative, and would welcome the proposed change to label them as  informative.    Jeremy      > -----Original Message-----  > From: w3c-rdfcore-wg-request@w3.org  > [mailto:w3c-rdfcore-wg-request@w3.org]On Behalf Of Graham Klyne  > Sent: 30 September 2003 12:00  > To: pat hayes; w3c-rdfcore-wg@w3.org  > Cc: Dan Connolly  > Subject: Re: Fwd: Re: comments on 26 September version of RDF Semantics  > document  >  >  >  > At 20:00 29/09/03 -0500, pat hayes wrote:  > >I tend to agree with Peter about the rules being normative, particularly  > >as I couldn't find a formal record of that decision either (the best I  > >could do was to link to the IRC log). [...]  >  > Me too.  After reviewing the IRC log [1], My (possibly imperfect)  > recollection was that although DanC raised the matter of making the rules  > normative, we didn't actually make a decision on that particular proposal.  >  > Having read Peter's response [2], particularly his points 1 and 3, I also  > tend to agree with keeping them informative.  >  > OTOH, Dan's argument, IIRC, was that implementers would work from  > the rules  > anyway, and if there were any divergence it may be that the model theory,  > not the rules, should be fixed up to most usefully serve the  > community.  That would be difficult position to sustain  > procedurally if the  > rules are only informative.  >  > This makes me wonder if, given that there is less implementation  > experience  > of inference based on these formal semantics, it wouldn't be more  > appropriate to request the formal semantics go to CR (with informative  > rules) rather than PR at this time?  >  > #g  > --  >  > [1] http://www.w3.org/2003/06/27-rdfcore-irc#T15-07-36  >  > [2]  http://lists.w3.org/Archives/Public/www-rdf-comments/2003JulSep/0365.html      At 20:00 29/09/03 -0500, pat hayes wrote:  >I tend to agree with Peter about the rules being normative, particularly  >as I couldn't find a formal record of that decision either (the best I  >could do was to link to the IRC log). The only coherent interpretation I  >can assign to this, on reflection, would be that any other inference  >engine which worked in some other way would not be conformant, even if it  >was complete and correct: which is silly.  Maybe y'all could just advise  >me to make section 7 informative rather than normative? I'd suggest that  >we do that before LC2, in any case.    ------------  Graham Klyne  GK@NineByNine.org        

        Thanks Brian    It feels somewhat bad mannered to ask for your reasons and then try and  rebutt them, but I guess that's the process ...    > >debate in telecon and e-mail. I would particularly like to hear from Jos  > >and Brian as to why they voted against.  >  > 1.  I see this as a change.  >  > 2.  No case for making this change has been made.      I think that a clear case has been made for the need for clarification.  A case has been made for making this changeHH^Hlarification; however  you have not found it compelling.    >  > 3.  I am wary of building on other specs that are not stable and well  >      understood.  I see no strong advantage to RDF in supporting this  >      now and it increases our risks.    I agree, and I am not advocating building on the IRI spec for that reason.  I believe that RDF Core has responsibilities to the international community  which cannot be addressed simply by saying that the IRI spec is not cooked  so we will leave things vague.  I think this decision does need to be backed up by comments on Charmod, IRI  draft (and XML 1.1 vis-a-vis namespace identifiers) that indicate where we  are going and getting consensus around that.    >  > 4.  As most implemenations don't support it now, it will decrease  >      interoperability    interoperability of US-ASCII URIs is not impacted.  There is no current interoperability of non US-ASCII URIs because no spec  indicates whether upper case or lower case % escaping should be done.    >  > 5.  This is pushing our charter; it violates the closest thing I have to  >      a principal for what is in and what is out of charter    I think this reflects item 2. You find the need for clarification less than  compelling; hence you have doubts about whether this is in-scope.    >  > There is no strong reason to do it now.  There are disadvantages to doing  > it now.  Don't do it now.    If we are convinced that this change is right, it costs less to make the  change now than in the future.    >  > Brian  >  >    Jeremy        

        >   > Only parsers need change, so that they give the inline literals  > the needed systemID prefix.    This fails the old self-entailment test:    <rdf:Description>    <eg:name>Patrick Stickler</eg:name>  </rdf:Description>    is neither equal to, not does it entail,    <rdf:Description>    <eg:name>Patrick Stickler</eg:name>  </rdf:Description>    A position that was rejected a long time back.    Jeremy        

      Jeremy:  > > Dark triples  > > [ ... ] are not in RDF M&S; they are not necessary; they do not clarify  > > M&S; they are not in charter.  > >  >    Frank:  > I'd like to see some amplification of the "they are not necessary" point  > before we make any decision on this.  The other points may be  > procedurally correct, but may be less important than the "semantics" of  > the issue (if you will).  For example, regarding the fact that they are  > not in M&S, presumably we're allowed to consider the new situations in  > which RDF may need to be used (e.g., supporting WebONT) that have come  > to prominence since M&S went to CR?  Even if we made a decision to drop  > this matter, I'd like to see us say something constructive about the  > issue of unasserted triples for the record (rather than just drop it as  > not being in charter).  >    My message reflected frustration I am feeling on WebOnt.    In DAML+OIL the syntax of the language is encoded *within* the model rather  than external to the model and merely interpreted in the semantics.    We see this too in RDFS consider:    A:  <my:range> <rdfs:subPropertyOf> <rdfs:range> .  <eg:foo> <my:range> <eg:bar> .  <a> <eg:foo> <b> .    The triples both map into the model, then within the model an RDFS  interpretation is constrained to understand the implicit triple "<eg:foo>  <rdfs:range> <eg:bar> ." and then that in turn constrains the interpretation  of the explicit triple "<a> <eg:foo> <b> ."  If we treated RDFS as merely a syntactic carrier then the fact that there  are not explicit <rdfs:range> triples in the original graph (A) means that  there are no range constraints to consider.    On WebOnt, Pat and Peter have both asserted that we need to use the RDF  graph as the syntactic carrier and not have such syntax reflected in the  model.    However, this assertion, while it is still being explored, currently appears  to me to be false. It seems possibly to encode the syntax within the model  theoretic interpretation (at least for webonts needs). I would like to see  examples where this is not possible (ideally in-charter examples).    In practice, nothing will stop people who want to treat the RDF graph  independently of its model theoretic semantics. However, *we* should, IMO,  not be licensing or encouraging such behaviour unless we believe it to be  advantageous.    I believe that such behaviour is disadvantageous, because it will mean the  extension mechansim available in RDFS, such as rdfs:subPropertyOf are only  applicable when people are using the model theory and not otherwise. Thus  these extension mechanisms will become a source of confusion, and fall into  disrepute. RDF document authors will need to know whether or not their  application is using asserted or unasserted triples.    The weasle words turn a normative specification into non-normative advice,  because anyone who doesn't like Pat's excellent work can simply say, "Ah,  but my graph isn't asserted"    Jeremy        

            I have been being beaten up further from the pragmatic wing  by Chris  Bizer - He is beginning to convince me ...      My understanding of his key arguments is as follows:    - use vocab as much as possible, not syntactic mechanisms      : impacts graphset tag name                asserted attribute    - meaning of vocab is shared: for example log:implies is ill-formed RDF,  because to make sense of it you have to use a second interpretation that  interprets concepts differently from the first. So the liar paradox is  resolved by saying that RDF is not a general purpose meta language for  logic.     : impacts semantics, outlaws log: vocab    - the de re/de dicto argument is hence resolved largely in favour of de re,  but to some extent is seen as a red herring. For provenance information it  is certainly helpful to regard the provenance statements as being about a  'de dicto' graph; but this is not because we doubt that the author may be  using the URIs differently from us.     : impacts semantics    I guess one way of doing this is to say that the interpretation of the  name of a graph is the pair consisting of the graph and a set of the  interpreted triples, and the predicate selects which member of the pair is  interesting...      - whether we believe any graph or not is a matter for the trust layer.  Example below. Chris's PhD (in progress) is on the trust layer.  His  approach is very pragmatic - users have a trust policy that can take into  account facts about the contents and or use of a graph to determine whether  to believe it. Such a policy is not a logically mechanism, much more  prgamatic and down-to-earth. This makes the distinction between asserted and  non-asserted graphs redundant.    - the graphset in trix is merely a syntactic necessity for XML documents,  and should not convey any meaning. If we want to talk about a collection in  RDF there are plenty of mechanisms. So if we want to talk about a collection  of graphs we use one of those. Thus, the graphset tag should be changed to  something semantic-free (e.g. trix). It should be explicitly stated that the  URL used to retrieve a trix document refers to the document and not to the  contained graphs. The point here is to stop before going on the slippery  slop to graphsetsetsets      His words are at:  http://lists.w3.org/Archives/Public/www-archive/2004Feb/att-0050/namedGraphD  iscussion009.pdf      Example: Provenance Chains  Peter states, that Chris said that Andy said, that Monica Murphy is a  person.    G1 (Monica ex:hasName "Monica Murphy".      Monica rdf:type ex:Person)    G2 (G1 ex:saidby Andy.      G1 ex:DocumentURL Doc1.trix.      G1 dc:date "2/10/2004")    G3 (G2 ex:saidby Chris.      G2 ex:DocumentURL Doc2.trix.      G2 dc:date "2/10/2004")    G4 (G1 dc:author Peter.      G2 dc:author Peter.      G3 dc:author Peter.)    G5 (G4 dc:author Peter.      G4 dc:date "2/10/2004")    Depending on our trust policy we might believe some, all or none of the  above triples...      Jeremy        

        The RDF specification shows how labelled graphs can be encoded in XML.    e.g. the graph    http://lists.w3.org/Archives/Public/www-archive/2001Jun/att-0021/00-part#38    is encoded as    http://lists.w3.org/Archives/Public/www-archive/2001Jun/att-0021/00-part#65          It permits the use of well-balanced fragments of XML as one sort of label,  and refers to these as "XML Literals".    A typical example is:    <rdf:Description    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"    xmlns:dc="http://purl.org/metadata/dublin_core#"    xmlns="http://www.w3.org/1999/xhtml"    rdf:about="http://example.org/papers/paper1">    <dc:Title rdf:parseType="Literal"><!-- Relevant text start. -->      Foo<em>bar</em>    <!-- Relevant text end. --></dc:Title>  </rdf:Description>    Many users may omit the default xmlns declaration.    It is unclear precisely what the label in the RDF graph is.  There is agreement that the relevant text in the input file lies between the  two comments.    Some RDF APIs provide a string, others provide a means of accessing the SAX  events.  This is the content of the issue  http://www.w3.org/2000/03/rdf-tracking/#rdfms-literal-is-xml-structure    As will be familiar to the C14N people, there are specific issues to do with  namespace processing.    These are identified in:  http://www.w3.org/2000/03/rdf-tracking/#rdfms-xml-literal-namespaces  and also present in an example in the spec.  http://lists.w3.org/Archives/Public/www-archive/2001Jun/att-0021/00-part#257    Other problems relate to inconsistent treatment of character references etc.  which, for instance, the HP team found problematic when upgrading Jena to  work with ARP instead of RDFFilter. The two parsers had taken different  choices with respect to the exact representation of xml literals and the  regression tests then failed.    A large part of RDF Core WG's work has been making RDF more formal.  Particularly the RDF test cases and RDF model theory depend upon a well  defined equality over node labels.    These goals are in conflict with the current spec. that explicitly ducks the  issue of equality.    http://lists.w3.org/Archives/Public/www-archive/2001Jun/att-0021/00-part#220  [[[  This specification does not state a mechanism for determining equivalence  between literals that contain markup, nor whether such a mechanism is  guaranteed to exist  ]]]  RDF Model Theory  http://www.w3.org/TR/rdf-mt/  RDF Test Cases  http://www.w3.org/TR/2001/WD-rdf-testcases-20010912/      Hence, a resolution of these issues will give:  - a set of representation for XML Literals,  - a means for turning a specific well balanced XML fragment into such a  representation  - a means for comparing two such representations for equality    The RDF Core is currently agreed that C14N will be the basis of addressing  these issues.        

          Patrick provided some pictures of the syntactically transformed TDL idioms  modelled within S-P.    Jeremy      Patrick says:    The slides depict (1) the minimal, basic idiom for all literal values,  (2) mulitiple locally defined types, (3) multiple globally defined  types, and (4) cohabitation of local and global typing. It is presumed  in slide 1 that the interpretation (complete TDL) is provided by  the application environment, or by some subsequently syndicated global  typing.                                

      > I'm starting to think this is worth changing the charter over:  > if the xml:lang stuff is to be significant, it must be  > in triple form.    This issue came up at today's telecon.  Both chairs indicated that if the WG goes with Sergey's suggestion of using  bNodes for expressing structured literals, and the WG felt that the  lang-string stuff was too much in conflict with this, then we should seek to  be rechartered. (And I think I understood this more generally, i.e. the  charter requirement to move forward on types may require us to request an  easing of some of our other charter restrictions).    For what its worth, using Jena 1.2 does give programmatic access to the  xml:lang read in from RDF/XML. I believe we do not yet do lang tag  comparison in a case insensitive fashion, but I think ARP normalizes case on  input.    Jeremy        

          [[  A:  Option 2     straw poll:     "We prefer Option 2 to no change."      If Yes then       straw poll - we prefer option 1 to option 2            straw poll - we prefer option 3 to option 2            straw poll - we prefer option 4 to option 2    each with fors, against and strongly against (i.e. would vote against in formal vote).    Chair to put question (option 1,2,3 or 4) based on results of staw polls.    If no to A, then no question is put.      ]]    Rationale:    Option 2 is the smallest sensible change, if we prefer the status quo to option 2, then we should do nothing. Otherwise we should decide to go for option 2 or more sophisticated, and then see if we have support for a more sophisticated XMLLiteral solution (options 1, 3 or 4).    Jeremy        

      Sorry I have made some significant mistakes in my test suite msg, a new  version in half-hour or so.    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Jan/0386.html    Jeremy        

      Pat    part 1:  I think we made progress ...      swp:assertedBy . swp:authority    is true when the authority asserts the graph,  part 2:    and from the point of view of the authority, this includes the truth of   the graph itself.    (note we had that when the authority provided the graph, but that is not   needed, if Pat asserts `Jeremy asserts "foo bar"', then for me, `Jeremy   asserts "foo bar"' is true if:  a) I asserted "foo bar"  and  b) "foo bar"    even though you (or anyone else) might be providing the graph.        Also another zip mainly for my convenience (as I move from home to office),   I am expecting some new text from Pat on swp:assertedBy as a performative   which I will integrate in.    I don't think it differs much from before.    Jeremy                  application/x-zip-compressed attachment: ng2.zip          

      >  > This treats a missing tag as synonymous with the RFC 3066 language range  > "*", which matches any tag.  >    At the plenary, in discussion with Misha and Martin, it became clear that  there are two equalities needed.    The RDF specs need a mathematically rigorous and transitive equality. User  applications probably want an equality following John's proposal.    The RDF specs need to clarify that application developers are not misled  that the transitive equality is normative for all uses.    The RDF Core has agreed that the definition of equality is as I earlier  indicated, with exact (case insensitive) matching of lang-tags.    Misha suggested that we should use a note to clarify this.    Thus I propose that text such as the following is included near the  definition of literal equality:    [[[    NOTE: This definition of equality is appropriate when constructing an RDF  graph, when checking an RDF test case, and when interpreting an RDF graph  according to the RDF model theory. In other contexts it is usually more  appropriate to use the methods described in RFC 3066 treating a missing  language tag as "*".    ]]]        

        > Recently, there've been a wave of criticism of the S proposal on the  > list. I'd like to address a central concern here.    As part of that wave, I would like to acknowledge that idiom B is an  interesting way forward that I had not appreciated before; sorry for not  having read all the messages adequately.      Jeremy        

          The main planks of Pat's text from    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2003Jul/0452    seemed to get support at the RDF Core WG telecon on Friday, I was actioned  to move the conversation forward, and ensure that Martin and I18N were in on  it.  My understanding is that the main goal was to avoid any possibility of  confusing XMLLiteral with xsd:hexBinary as in Martin's test case.    I also am trying to adequately address Patrick's concerns while changing  Pat's text as little as possible.    Brian used the term "XML fragment" at the telecon, I am however sticking  with Pat's "XML value" because of the existence of    http://www.w3.org/TR/xml-fragment    which makes Brian's preferred term misleading.  I would be happy to consider other words for XML value.    For completeness I also include stuff on the lexical space, since there was  some concern that the wording is not about Unicde strings ... and the word  "corresponding" ...    I have numbered the notes for the sake of this e-mail, further discussion  below.    Patrick - please indicate whether the last two notes (2,3) adequately  address your concerns. (3) ended up perhaps more geared towards some of  Martin's concerns.    I ended up unclear as to whether note 2 was wanted by the WG or not.    [[  The lexical space    is the set of all strings which:    + are well-balanced, self-contained XML data [XML];    + correspond  under [UTF-8] encoding to exclusive Canonical      XML (with comments, with empty InclusiveNamespaces      PrefixList ) [XML-XC14N];    + when embedded between an arbitrary XML start tag and an end tag      correspond to a document conforming to XML Namespaces [XML-NS]      The value space is a set of entities, called XML values, which is:    + disjoint from the lexical space    + disjoint from the value space of any XML schema datatype [XML-SCHEMA2]    + disjoint from the set of Unicode character strings [Unicode]    + in 1:1 correspondence with the lexical space.        The lexical-to-value mapping     is a one-one mapping from the lexical space onto the value space,     i.e. it is both injective and surjective.        Note (1): Not all lexical forms of this datatype are compliant with XML 1.1  [XML 1.1]. If compliance with XML 1.1 is desired, then only those that are  fully normalized according to XML 1.1 should be used.    Note (2): XML values can be thought of as the [XML Infoset] or  the [XPath] nodeset corresponding to the lexical form, with an appropriate  equality function.    Note (3): RDF applications may use additional equivalence relations, such as  that which relates an xsd:string with an rdf:XMLLiteral corresponding to a  single text node of the same string.    ]]      I seem to recall concern about putting too much into notes. Either the stuff  is sufficiently important to go into the design, or it isn't.    This may be sufficient to kill notes (2) and (3). I am reluctant to drop  note (1) since the RDF specs have largely followed charmod on NFC which puts  us into a somewhat anomolous position between XML 1.0 and XML 1.1 ...    If the notes add clarity then it is probably best to keep them.        

          We need to finalize a namespace URI for this round of publications.    I suggest we go with something on Patrick's TriX site since he does a good   job of keeping it up to date.    So suggest patrick gets to choose a URI directory and the following files   therein:    - a trix namespace, with DTD and XML Schema  - an rdfg namespace with RDFS/OWL Schema  - an swp namespace with RDFS/OWL Schema    do we need anything else?    Jeremy        

            > The linkchecker has this function, but only available as a command line  > parameter; cf http://www.aero.jussieu.fr/WEB-outils/docs/checklink.html  >   > (I agree that having this as an advanced capabitility of the on-line  > version would be good; but this is better proposed/discussed on  > www-validator)  >       Perhaps this is on-topic for this list then ...  the needs of multidocument spec-prod would be better met by having support   for a specific link checker for each multidocument set.  e.g. for OWL there would be a particular page with the mappings set (by   perhaps the team contact)  Each editor could then use that page to check their document.    I suppose this could be provided by the link checker page accepting a query   part of the URI that sets up the mappings. (Then the multidocument set   specific checker would just be the standard link checker with a specific   query part).    Jeremy        

      Thanks Graham for your details comments.  Much appreciated.      J:  > >[12]  > >RDF/XML documents SHOULD be W3C-normalized as specified in  > >[CHARMOD]. Moreover, after the stripping of comments and  > >processing instructions an RDF/XML document SHOULD still be  > >W3C-normalized. It is the responsibility of the document  > >creator to fulfil this requirement. RDF/XML processors MUST NOT  > >correct input that is not W3C-normalized.    gk:  >  > I'm not sure what is the value of saying this.  >  > It seems to me that this would be an application concern,  > if an RDF processor is still expected to accept non-normalized XML  > as a literal.  Hence I'd rather say nothing here.    My reading of CHARMOD was that the principle of early normalization was  important. To be in accord with this, we should prohibit later  normalization.    From:    http://www.w3.org/TR/2001/WD-charmod-20010126/#sec-Normalization    I read "Without a precise specification, it is not possible to determine  reliably whether or not two strings are identical. Such a specification must  take into account character encoding, the way to perform normalization and  where or when to perform it."    Since I have seen defining literal equality as an important part of the  literal specification, I have seen it as significant to spend some effort on  specifying precise normalization behaviour.    There is a requirement on document authors (to produce W3C-normalized  documents) and on document processors (not to normalize). My understanding  is that this is a robust requirement in the sense that it only fails if both  parties screw up, if only one does then it succeeds.      >  > >[13]  > >RDF/XML processors MAY detect lack of W3C-normalization in  > >an input document, and issue a diagnostic.  >  > Similarly, I don't think this has any place in the RDF  > specification, other  > than perhaps as a non-normative implementation recommendation (hence not  > using RFC 2119 form - may rather than MAY).  Agreed 'may' not 'MAY', it was really only a concession after the rather  harsh MUST NOT in para [12], and was intended to be read in the context of  that MUST NOT. Perhaps sticking it in brackets and adding it to the end of  [12] would convey that better.      >  > >[14]  > >Summary of text normalization for RDF/XML processors.  > >RDF/XML processors MUST use a normalizing transcoder  > >from non-UCS-based encodings.  > >RDF/XML processors MUST NOT do any other text normalization.  >  > What's a normalizing transcoder in this context?  (I think this means  > conversion to character-normalized UCS/Unicode.)  >  > [Later:  now I see --  > http://www.w3.org/TR/charmod/#def-normalizing-transcoder;  > citation at this  > point would be helpful.].    Agreed.      >  > >[15]  > >Unicode string equality within Literals is given by binary  > >equality.  > >(cf. http://www.w3.org/TR/charmod/#sec-IdentityMatching )  >  > I think the expression "binary equality" here is an  > over-simplification of  > the cited identity matching algorithm;  I'd suggest describing it as  > "String identity matching, per [citation]".    Again quoting from charmod:    "1. Early uniform normalization to W3C-normalized form, as defined in 4.2.2  W3C-normalized Text  2. Conversion to a common encoding of UCS, if necessary  3. Expansion of all escapes  4. Binary comparison"    Since the text has already ensured steps 1, 2 and 3, all that remains is  step 4. I am happy to substitute "binary comparison" for "binary equality"  or even "binary comparison as given by  http://www.w3.org/TR/charmod/#sec-IdentityMatching"      >  >  > >[33]  > >RDF Literals arising from the propertyElt production with  > >rdf:parseType="Literal" attribute (using the [n]th production  > >of 6.12):  >  > I think the indicated transformations are legitimate for *any* value of  > parseType;  if parseType='Resource' that would not affect the resultant  > RDF, and for other values of parseType, if they are not recognized then  > they may be treated as 'Literal' per spec.  >    Hmm, I'll think about this one. Personally I am not sure I would want the  spec to continue to say what to do with unrecognised values of parseType.  The old spec has the strange behaviour of saying that parseType must be  "Resource" or "Literal", but if it isn't there is what you do ....      Once again, thanks a lot for a thorough read. Later in the week I'll  incorporate comments and send out a new version of the text.    Jeremy        

            > -----Original Message-----  > From: w3c-rdfcore-wg-request@w3.org  > [mailto:w3c-rdfcore-wg-request@w3.org]On Behalf Of Patrick Stickler  > Sent: 17 October 2002 08:14  > To: ext Jos De_Roo; ext Brian McBride  > Cc: Dan Connolly; w3c-rdfcore-wg@w3.org; Graham Klyne  > Subject: Re: details of rdf:datatype?  >  >  >  >  >  > [Patrick Stickler, Nokia/Finland, (+358 40) 801 9690,  > patrick.stickler@nokia.com]  >  >  > ----- Original Message -----  > From: "ext Brian McBride" <bwm@hplb.hpl.hp.com>  > To: "Patrick Stickler" <patrick.stickler@nokia.com>; "ext Jos  > De_Roo" <jos.deroo.jd@belgium.agfa.com>  > Cc: "Dan Connolly" <connolly@w3.org>; <w3c-rdfcore-wg@w3.org>;  > "Graham Klyne" <Graham.Klyne@MIMEsweeper.com>  > Sent: 16 October, 2002 19:16  > Subject: Re: details of rdf:datatype?  >  >  > > At 11:20 16/10/2002 +0300, Patrick Stickler wrote:  > >  > > [...]  > >  > >  > > >Firstly, one cannot presume that all datatypes define a canonical  > > >representation for all values and thus that it is possible to obtain  > > >such a canonical representation, so basing anything on canonical  > > >representations is simply not feasible. Please stop referring to  > > >canonical lexical forms. They don't exist in RDF datatyping.  > >  > > Puzzled frown.  Have I lost the plot here?  It looks to me as  > though Jos is  > > describing an implementation strategy for value based  > entailments.  As far  > > as I'm concerned, that is a relevant contribution.  >  > Well, if it is based on the presumption that there is a canonical  > space defined for every rdfs:Datatype, then it is not addressing  > the full breadth of RDF Datatyping and as such will have incomplete  > utility.  >  > I was simply pointing this out.  >  > But of course, implementors are free to do as they like.  >  > Patrick  >  >    For any datatype one could define a canonical form if one so chose.  So requiring RDF datatypes is a possibility. (Technically I have required  certain transfinite type systems to invoke the axiom of choice! but I  suspect all realistic type systems are safely countable).    The text in the minority version is intended to utilize a canonical form if  one is provided, and not if not.    Jeremy        

      Testing        

        > I(n) = GN(n) for n in the set of graph-reference names; and  > for all n such that <I(n), agent> in IEXT(I(rdfg:assertedBy)),  > I(GN(n)) = true .  >  >    I am very dubious about the above - the doubt is about trying to add special  conditions for IEXT(I(rdfg:assertedBy)).    In my view, we should regard assertedBy as a *social* act not a *logical*  act. Thus an assertedBy statement is true if and only if the object of the  statement is an agent, and the subject of the statement is a graph and the  agent did indeed aassert the graph. Whether the graph is true or not does  not impact the truth of the assertedBy statement.    However a hasSignature statement can be given a formal meaning grounded in  society.    Thus I would suggest the formal aspects are limited:  1) how graph naming fits  2) digital sigs    and other things that do not presuppose that all authorities agree with one  another.    Jeremy        

        There are currently available general purpose RDF environments with some  type support that do things differently from S.    I do not believe that there are any which do things remotely similarly to S.    DanC:  >  > Do you have some RDF software that treats the value of  > that property as a date?  >    Jena has API support for integers and floating point values in terms of  regarding the integer or floating point as the interesting value and the  string just as a lexicalisation.    See in particular:    http://www.hpl.hp.com/semweb/javadoc/com/hp/hpl/mesa/rdf/jena/model/Resource  .html#addProperty(com.hp.hpl.mesa.rdf.jena.model.Property,%20long)    and    http://www.hpl.hp.com/semweb/javadoc/com/hp/hpl/mesa/rdf/jena/model/Resource  .html#hasProperty(com.hp.hpl.mesa.rdf.jena.model.Property,%20double)    > Applications on top of RDF parsers that know about dc:date  > take the string and do date stuff with it. But not  > the RDF parser itself.    I don't think we should make a distinction between the parser and the rest  of the RDF processing. A valid implementation of a type mechanism might  include an untyped treatment during parsing and applying type rules later.  Stuff which requires application specific treatment and can't go into a  general platform is all that is application specific.    Giving the lack of type support in RDF M&S all a general purpose platform  can do is give support for the application programmer who has to know which  values get converted and which don't.    Query languages such as    http://swordfish.rdfweb.org:8085/rdfquery/index.html    (which is supported in Jena) currently take a very liberal view to typing.  If it fits the lexical space of an integer, and the query treats it as an  integer then it is an integer for now.    Both Jena and Swish take the view that Patrick is championing that the  string is just the lexical form, and there is some other value that is not a  string trying to get out.    Concerning Jena, I believe the HP developers will make the effort to support  whatever this WG recommends. My point is that S will probably require more  work than some of the other proposals.    Jeremy        

        This is the summary report of my review of the editor's draft of the Syntax  doc (revision 1.350).    The WG should not publish this document.  The editor has refused to address my main point.    Hence I propose that the WG:    - actions the editor to delete section 2 "An XML syntax for RDF" (approx 10  pages)  - publish the WD subject to this and other editorial changes at editor's  discretion      ===    I would hope that any opposition to this proposal would come from people who  have read section 2. I would hope that any opposition took account of the  large number of very substantial editorial changes proposed by myself and  Brian (I reattach my review copy, the previous version missed two  </span>'s).    In particular if this proposal is rejected I would expect that that means  that a majority of the WG believe that, in the time available, section 2 can  be made into something that will help the reader of the document understand  the substantive content (in sections 5 - 9).  Moreover, the degree of this help must justify the length of the section.    ===    I have previously indicated a willingness to compromise on having the  section clearly labelled as informative.    If there is a majority in the WG who, having reviewed the section, believe  this compromise is workable, then I suggest that:  - the section should be moved to being a non-normative appendix  - that the appendix be on a separate html page in a compound document    Moreover, I think that to make it a contribution to the community's  understanding of RDF/XML rather than an obstacle there is still a  substantial amount of editorial work to do - in terms of making the  descriptions clear, correct and concise; and in relating these descriptions  to the substantive section (particularly the productions in section 7). The  quantity of this editorial work, and the shortness of time in which to do  it, suggests that the document needs an additional editor, who I would  expect to emerge from the majority who felt that these examples were worth  the effort. I would hope that such an editor would make efforts to use  declarative descriptions of the examples, rather than the procedural  descriptions that Dave has used.    <<aside:  The deletion of the italian  <rdf:Description rdf:about="http://www.w3.org/TR/rdf-syntax-grammar">  <dc:description xml:lang="it">Il Pagio di Web Fuba</dc:description>    should be required in any case.  It is inappropriately (and untruthfully) boastful (approx: "The coolest web  page")  >>    ===    I feel that the best way forward is:    - acceptance of my proposed resolution above  - if the editor believes it is necessary to give examples of use of each  production, that such examples should be added to the test cases.  - in section 7, after each production, a link to the relavant example is  given.    If WG thinks Dave's section 2 could be a contribution to the community, he  should be encouraged to work on the many editorial comments he has already  received, and publish it through some refereed channel - like - if he were  quick - he could submit it for consideration for WWW2003; more realistically  maybe ISWC2003    ===    I regret that I will be unable to attend the telecon tomorrow, I trust the  chair will represent my position.    ===    There are other points, the important ones Dave has already accepted.    A technical issue that we have not discussed is XML validation, which can  change the infoset over which the grammar operates. I suggest we should have  telecon time on this topic after publication - I could prepare some test  cases.    Jeremy            text/html attachment: dave.html          

          Bill and I have produced the attached text for your consideration.    The goal is to have something that we might agree on, and if so, then the  various editors can cut and paste out of this text as appropriate. [Some of  the text is more relevant to the model theory (not this draft!), some to the  syntax, some to the primer].    I apologise for rather ducking the (unminuted) request to explain how to  modify the (unicode string, RFC3066 lang tag) representation to have a  general URI rather than a language tag. Paras [2] and [3] are the limit of  the treatment of this proposal.    If we've time, I would like to discuss this text at Friday's teleconference.    Jeremy    PS Brian has put in a bug report against ARP's handling of  parseType="Literal", which is pretty weak. I am hoping to get agreement to  this text so that I can bounce it!          text/plain attachment: literals.txt          

          I support this.    Two points:    1) We could include this ref to aczels work, which indicates that it is   nearly twenty years old.      Aczel, Peter Non-Well-Founded Sets. With a Foreword by Jon Barwise.   Distributed for the Center for the Study of Language and Information. 131   p. 1988 Series: (CSLI-LN) Lecture Notes    (I have seen a ref to the unpublished manuscript dated 1985)    2) I think the OWL DL work should be reference to the WebOnt WG rather than   myself, I will dig out appropriate refs in response to your qu-03 comment.    Jeremy        

      Jeremy Carroll wrote:    >   > This is now the submitted version (the PDF is one I have downloaded from   > the site, after having uploaded it)    Another one.    Changes are mainly trivial; the most significant changes are 1 substantive   change to Pat's text in section 2, and wording alignments between sections   2 and 6.2 (also Pat's text).    Acknowledgements now fit.    The substantive change is that the old text talked about interpretations of   named graphs, and said that if I satisfies g then I(name(g)) = g; I don't   believe we interpret named graphs at all, merely the graphs (or a merge   thereof) within the named graphs. Hence I have changed this to say that an   interpretation conforms with a set of named graphs N if for every ng in N   then I(name(ng)) = ng.    I have followed Chris's suggestion and capitalized Named Graph throughout,   but personally I find it ugly.    Jeremy              application/pdf attachment: PID-FAFPGYHS-1081860211.pdf          

          > > <rdf:Description rdf:about="http://www.example.org/a">  > >    <eg:prop rdf:datatype="&xsd;int">3</eg:prop>  > > </rdf:Description>  > >  > > Does not entail  >  > Does not RDF or RDFS entail, but *does* datatype entail, right?  >  > > <rdf:Description rdf:about="http://www.example.org/a">  > >    <eg:prop rdf:datatype="&xsd;int"> 3 </eg:prop>  > > </rdf:Description>  > >    No it doesn't entail at all.    " 3 " is not an integer but "3" is. So the second graph is not a consequence  of the first, because the whitespace makes a difference.    (I frankly haven't a clue what the second graph means - I promised Brian I  would read the semantics editors draft before the telecon, so I might know  by then).    Jeremy        

      > > > 2) RFC2396 the URI spec so far, and I have to build  > > > stuff like our R representative mechanism on top of that  > > >  > >  > > ??? (Sorry I haven't understood)  >   > from RFC2396 (on top of which which we try to build running code)  >   >    For original character sequences that contain non-ASCII characters,  >    however, the situation is more difficult. Internet protocols that  >    transmit octet sequences intended to represent character sequences  >    are expected to provide some way of identifying the charset used, if  >    there might be more than one [RFC2277].  However, there is currently  >    no provision within the generic URI syntax to accomplish this  >    identification. An individual URI scheme may require a single  >    charset, define a default charset, or provide a way to indicate the  >    charset used.  >   >    It is expected that a systematic treatment of character encoding  >    within URI will be developed as a future modification of this  >    specification.  >     Yes, any final text must clarify UTF-8 as the charset.    Jeremy        

          Strong oppose.    Specific problem: what does:    <rdf:Description>    <eg:prop rdf:nodeID="a"/>  </rdf:Description>    generate.    It currently generates    _:xx eg:prop _:a .    where _:xx corresponds to rdf:Description.    Generic problem:  I agree this functionality would perhaps be useful, but RDF/XML suffers too  many 'useful' productions. We have got rid of enough, and clarified enough  to begin to make it possible to expect people to actually understand RDF/XML  (all of it); steps to add more abbreviated forms should be taken with great  care.    Jeremy    > -----Original Message-----  > From: w3c-rdfcore-wg-request@w3.org  > [mailto:w3c-rdfcore-wg-request@w3.org]On Behalf Of Dave Beckett  > Sent: 07 April 2003 16:29  > To: w3c-rdfcore-wg@w3.org  > Subject: rdf:nodeID on properties for refiication  >  >  >  >  > This is from the "giving yourself more work" category.  >  > It does not address a last call issue and is thus optional.  >  > Privately, I've been asked if rdf:nodeID could be allowed on  > properties so that statements could be reified with a blank node  > identifier rather than a URI being required.  >  > i.e. Presently allowed:  >  > ----------------------------------------------------------------------  > <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"  >          xmlns:ex="http://example.org/vocab#">  >   <rdf:Description rdf:about="http://example.org/node">  >  >     <ex:foo rdf:ID="abc">foo</ex:foo>  >  >   </rdf:Description>  > </rdf:RDF>  > ----------------------------------------------------------------------  >  >  > making the 4 reification triples with reified node with URI <baseURI#abc>  >  > <baseURI#abc> rdf:type rdf:Statement .  > <baseURI#abc> rdf:subject <http://example.org/node> .  > <baseURI#abc> rdf:predicate <http://example.org/vocab#foo> .  > <baseURI#abc> rdf:object "foo" .  >  >  > Presently forbidden:  > ----------------------------------------------------------------------  > <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"  >          xmlns:ex="http://example.org/vocab#">  >   <rdf:Description rdf:about="http://example.org/node">  >  >     <ex:foo rdf:nodeID="rei">foo</ex:foo>  >  >   </rdf:Description>  > </rdf:RDF>  > ----------------------------------------------------------------------  >  > making the 4 reification triples with blank node ID _:abc  >  > _:rei rdf:type rdf:Statement .  > _:rei rdf:subject <http://example.org/node> .  > _:rei rdf:predicate <http://example.org/vocab#foo> .  > _:rei rdf:object "foo" .  >  >  > Pros:  >   Flexibility  >   Consistency  >   No need to invent a URI  >  > Cons:  >   Another change  >   3 places to put rdf:nodeID - will this confuse?  >  >  > This would have low syntax doc impact, but would need some minor new  > words.  >  > In terms of implementing, I don't see it as too hard.  >  > Dave  >  >        

          I have now republished with changes from Graham and Pat.    I think the current version is ready for WG review, although if Graham gets   me any further changes before the telecon tomorrow I will include them.    I list the latest changes below (the very last one is possibly the most   interesting, concerning synonyms for XMLLiteral).    Patrick:   >>> "The datatype abstraction used in RDF is compatible with   >>>  XML Schema Part 2: Datatypes..."    Pat on datatypes:   > That reads OK to me also as a first sentence, although you might want to   > qualify it pretty quickly since we explicitly rule out some of the XMLS   > datatypes as being incompatible.    I now have " ... is compatible with the abstraction used in XML Schema ..."    I also explicitly say at end    "[RDF-SEMANTICS] contains a more detailed discussion of specific XML Schema   built-in datatypes."    If Pat could provide an anchor on the table of XSD datatypes then I would   link directly to that.    gk:   > I agree.  But I think the following:   >   > [[   > A URI reference or literal used as a node identifies what that node   > represents. A URI reference used as a predicate identifies the   > relationship between the nodes it connects. A predicate URI reference   > may also be a node in the graph.   > ]]       > should be revised to say something like   > "... identifies the relationship between the things represented by the   nodes it connects"    I did this and also changed from "the relationship" to "a relationship"      jeremy concerning semantics:   > Are the following two phrases from concepts OK or should they be changed:   >   > a)   >   > "A datatype is identified by a URI."   >   > b)   > concerning XMLLiteral   >   > "The datatype URI   > is http://www.w3.org/1999/02/22-rdf-syntax-ns#XMLLiteral."   >   > possible change to a) is e.g.   > "A datatype may be identified by one or more URI references"    The new text is:  "A datatype is identified by one or more URI references"    which excludes a free floating datatype with no URI but makes no unique   names assumption. I beleive this agrees with semantics.     >   > possible change to b) is e.g.   >   > "A datatype URI reference   > is http://www.w3.org/1999/02/22-rdf-syntax-ns#XMLLiteral."   > or   > "The preferred URI reference   > is ..."   >    The new text reads:  "A URI reference for identifying this datatype  is ..."    Brian reminds me:   > 2002-11-22#5      jjc      check that RDF Concepts does not allow a   > synonym for rdf:XMLLiteral      The text above is intended to allow a synonym, without actually saying so   explicitly. If the WG believes this detail does need explicit text I have a   weak preference for it to go in semantics.    Jeremy        

      Bill:  > ***the purpose of 'should not' is to allow applications some flexibility  > on dealing with language tags. That is, when a literal is equal to  > another but only one has a lag tag, they can be considered equivalent,  > which might be sufficient for some applications to make a match.      Pat:  > I find this odd. Why not let them be equal in this case? Omitting the   > language tag presumably means that no language information is being   > supplied. But in that case, there is no need to reject a match with   > an identical literal which does have a language tag, is there?      I agreed with Bill earlier, and continue to do so.    The purpose of defining equality is that in the model theory we are  talking about a graph, which is a set of edges. We need to be able to  tell whether one edge is the same or different from another edge.    We are not trying to define a processing model for language aware RDF  processors.      I think the graph constructed by    _:a <rdf:value> ("Roma", "it").  _:a <rdf:value> ("Rome", "en").  _:a <rdf:value> ("Rome", "fr").  _:a <rdf:value> ("Roma", _ ).    is different from     _:a <rdf:value> ("Roma", "it").  _:a <rdf:value> ("Rome", "en").  _:a <rdf:value> ("Rome", "fr").    If the literal ( "Roma", _ ), i.e. with no language specified, is the  same as ("Roma", "it"), i.e. in italian, then the two graphs are  identical.      Now, suppose we have a language aware graphical information system, and  a user whose preferred language is "fr-ca" (French Canadian) comes up. I  have quite deliberately not tried to specify which label goes onto the  big city half way up italy.    Such an app may be clever enough to decide that "fr" is a better match  to "fr-ca" than _ but maybe not.    A different application, may always read a pair ( "string", _ ) using  the currently set default language; while that certainly should not be  the default case, I wouldn't want to rule it out as a way of processing  RDF.    Jeremy        

              Dan Connolly wrote:  Jeremy wrote:    >>>  >>That's a bug.  >>  >   > If it's a bug, it's evidence that the XML spec is  > *not* sufficient to make it clear to implementors  > how this works. Let's please add the  > this <xml:lang>en</xml:lang> example to the test  > suite, regardless of what the disposition is.  >   > How do you come to conlude that it's a bug, Jeremy?  > The text in 6.1.2  >   http://www.w3.org/TR/rdf-syntax-grammar/#section-Nodes  > is about attributes, not element names.  >     Sorry you are right, it is not a bug. The XML spec is clear. I failed to   read the subject line and thought it was about something else (attributes).    Jeremy        

      Aaron seems to think that   http://www.w3.org/2000/10/rdf-tests/rdfcore/amp-in-url/test001.rdf    contains the string '&amp;'     Art's comment seems to be about the string '&' which I seem to find  in the file.    I will confess to being unsure as to what is the actual string in the  file, the layers of escaping technology do add confusion; but Art's  modification makes sense to me.    Aaron, how are you looking at this file?  I am using internet explorer 5 and view source  or netscape 4.7 save to disk and then wordpad.      Art: my suggested wording is:       Note: when a XML/HTML browser is used to display this file, an       ampersand may be displayed and not the escape sequence:        ampersand hash 38 ;      In this case, please use a "view source" or a "save to disk" action.    Jeremy        

            Frank Manola wrote:      > By the way, you never answered the "What happens..." question?      <rdf:Description>     <eg:prop rdf:parseType="Literal"><em>foo</em></eg:prop>     <eg:prop rdf:dataType="&rdf;XMLLiteral"><em>foo</em></eg:prop>  </rdf:Description>    creates the same triple twice    whereas      <rdf:Description>     <eg:prop rdf:parseType="Literal"><em>foo</em></eg:prop>     <eg:prop rdf:dataType="&rdf;XMLLiteral"><em>foo</em></eg:prop>  </rdf:Description>    is not RDF/XML    Jeremy        

      Is Sergey back after his honeymoon yet?    DanC:  >  > If they editors (Stickler/Hayes/Melnick)  > are happy to publish it with their  > names on it, I'm happy to see it go out.  >      While he wrote chunks of the current text I take it that he has not been  involve with this round.  We will need his positive consent before publication.    Jeremy        

          This is just a heads up - of my efforts on the action item to draft a   discussion of the xmlliteral issue for inclusion in the request for advance.    Here is what I've got, I will continue on it tomorrow morning.    Many URIs are missing.    A particular question I would like help with is what are the concise   arguments for having reject option 3 from  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2003May/0016.html  which is the closest design to what we've got, that would probably satisfy   I18N.    I think it's the "puke factor" - but it would be nice to wordsmith that ...    Jeremy    =============        Dissenting Opinion: xml:lang and rdf:parseType="Literal"    The internationalization working group has registered  a dissenting opinion on the treatment agreed by RDFCore  concerning rdf:parseType="Literal".  This dissent is to changes made by the working group  in response to comments concerning the last call design,  particularly comments concerning the datatype rdf:XMLLiteral.    This feature of RDF is the single feature to have attracted  most comments both during and before last call.  This included comments from Reagle (  http://lists.w3.org/Archives/Public/www-rdf-comments/2003JanMar/0128.html  http://lists.w3.org/Archives/Public/www-rdf-comments/2003JanMar/0434.html  ),  Prud'hommeaux,  http://lists.w3.org/Archives/Public/www-rdf-comments/2003JanMar/0240.html  Web Ontology WG,  http://lists.w3.org/Archives/Public/www-rdf-comments/2003JanMar/0335.html  Patel-Schneider,  (  TBD1  TBD2  ),  Berners-Lee  (  TBD3  ),  Marchiori  (  TBD4  )      Resolving these comments to the WG's (and the commentators')  satisfaction involved changes that impacted aspects that were  known to be important to the internationalization working group,  and they were informed  (TBD5).  Duerst then commented further  (  TBD6  TBD7  ).  A detailed analysis was provided by Ishida.  (  TBD8  ).      The Working Group gave further consideration to these comments  but they did not introduce substantial new arguments that had not  already been made in the WG decision of ????.    The WG has considered five different designs (the four outlined  in  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2003May/0016.html  and the last call design).  A key attraction of the current design is simplicity.      Members of the WG have argued that:  - the treatment of xml:lang is  performed by XML exclusive canonicalization (which had  been reviewed and accepted by the I18N WG).  - an RDF specific solution to perceived deficiences  in exclusive canonicalization would not be interoperable  with other ad hoc solutions.  - long term, a solution based on a generic XML solution,  perhaps not dissimilar to XML fragments, would be better  - the simplicity of the current design will encourage  deployment of XMLLiteral, which will aid internationalization concerns.    An important consideration, reflected most in the comments  from the Web Ontology WG and Patel-Schneider's concerns,  is that unless rdf:XMLLiteral is a normal datatype  with no special treatment of language, then OWL Lite and  OWL DL do not support it. No version of the OWL Abstract Syntax  has permitted literals other than plain literals (with or without  language tags) or typed literals (without a language tag).  Thus, any solution, other than options 3 or 4 from  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2003May/0016.html  would require substantive changes to OWL DL and OWL Lite.  The WG chose option 4 from that message      The Working Group did accept an  ****      We ask the Director to confirm the WG decision despite this dissent.        

        Sergey's doc, as Patrick has indicated, does not permit meaningful  co-existence.    In Idiom A, the range of a property is the value space, in idiom B the range  is the lexical space, and these are disjoint.    Also, it is worth pointing out that the local idioms are fundamentally RDF  idioms, while the global  idioms are fundamentally RDFS idioms.    That is, the model theory for RDF (without RDFS) should cover the local  idiom, whereas the global idiom would fit within the RDFS extension.      In my view, we are likely to need to jump a somersault or two when we hit  schema union types and the combination of local and global idioms. But then  we've known for a while that the union types are a dog's breakfast.    Jeremy        

            Graham Klyne wrote:    >   > I would argue to reject rather than postpone this issue, for reasons set   > out in my response [1].     i.e.  [[[     I would oppose this change because this behaviour is explicitly discouraged   by RFC 3066:  [[  2.4 Meaning of the language tag        The language tag always defines a language as spoken (or written,      signed or otherwise signaled) by human beings for communication of      information to other human beings.  Computer languages such as      programming languages are explicitly excluded.  There is no      guaranteed relationship between languages whose tags begin with the      same series of subtags; specifically, they are NOT guaranteed to be      mutually intelligible, although it will sometimes be the case that      they are.  ]]  -- http://www.ietf.org/rfc/rfc3066.txt  ]]]  but the same RFC says:      [[  2.5 Language-range        Since the publication of RFC 1766, it has become apparent that there      is a need to define a term for a set of languages whose tags all      begin with the same sequence of subtags.        The following definition of language-range is derived from HTTP/1.1      [RFC 2616].                  language-range  = language-tag / "*"        That is, a language-range has the same syntax as a language-tag, or      is the single character "*".        A language-range matches a language-tag if it exactly equals the tag,      or if it exactly equals a prefix of the tag such that the first      character following the prefix is "-".        The special range "*" matches any tag.  A protocol which uses      language ranges may specify additional rules about the semantics of      "*"; for instance, HTTP/1.1 specifies that the range "*" matches only      languages not matched by any other range within an "Accept-Language:"      header.        NOTE: This use of a prefix matching rule does not imply that language      tags are assigned to languages in such a way that it is always true      that if a user understands a language with a certain tag, then this      user will also understand all languages with tags for which this tag      is a prefix.  The prefix rule simply allows the use of prefix tags if      this is the case.    ]]    which supports tex.  Also we should defer to I18N on whether this is useful or not. We could ask   I18N to endorse or not tex's comment on this issue.    Jeremy        

        Jeremy:  > [[[  >  > Issue B?: TDL self-entailment  >  > In TDL a document does not entail itself.  >  > Cannot live with: Graham, Jeremy, DanC  >  > ]]]    I have finally had a stab at updating the TDL Model Theory in line with the  existentially quantified literals idea. See:    http://lists.w3.org/Archives/Public/www-archive/2002Jan/att-0157/01-RDF_Data  typing.htm    the attachment in    http://lists.w3.org/Archives/Public/www-archive/2002Jan/0157.html    feedback welcome.  Changed text in purple.    (Sorry the picture links are currently broken).    Jeremy        

          Here are the test cases.      001. rdf:ID & other  002. rdf:resource & other  003. rdf:ID & rdf:bagID  (also unclear in M&S)  004. rdf:ID & rdf:resource  005. rdf:ID & rdf:resource & other     Jeremy        application/x-zip-compressed attachment: rdfms-not-id-and-resource-attr.zip          

          > 15: Semantics Issues  > We have several semantics issues:  >  >   horst-01  >   pfps-01  >   pfps-03  >   pfps-05  >   pfps-09  >  > That I suspect we are ready to close, but we need a formal motion to  > close them.  >  >    For pfps-03 I note that the LC document and the current editors draft both  say:    [[  The editor believes that both of these descriptions, and also the closure  rules described in section 4, are all in exact correspondence, but only the  directly described model theory in sections 1- 3 should be taken as  normative.  ]]    we could decide that that was sufficient, or Pat could add the theorem that  Peter asks for.      On pfps-01, I would be prepared to second the following proposal, if Pat  were to propose it:    PROPOSE: to accept pfps-01 and address it with the following text (**'s show  changed text):  [[  The datatype map which also contains the set of all pairs of the form  <http://www.w3.org/2001/XMLSchema#sss, sss>, where sss is a built-in  datatype which has well-defined lexical and value spaces and a  lexical-to-value mapping and is named sss in XML Schema Part 2: Datatypes  [XML-SCHEMA2], eg decimal, string, is referred to here as XSD.  ]]      On pfps-09, I would be prepared to second the following proposal, if Pat  were to propose it:    PROPOSE: to accept pfps-09 and address it with the text in section 3.4  Datatyped Interpretations of the editors draft, for instance:  [[  RDF provides for the use of externally defined datatypes identified by a  particular URIref.  ...  Formally, let D be a set of pairs consisting of a URIref and a datatype such  that no URIref appears twice in the set, so that D can be regarded as a  function from a set of URIrefs to a set of datatypes: call this a datatype  map.  ]]    For pfps-05 I am not convinced that the editors draft addresses it.  I believe it is partially addressed by:  rule rdfs1 in section 4.2  http://www.coginst.uwf.edu/~phayes/RDF_Semantics_Editors.html#rdfs_entail  but that the table of axiomatic triples seems to omit the following:    rdfs:Literal rdfs:subClassOf rdfs:Resource  rdfs:Class rdfs:subClassOf rdfs:Resource      On pfps-05, I would be prepared to second the following proposal, if Pat  were to propose it:    PROPOSE: to accept pfps-05 addressed by rule rdfs1 in section 4.2 of the  editors draft.      I haven't got to horst-01.    Jeremy        

          If the chair wishes, I would be prepare to propose the following resolution:      The WG resolves:  + that the RDF Core Specs will include a local datatyping mechanism  + that the RDF Core Specs will not include a global datatyping mechanism  + to rescind the stake-in-the-ground decision      DECISION 2002-02-22/2:      DECISION 2002-02-22/3:    see  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Feb/0656.html        If we were to consider this I would suggest three straw poll questions  before hand:    Qu1: who cannot live with a tidy model theory and no global datatyping?  Qu2: who cannot live with an untidy model theory and no global datatyping?  Qu3: who cannot live with no global datatyping?    My suspicion is that while many in the group have strong opinions about both  tidiness and global datatyping that a decision not to do global datatyping  reduces the tension and permits us to achieve consensus, at the cost of  doing less.    I would be surprised if we are down to fewer than one responder to each of  those, but we might find that the minorities are small enough to be  overruled without breaking consensus.    Jeremy        

        Despite DanC's wanting people to accept votes that go against them, I feel  that part of the consensus process is for people who are deeply unhappy with  the way things are going to explain why. Then the rest of group can listen,  and hopefully take on board the issues.    I can go along with the first three positions decided at the telecon ( S-B  style idiom, tidiness, no doublet) but I object very strongly to retaining  the triplet.    I don't think the triplet fits at all with the S-B approach that the  majority of the group favour.    The S-B style says that in the triple    <Jenny> <ageB> "10".  Jenny's age is a string (range constraints do not change this).  The triplet approach (aka S-A) permits us to say something like:    <Tommy> <ageA> _:b .  _:b <integer> "10" .    and Tommy's age is the integer 10.    Whatever we do to the range constraints, or however clever we are with the  age properti(es) I do not believe we can get the entailment:    <Jenny> <age> _:x .  <Tommy> <age> _:x .    i.e. that Jenny and Tommy have the same age. They don't: one has an age  which is an integer, the other has an age which is a string; but both have  been alive the same length of time!  [I am being deliberately vague about the exact property names, maybe they  are all the same].    I can live with the S-B idiom and semantics. I really like the S-A idiom and  semantics. But they don't fit together. Providing two incompatible means to  say the same sort of thing seems to me to be the very worst of design by  committee.    If we are so committed to the S-B idiom and tidyness then in my view we  should drop the desire to have a local datatyping idiom, because we have not  found a local datatyping idiom that is compatible with S-B and tidyness.    I think Pat's simpledatatypes2 is magic and I regret that we have not been  allowed to consider it.    Jeremy      More for the diehards ...  =========================    We have talked about the line between the application datatyping and the  datatyping within RDF. In S-A and S-B this line is drawn at a very different  place, and I believe that if we choose both then this will be an ongoing and  festering sore of confusion.  If we are going to limit datatyping to checking that strings are in lexical  spaces, let's do that. If we are going to use datatyping to deliver typed  values, let's do that. But trying to do both to please two different  constituencies within the WG is a mistake.    From a process point I prefer us considering coherent proposals as whole  items, rather than having a shopping list of features so that the final  requirements may or may not be satisfiable.        

          Hi Peter    thanks for your message  http://lists.w3.org/Archives/Public/public-webont-comments/2003Jun/0022      We accept the responses to  comments 1, 4 and 5.    We accept the current situation with comment 3, but note that WebOnt still  has to consider changes resulting from RDF Core's decision to drop the  rdf:type rdf:List triples, and point out that making the rdf:type owl:Class  triples optional in all cases would help ameliorate our concerns here.    We note that comment 2 is essentially a special case of the comment about  descriptions in  http://lists.w3.org/Archives/Public/public-webont-comments/2003May/0048.html  and we will respond further on that thread.    We are not requiring any further response on this thread and are happy for  it to be closed.    Jeremy on behalf of the Jena Team        

      I think I was advocating a substantially more woolly position than you  appear to want.    A few inline comments follow ...    >  >  > saying they're to be used 'for this purpose' (provenance and quoting)  > doesn't adequately describe the meaning of these constructs. What *is* an  > instance of rdf:Statement? We need to give a clear answer, rather than  > allude to possible uses for the class. That's the mistake the old spec  > fell into (cont. below).    Words typically have more than one (related) meaning falling into different  usage patterns. It works in natural language, I have yet to be convinced  that giving (not particularly formal) definitions that follow the  "provenace" model and the "quoting" model is not a solution.    e.g. when discussing the provenance of an RDF statement:    1: A different resource is used for each occurrence of the statment.  2: The resource is of type rdf:Statement  3: The s/p/o properties are as follows: [ omitted ]  4: dc properties are used to describe provenance.   [I am not suggesting (4) is correct, merely an example]    This sort of resource is referred to as a "stating"    when quoting  Each rdf:Statement resource is uniquely identified by its s/p/o.    This sort of resource is referred to as the Statement.    We observe that each stating as a natural Statement corresponding to it.    While it may seem confusing to have both Statements and Statings represented  in the same way, in practice context will disambiguate.      >  > How so? Giving a clear definition for rdf:Statement, rdf:predicate,  > rdf:object and rdf:subject might avoid the stating/statement problem.    It is clear to merely say that the rdf:Statement corresponds to the triple  in n-triple and the rdf:subject is the first field, the rdf:predicate is the  second, the rdf:object is the third.    Clarity only vanishes when we claim some deep metaphysical truth about  *identifying* a triple with its reification. If the reification merely  models the triple then it is not difficult.    Jeremy        

        Note following text from RFC 2279      -  Character values from 0000 0000 to 0000 007F (US-ASCII repertoire)         correspond to octets 00 to 7F (7 bit US-ASCII values). A direct         consequence is that a plain ASCII string is also a valid UTF-8         string.        -  US-ASCII values do not appear otherwise in a UTF-8 encoded         character stream.  This provides compatibility with file systems         or other software (e.g. the printf() function in C libraries) that         parse based on US-ASCII values but are transparent to other         values.            text/html attachment: rc.html          

            Graham Klyne wrote:    > At 05:30 PM 11/21/02 +0100, Jeremy Carroll wrote:  >   >> 7) Take a copy (not CVS) and global substitute the root of our subtree   >> with  >> the root of the real TR tree.  >> (a small Unix script can do this)  >   >   > Or use relative URI-references?  Isn't that what they're for?  >       They won't work with the latest symbolic links ...    Nice try.    Jeremy        

          Jeremy:  > 1: The current spec is self contradictory.  > 2: The 'common interpretation' (by only a few members of the community) of this differs from any plausible reading of the spec.    Here is a (biased) guide to the current spec:    In section 6, where the style of the spec is precise and rigorous, as  opposed to the chatty introductory materal earlier    Para 214:  [[[  Within propertyElt (production [6.12]), the URI used in a resource  attribute identifies (after resolution) the resource that is the object  of the statement (i.e., the value of this property). The value of the ID  attribute, if specified, is the identifier for the resource that  represents the reification of the statement.  ]]]    There is no indication that this is restricted to only some of the  expansions of production 6.12.     Significantly later, after a number of unrelated issues have been  discussed (namespaces, unicode, string equality, xml:lang), we arrive at  para 229    [[[  Properties and values expressed in XML attribute form within an empty  XML element E by productions [6.10] and [6.12] are equivalent to the  same properties and values expressed as XML content of a single  Description element D which would become the content of E. The referent  of D is the value of the property identified by the XML element name of  E according to productions [6.17], [6.2], and [6.3]. Specifically; each  propertyElt start tag containing attribute specifications other than ID,  resource, bagID, xml:lang, or any attribute starting with the characters  xmlns results in the creation of the triples {p,r1,r2}, {pa1,r2,va1},  ..., {pan,r2,van} where  ]]]    1. [...snip...]    2. [...snip...]  [[[ para 232    3. r2 is the resource named by the resource attribute if present or a  new resource. If the ID attribute is given it is the identifier of this  new resource.   ]]]    4. [...snip...]    5. [...snip...]          The 'common interpretation' goes  + para 232 and para 214 contradict one another,   + para 232 specifically applies when the condition specified in para 229  is true  + thus para 229 implies that para 214 doesn't hold in certain cases.      This interpretation of self-contradictory text is appropriate reasoning  when reading introductory material, when the technique of leaving some  complexity to later is often found; it is also appropriate when the  proximity of the paragraphs and the overall textual structure makes it  clear that an "if then else" structure is intended. Neither of these is  present here, and we are faced with a contradiction, a mistake, an  erratum. It is the job of this WG to fix errata.    The 'common interpretation' also links in with production 6.12. viz:       [6.12] propertyElt    ::= '<' propName idAttr? '>' value '</' propName  '>'                           | '<' propName idAttr? parseLiteral '>'                                 literal '</' propName '>'                           | '<' propName idAttr? parseResource '>'                                 propertyElt* '</' propName '>'                           | '<' propName idRefAttr? bagIdAttr? propAttr*  '/>'       The common interpretation is that para 214 picks out the final expansion  in this production, and in that case para 232 applies.    That is not what it says.    Consider the following rdf document:    <rdf:RDF xmlns:rdf="...">    <rdf:Description rdf:about="http://example.org/">      <rdf:value rdf:ID="id" rdf:bagID="BAG" />    </rdf:Description>  </rdf:RDF>      With the common interpretation this becomes:    <#BAG> <rdf:type> <rdf:Bag> .  <http://example.org/> <rdf:value> <#id> .    The text of para 229 does not say the fourth expansion of 6.12 but it  says "each propertyElt start tag containing attribute specifications  other than ID, resource, bagID, xml:lang" The rdf:value in this example  is not such a case and hence para 232 does not apply on any reading of  M&S. Therefore the only possible reading of this particular rdf:ID  attribute is that given by para 214, i.e. reification.      Thus M&S without doubt specifies the following triples for the example:    <#BAG> <rdf:type> <rdf:Bag> .  <http://example.org/> <rdf:value> _:a .  <#id> <rdf:type> <rdf:Statement> .  <#id> <rdf:subject> <http://example.org/> .  <#id> <rdf:predicate> <rdf:value> .  <#id> <rdf:object> _:a .    OK, I suspect I am being disingenuous here.    The following paragaph, the last in section 6 is   [[[  The value of the bagID attribute, if specified, is the identifier for  the Bag corresponding to the Description D; else the Bag is anonymous.  ]]]    I don't believe there are any implementations of this last phrase  either, the writers of this spec had run out of steam by this point, and  were making mistakes. The text in this part of the spec does not have a  meaning, and we should not give it a false loyalty.        Earlier Dave articulated two options:    Dave:  > 1) rdf:ID is always allowed and reifys the 1 statement  >    <parent node URI> <propertyElt URI> <rdf:resource URI> .    > 2) rdf:ID is never allowed.  If you want to reify that  >    statement, use the expanded form rather than this abbreviation.    Brian implicitly suggests two other options:    3) re-articulate what M&S says by taking para 232 which is guarded by  para 229 as taking precedence in that case over paragraph 214.    4) articualte, for the first time ever, the 'common interpretation' of  what M&S says i.e. using the fourth production of 6.12 as the guard for  text like para 232.      I point out that none of these is backwardly compatible.    All readings of the spec, the 'common interpretation' in parsers, and  any artiuclatable approach, all differ. Whichever of these four choices  we make we break 'backward compatibility' with something.    Fortunately there are no users of this construction. (I wonder why?)  Thus the backward compatibility argument is spurious, and we should ask  why there are no users of this construction.    Two reasons spring to my mind:  + maybe reification is less useful than was thought  + the lack of clarity about how to use reification effectively, and  overly confusing syntactic rules act as obstacles to users,  implementators, document writers, documentation writers at all levels.        Brian said:  > We should resist the temptation to fix things that we don't like but are not  > really broken.    We don't have a choice but to do something along the lines of (1), (2)  (3) or (4) and the argument is not about not fixing things, but about  what does the least damage to M&S and rearticulates M&S most faithfully.  I believe that (1) is that choice.    Jeremy        

          I have implemented the new Syntax in ARP.  I had a few issues, mainly with the test cases.  One substantive issue with the text is as follows:      ====      In M&S rule [6.21] we have:    [[[   [6.21] IDsymbol       ::= (any legal XML name symbol)  ]]]    where the hyperlink on XML name is to    http://www.w3.org/TR/REC-xml#NT-Nmtoken      In the new WD we have:    http://www.w3.org/TR/rdf-syntax-grammar/#rdf-id    [[[  An attribute ?string-value? matching any legal [XML] token Nmtoken  ]]]    Looking at it I think neither is correct and suggest that instead it  would be better to match against:    http://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-NCName    the namespaces NCName construct.    I will describe the differences:    NT-Nmtoken  ==========    Any non-empty sequence of NameChar characters    XML name  =======    Any NT-NMtoken that does not start with:     Digit | '.' | '-' | CombiningChar | Extender      NCName  ======    Any XML name that does not contain ':'.      ........................    Discussion  ----------    A)  If we allow an rdf:ID that matches more than NCName then it cannot be  used in a qname e.g.      <rdf:Property rdf:ID="300x" />    names the property with a name that cannot be used in an XML  serialization.      B)  Allowing rdf:ID's that start in CombiningChar and Extender is likely to  be at odds with our general position vis-a-vis charmod. (I have not  checked that in detail).    C)  Both M&S and the current WD permit    <a:foo rdf:ID="ex:ex"/>    which looks distinctly dubious to me. Possible confusion as to whether  or not the ID is a qname etc.        Jeremy        

        I like the outline of Jos's proposal very much.    [I am neutral about Aaron's suggested modification.]    As I see it, this allows a test application to:      read one or more manifest files that describe      + tests using rdf-entailment or rdfs-entailment    It can then scan through these looking for tests that are relevant to the  sort of application it tries to be.    The manifest file makes no assumptions as to the implementation of the  application (other than it is able to read rdf/xml files!).    As an example, I understand Jos's implementation uses a reasoner of some  sort, so that his test suite might check the rdfs-entailment by checking  that each statement in the rhs does follow from the lhs.  A different implementation of rdfs might be a Jena inferencing model, which  is automatically closed using Pat's model theory (call for  implementations!). Such an implementation would read the LHS files and check  that the RHS files were sub-graphs.    Also Jos's proposal includes the current tests, despite somewhat hiding  their intent. It also encompasses my proposal to have tests where two RDF  files with the same graph are given.      One note: the current "equality" tests are computational less expensive than  an rdf entailment test. Technically it is the difference between Graph  Isomorphism and SubGraph Isomorphism. GI is thought to be strictly between P  and NP where SubGraph Iso is known to be NP. For these reason it may be  desirable to either:  + add rdfEquivalent and rdfsEqualivalent predicates  or make sure we use cycles, and suggest that users of the test cases should  search for such cycles if they have a GI algorithm available.    Another advantage of Jos's propsoal is that it is extensible. If we come up  with new tests that don't fit the framework we can extend the framework.    +1    Jeremy        

          "significant" might not have been the right word, but certainly extensive  enough to get a slot on the agenda at the tech plenary.    I am trying to maximize the utility of that slot, to me, as one of the  responsible editors.    The wording of the message was intended to convey clearly that the RDFCore  WG is in charge of the document.    The recent discussion on this topic that I have been party to has been on  WebOnt; where there is more opposition to our wording than in RDFCore. Since  the social meaning of RDF becomes the social meaning of OWL this seems in  order.    My hope is that with face2face conversation between people who feel strongly  about this issue minor wording changes could be suggested that:  - continue to create connection between RDF Formal semantics and the real  world  - continue to indicate the possibility of legally binding agreements  - but avoid any sensitivities unintentionally transgressed    As editor, I believe that if this is possible then the WG would be likely to  approve such changes since:  - the resolution of rdfms-assertion would still be conveyed  - a comment about social meaning from PFPS  http://lists.w3.org/Archives/Public/www-rdf-comments/2003JanMar/0192.html  (which doesn't seem to have made it into the LC issue list - but is clearly  intended as a Last Call comment) and probably others in webont may be  addressable    Since PFPS regards this as a "fatal flaw" I am under obligation to at least  fully understand where he (and others) differ from the WG position which I  support.    Jeremy      > -----Original Message-----  > From: Brian McBride [mailto:bwm@hplb.hpl.hp.com]  > Sent: 13 February 2003 23:44  > To: Jeremy Carroll; w3c-rdfcore-wg@w3.org  > Subject: Re: Social Meaning Boston 6 March  >  >  > At 21:32 13/02/2003 +0100, Jeremy Carroll wrote:  >  >  > >I am posting this message to three lists, sorry for duplicate copies.  > >  > >There has been a significant discussion on the social meaning  > >parts of the RDF Concepts Last Call.  >  > Really!  Where?  >  > Brian  >  >        

      DanBri:  > I propose section 6 be dropped for now, until this is fixed.    Opposed.    There are practical problems in RDF serialization.  At some point the specs need to acknowledge this, and indicate to  implementors what they should do.    In RDF2 I would hope to fix this, e.g. allow the "_:nnn" bnode syntax as  matching uriref production in the grammar.  That was out of charter.    The charter allows us to clarify M&S.  The clarification is "this is screwed up".    I think a minor change highlighting that the meaning of the graph has  changed in such a serialization may improve the document.    Jeremy        > -----Original Message-----  > From: w3c-rdfcore-wg-request@w3.org  > [mailto:w3c-rdfcore-wg-request@w3.org]On Behalf Of Dan Brickley  > Sent: 26 April 2002 12:14  > To: w3c-rdfcore-wg@w3.org  > Subject: comments on syntax wd: bug in graph seriali[zs]ation algo  >  >  >  > http://ilrt.org/discovery/2001/07/rdf-syntax-grammar/#section-Serialising  > [[  > All blank nodes are assigned arbitrary URIs.  > ]]  >  > This is inconsitent with our policy w.r.t. blank nodes.  >  > I propose section 6 be dropped for now, until this is fixed.  >  > Dan  >  >        

        >  > Issue http://www.w3.org/2000/03/rdf-tracking/#rdfms-abouteach  >  > Summary: I propose to remove rdf:aboutEach from the RDF/XML language.  >        Earlier Brian said, of a different issue:  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Oct/0362.html  >  > The barrier for making changes is set very much higher than for  > 'clarifications'.  A strong case must be made that the change is  necessary.  > There must be a strong call from the community to make the change.  And we  must  > be sure we have evidence of how existing code and data and will be  affected.  > And there must be good reason why it cannot wait till we have a more  relaxed  > charter.  >  > We should resist the temptation to fix things that we don't like but are  not  > really broken.  Lets save those for rdf 2.  >    I think we should try and apply consistent standards for changes.    I think we should explicit delete "strong call from the community" from the  necessary hurdle for changes.    However, I personally am unconvinced by Dave's case that the change is  *necessary*. aboutEach is unfortunate and shouldn't be in the language but I  feel it is in the category of "don't like but are not really broken."  (In  contrast with the issue that brought the chair into action in October where  the spec is self-contradictory and hence is broken!).    Looking at Dave's implementation overview stuff it seemed to say, aboutEach  is implementable but quite difficult and most people haven't bothered. That  is it is an implementation defect not a spec defect. The main reason for  dropping aboutEach, which isn't such a bad one, is that the corner cases to  do with aboutEach are unclear (in a range of issues raised in part by me).  The easiest way to clarify the corner cases is excision of aboutEach.  Instead of trimming five toenails, it might be easier to cut off the foot.    I suspect that laziness is the reason for not postponing this to rdf 2.    Jeremy        

          I am happy to follow up with Joe ...  Pat's text looks fine to me.    Jeremy    pat hayes wrote:    >  > Re.   > http://lists.w3.org/Archives/Public/www-rdf-comments/2003JanMar/0162.html,   > I'm afraid I do not understand what the issue is to which I am   > expected to respond. The semantics document introduces the xsd:prefix   > with the following text (section 0.2):  >  > "We will also make extensive use of the Qname prefixes rdf:, rdfs: and   > xsd: defined as follows:  >  > Prefix rdf: namespace URI: http://www.w3.org/1999/02/22-rdf-syntax-ns#  >  > Prefix rdfs: namespace URI: http://www.w3.org/2000/01/rdf-schema#  >  > Prefix xsd: namespace URI: http://www.w3.org/2001/XMLSchema#  >  > Since Qname syntax is not legal N-triples syntax, and in the interests   > of brevity and readability, we will use the convention whereby a Qname   > is used without surrounding angle brackets to indicate the   > corresponding uriref enclosed in angle brackets, eg the triple  >  > <ex:a> rdf:type rdfs:Property .  >  > should be read as an abbreviation for the N-triples syntax  >  > <ex:a> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type>   > <http://www.w3.org/2000/01/rdf-schema#Property> ."  >  > Can someone (Jeremy?) tell me in what way this is misleading?  >  > Pat        

          I thought it might be helpful to clairfy the common areas in the two model  theories for TDL and S. (And hence to clarify what the dispute is about).      Given a string and a datatype (e.g. "0" and xsd:integer) both TDL and S have  representations in the model of:  - the string itself      + in TDL the first component of the interpretation of the string      + in S the interpretation of the string (which I think is XL(s))  - the mapped value      + in TDL the second component      + in S-A the interpretation of the b-node      + in S-P the first component of the interpretation of the b-node      A difference is that S requires these two distinct enitities in the universe  of discourse to be mapped from two distinct entities in the graph; whereas  TDL likes idiom S-B and manages to map that single node into both the string  itself and the mapped value.    Both S and TDL also have a representation in the model theory of the  datatype, although for TDL this representation is limited to the uri &  mapping only, (from which the other properties can be deduced).    Obviously both model theories have the non-datatype machinery in common.    Jeremy        

          I18N issue draft SOTD for concepts:  [[  A notable change  since the Last Call publication is the simplification  of typed literals to exclude language tags.  The Working Group particularly seeks feedback on the  impact of this change on the datatype  rdf:XMLLiteral.  ]]    I would suggest that the syntax SOTD should highlight that  For a property element with rdf:parseType="Literal"  an xml:lang attribute on  it or one of its ancestors  is ignored.    Jeremy      Dan Brickley wrote:    > * Brian McBride <bwm@hplb.hpl.hp.com> [2003-09-02 15:59+0100]  >   >>looks ok to me.  >>  >>I suggest that we particularly want to highlight i18n's xml lang/xml   >>literal issue and request feedback, say in both concepts and in syntax,   >>and in the announcement.  >>  >   > Yes, at least in the documents. I didn't attempt this in the boilerplate  > I drafted since it is intended to be mixed-in with per document text.  >   >   >>Does it make sense for such highlighting to go in the status section?  >>  >   > I think so.  >   > Dan  >   >         

        Hi Ian,    I am increasingly preparing myself for having a go at enriching the world  with another DL reasoner!    This would be:  - part of Jena  - written in Java  - with a Berkeley style licence  (see http://www.hpl.hp.com/semweb/download.html )    My intent is to refer to as many DL implementation papers as possible while  writing it. (I want to reimplement rather than reinvent the wheel).    I would also like to refer to the FaCT codebase while reimplementing.  http://www.cs.man.ac.uk/~horrocks/FaCT/  I note that currently this would not be wise, since I would probably "copy"  (in the legal sense, not byte by byte) some of the content of the FaCT  codebase. Given that FaCT is GPLed this would then require us to GPL Jena  (which we do not wish to do).    So, may I have your permission to copy parts of the FaCT codebase into a  Java DL system, to be freely distributed under a Berkeley style license (but  without a copyleft restriction). I will not use automatic translation tools  in this process.    As yet I haven't looked at any of the FaCT code ...    If the reply is positive, please reply to all.  This will log the reply in www-archive.    Jeremy        

            I have reviewed the proposed changes and I support them.    I would marginally prefer a slightly more explicit word than "Following" in   the change log, sentence:    "Following comments by ter Horst , the definition of D-interpretation has   been re-worded."    my (tiny) concern being that the re-wording follows Herman's comment in   time but not in substance.    Possible rewording would be    s/Following/After considering/    If the editor or chairs do not wish us to consider this change that is no   problem.    Jeremy        

          Brian asked:  [[  Are there any knock on effects in semantics.  ]]        From "RDF Semantics" 5th September  [[  Throughout this document we use the term 'character string' or 'string' to  refer to a sequence of Unicode characters in Normal Form C  ]]      Hence Pat seems to agree with my understanding that we only deal with  strings in NFC.    Jeremy        

          The next version of concepts (i.e. for review by WG prior to last call) is  basically ready.    An editorial issue is:    Section 2 is fatter than the rest, the editors would prefer to flatten it,  expanding it to sections 2, 3 and 4. This will cause nearly all the section  numbers in concepts to change.    This is cosmetic.    We can either do it now or do it after last call.    This will cause some work for the other editors (in that all links to  concepts will need checking). Us making the change now would allow any  errors to be caught in last call review; making it later might be less  pressured.    Any thoughts?    Jeremy        

            Brian McBride wrote:    >   >   > Jeremy Carroll wrote:  >   >>  >>  >> Brian McBride wrote:  >>  >>> b) advice to the CG about what to do about postponed issues  >>  >>  >>  >>  >> Personally I prefer not to discuss postponed issues (for new recs?)   >> until we've got this one in the bag.  >>  >> As HP rep the position I represented was we did not need to resolve   >> these issues in this standardization round. For the next few weeks   >> that remains the position I wish to represent.  >   >   > I was not clear.  I was not proposing we discuss resolutions of the   > issues, but suggestions to the CG of how/whether these issues might, at   > some point in the future be resolved.  For example, the WG might   > recommend to the CG that some issues are higher priority than others.  >   > Is that a discussion you feel able to contribute to?      I am not sure that we can have a procedural only discussion - I guess if I   am unconfortable I will just stay quiet - and my silence should not be   interpreted as assent.    For instance, I decided to not reply to Grahams msg on the postponed issues   despite disagreeing with it.    Jeremy        

        I am happy with such changes.    I guess you're knocking the ball back to Aaron's court over the final  warning.    Jeremy:  > >  > >[[[ADD:  > >Finally, other non-RDF components of a system may expect to be  > >able to treat a URI with fragment identifier in a manner similar to  > >the treatment of a URL with fragment identifier used for document  > >retrieval over the web. This may lead to interoperability problems.  > >]]]    Graham:  >  > I think that if this is to be included, we need some  > justification (e.g. an  > example where interoperability fails).  I have found it hard to come up  > with a convincing case.  From my exchanges with Pat, I think the dragons  > may not be as fiery as we first thought if we are clear about the  > accidental nature of any relationship between URI and URI#frag as far as  > RDF is concerned.  >        

      Jeremy:  > >Justifications of Ns & ?s  > >-------------------------  > >N> data persistence  > >N> security  > >N> xml interfaces  > >?> internationalization  > >  > >are part of the metadata layer of semantic web architecture  > (RDF), not part  > >of the ontology layer.  Pat:  > I fail to follow this distinction. (I know it is taken from the  > 'layer cake' slide. I fail to follow it there as well.) RDF, for  > example, is surely a (simple) ontology language. Do y'all have some  > idea that metadata is somehow distinct from , and more primitive  > than, ontology? (?? In what sense?)  Pat:  > Maybe xml and internationalization (maybe), but I don't see any way  > to isolate security and data persistence issues from the ontology  > 'layer', wherever that happens to be.  >      I see RDF as giving primitives for describing any data, and the ontology  layer as describing constraints on how to use those primitives. These  constraints are themselves data, described in RDF, and subject to a set of  constraints!    Not exactly layers; & I certainly don't see TBL's layered picture as Gospel  Truth,; but it is a fair enough starting point.    Aspects of security that appear in database schemata include access control.  If we can include access control info in our ontology language that will be  good, but it is not a MUST HAVE for me. It seems that in order to define  such a thing we need to have a much better model of web security than we  currently have, so I think it is more profitable to duck it for now.    I understand persistence as about storing our data on a disk, or similar.  This seems to be a general problem for any RDF data and not ontology  specific. Unless we wish to annotate ontologies to say that this property  should be stored persistently, and this property not. (Again not a feature I  would die for).    I am suggesting a meta criteria that we should address issues that do not  appear for RDF; and not address issues for which an RDF solution would also  be a WebOnt solution. But I am not dogmatic, and having expressed my opinion  don't wish to get in the way of people coming up with good security or data  persistence solutions!    Jeremy        

            Graham Klyne wrote:      >   > Just saw Jan's post:  >     > http://www.w3.org/mid/Pine.GSO.4.44.0309021152160.22152-100000@mail.ilrt.bris.ac.uk.   >   > I'm happy with that, which (I think) is effectively (c).  >   me too.      Jan seems to argue with DanC for option (e) - that somehow or other   datatyping subClassOf is extensional, whereas elsewhere it is intensional.    I guess I find that really quite problematic.    I seem to remember being isolated in defending the extensional semantics   for subClassOf; I can't understand what (some of) the rest of you want -   you got rdfs:subClassOf as intensional, but a least be consistent, and   forget your extensional intuitions.    Jeremy        

          Once again I am afraid I won't make the telecon. Sorry.    Jeremy        

          Mindful of time pressure ...    I suggest the following approach for our paper ...    1) introduce a property      rdfx:assertedBy    whose domain is graphs and range is agents union documents.    2) include examples in which a PKI signature of such a statement is   included in which the asserting agent signs the statement of assertion    3) include text that describes the bootstrapping problem and note that the   example provides one mechanism for bootstrapping trust, but noting that the   HTML web largely works, providing adequately trusted information, without   widespread use of such mechanisms    We might also want an rdfx:notAssertedBy property for explicitly stating   that a graph is fictional, in the eyes of its author (or anyone else).    4) We could include text that suggests that documents published in RDF/XML   should be regarded by default as being asserted by their authors, and point   to the social meaning discussion to show that this was never adequately   resolved.    To me, at least, that provides enough mechanisms for the publishing of   assertional intent, at least for most actual usage.    I think Chris is correct to indicate that the reading agent's trust is a   separate problem that may be increased by the use of signatures but not   increased to 100%.    I think we should address this by postulating a trust layer, which takes as   input a set of named graphs and provides as output a single graph, being   the merge of some of the input graphs, (those which the trust layer chose   to trust). Chris provides some potential trust metrics, and we include the   PKI signature as one of the factors which may be considered.      Jeremy        

        Can we go for the 9.00 am slot on Tuesday.  We're hoping for about an hour (i.e the RDF people).  You may be able to better estimate it.    Jeremy    -----Original Message-----  From: w3c-rdfcore-wg-request@w3.org  [mailto:w3c-rdfcore-wg-request@w3.org]On Behalf Of  Misha.Wolf@reuters.com  Sent: 21 February 2002 14:37  Subject: RE: Outstanding Issues - rdfms-xmllang        Plase refer to:    http://www.w3.org/International/Group/2002/02/ftf17/#schedule    All the white slots are currently available.    Misha      On 21/02/2002 13:19:42 Brian McBride wrote:  > In principal, I think that would be an excellent idea.  >  > Jeremy, please could you suggest a statement of purpose for the meeting  and  > objectives, and possibly an agenda.  >  > Do we do this a small subgroup from RDFCore meeting with the i18n folks or  > as the whole WG.  Who from RDFCore would like to participate in such a  > discussion on RDF conformance to charmod?  >  > Misha, can you suggest times when it might be possible to meet.  >  > Brian  >  > At 11:51 21/02/2002 +0000, Misha.Wolf@reuters.com wrote:  >  > >[I'm copying w3c-i18n-wg, rather than w3c-i18n-ig, as this  > >is a process mail, not a technical one]  > >  > >Are you folks interested in meeting with the I18N WG  > >at the Plenary to discuss outstanding issues?  > >  > >Misha Wolf  > >I18N WG Chair  > >  > >  > >On 20/02/2002 11:11:07 Jeremy Carroll wrote:  > > > > rdfms-xmllang: Why isn't xml:lang information represented within the  RDF  > > > data model?  > > >  > > > > This was put on hold whilst we looked at datatypes.  > > > > Model and Syntax says that lang is part of the literal; that no  triples  > > > are  > > > > generated for an xml:lang.  We can choose to stick with that or  > > change it.  > > > > Does anyone have a compelling reason to change it?  > > >  > > >  > > >  > > > My proposal before we put it on hold was in the overly long:  > > >  > > > http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Sep/0378.html  > > >  > > > [[[  > > > [1]  > > > An RDF Literal is a Unicode string, optionally paired with a  > > > language tag (as defined in RFC3066).  > > > ]]]  > > >  > > > in that thread we identified equally rules as follows:  > > >  > > > http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Oct/0375.html  > > >  > > > suggesting that such pairs are equal  > > >   if and only if  > > >   the unicode strings are equal  > > > and  > > >    the lang tags are either both absent, or both present and equal (as  lang  > > > tags, i.e. case insensitive).  > > >  > > >  > > >  > > >  > > > This then works orthogonally with:  > > > - the graph syntax  > > > - model theory  > > > - datatyping  > > > - any treatment of Unicode string normalization  > > >  > > >  > > > Jeremy  > > >  > > >  > >  > >  > >  > >-------------------------------------------------------------- --  > >         Visit our Internet site at http://www.reuters.com  > >  > >Any views expressed in this message are those of  the  individual  > >sender,  except  where  the sender specifically states them to be  > >the views of Reuters Ltd.  >        ------------------------------------------------------------- ---          Visit our Internet site at http://www.reuters.com    Any views expressed in this message are those of  the  individual  sender,  except  where  the sender specifically states them to be  the views of Reuters Ltd.        

        Hi Chris,    this is a PDF and archioved version of your document    Jeremy          application/pdf attachment: namedGraphDiscussion009.pdf          

          I'll think some more    Chris positions trust as crucial to the information-consumer    This is an interesting variant on the information-producer centric concerns  that characterised the RDF Core debate about assertions.    Later    Jeremy        

            Jos De_Roo wrote:    >   > [...]  >   >   >>There are technical reasons (to do with identity substitution on  >>datatype names) why it is unworkable to have a 'special' datatype  >>which violates the structural assumptions of the datatyping model,  >>and it is not feasible or desireable to include lang tags in the  >>datatyping model. So *if* we treat XML literals as being typed by an  >>XML datatype, it is infeasible to include lang tags as part of the  >>literal structure. They could be included as part of the XML literal  >>string itself, by requiring all such literals to have a special  >>rdf-wrapper onto which the lang tag can be attached by normal XML  >>conventions; but then of course the actual XML literal string no  >>longer looks like the XML fragment included in the RDF/XML document.  >>But on the other hand, from view X, I guess that would just be an  >>implementation detail.  >>  >   > I agree with that summary.  >   > --  > Jos De Roo, AGFA http://www.agfa.com/w3c/jdroo/  >   >       I have swung from preferring keeping the wrapper in order to hold the   langtag to not having the wrapper. I think this reflects "view G" in pat's   helpful terminology. The wrapper was never really part of what one is   trying to say.    Jeremy             

        I have been doing some cleaning up ...    as far as I am concerned everything except sections 5 and 6 is now in place    Please review the conclusion - it needs to be changed, I've written   something for people to find fault with.    I need to talk with Pat about section 6.3 (I am busy for a few hours now,   will try later)    We might have to cut some text somewhere, we are currently over the limit,   but we have to drop the vocab section, add the picture and prne redunancy   (particularly on the performative stuff).    Some of the refs need tidying up.    I include the latex sources - if Chris wants to do a bit more tidying up do   so and try and return the lock before 8 pm (UK time). (Maybe include the   vocab picture and drop that section)    Jeremy                  application/pdf attachment: ng.pdf    application/x-zip-compressed attachment: ng2.zip          

            We're running out of time -    in particular - we need to agree author list, title , keywords and abstract   mnext Tuesday - which since I am leaving early on Thursday, and Friday is a   UK holiday means Thursday a.m. (i.e. Wednesday for Pat)    Also stuff on TriX paper for Extreme below.    So for the paper I suggest:    Authors:    Jeremy J. Carroll, Christian Bizer, Patrick Hayes, Patrick Stickler    Title:  Named Graphs, Provenance and Trust    Areas from CFP:  http://iswc2004.semanticweb.org/CF/researchTrack.php  Languages, Tools and Methodologies for Semantic Web Data  Semantic Web Trust, Privacy, Security and Intellectual Property Rights    (any others??)    Keywords:    RDF, Syndication, Provenance,  Trust, Security, Digital Signatures,  Publishing, TriX, Model Theory, Graphs  (that's probably too many - suggested changes?)    Abstract:    The Semantic Web consists of many RDF graphs named  by URIs. This paper discusses the syntax and semantics  of such collections of named graphs. This enables  improved clarity in  Semantic Web  publishing, allowing publishers to communicate  assertional intent, and to sign their graphs.  Information consumers can evaluate specific graphs  using task-specific trust policies, and act on the  information from those named graphs that they accept.      (something upbeat for the last line?)      On TriX paper (Carroll/Stickler) - I don't think I am going to have time to   update it after Pat's feedback on the named graph paper - hence I think we   need to update in terms of the current draft plus planned changes and worry   about any late changes after we have submitted it. (i.e. the version that   gets reviewed may not be exactly the version that we wish to be reviewed,   but close enough).            Jeremy        

          Following on from my reply  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Jul/0047.html    I highlight:    > Er.... why not? In the current stake proposal, they all denote the  > string "10" (which conforms to the lexical form requirements of both  > xsdr:decimal and xsdr:string, so everything is fine.)    But Brian is in the context of the f2f suggestion that the denotation of  literals depends on the property and the literal, not just the literal.      Brian:  > >I confess I find this rather bizarre.  In the case where the object  > >of a statement is a literal, then the value of the rdf:object  > >property of the reification of that statement denotes a syntactic  > >entity, otherwise it denotes a semantic one.  (Sorry that doesn't  > >sense to a logician, but Pat'l know what I mean.)  Pat:  > Well, it is bizarre, but the bizarritude arises from the fact that we  > have made these pieces of syntax denote themselves, thereby neatly  > confusing the syntactic and semantic domains by putting the former  > into the latter.    Ahh, this links up better with the f2f.    Brian:  > >Is that what we mean to say?  > >  > >If the answer to test case A is yes, then we need an non-entailment test:  > >  > >   <s> <p> "a" .  > >   _:s rdf:subject <s> .  > >   _:s rdf:predicate <p> .  > >   _:s rdf:object "a" .  > >   _s: rdf:type rdf:Statement .  > >  > >where _:s is a reification of the first statement  > >  > >does not entail:  > >  > >   <s> <p> _:o .  > >   _:s rdf:object _:o .  Pat:  > Again, I think this is valid in the current 'stake' proposal (for  > literals and urirefs).    This entailment holds for literals, and the corresponding entailment holds for  urirefs.    >                     And if literals were semantically untidy, then  > any entailment from distinct literal nodes to common bnodes would be  > invalid. In other words, I don't think reification introduces any new  > issues.    So if the object is a uriref or bNode we enatil:      <s> <p> _:o .   _:s rdf:object _:o .    but if the object is a literal then we don't.    >           The issue is: If we allow untidy literal nodes, when can we  > assume that two literals denote the same thing? Answer: when they are  > the same *node*. It's the nodes that do the denoting, not the labels.  > Then it all works coherently, including reification and containers  > (that is, containers are weak; eg datatyping a container doesn't  > datatype its contents. But we knew that already, right?)  >      Jeremy        

          Frank asked me to explain what the problem was better ...    DanC's news URI is perhaps a better ownerless example.    With the freenet ones it's perhaps a wording problem:    >  > [[  > The social conventions surrounding use of RDF include the idea  > that each URI  > 'belongs to' somebody who has authority and responsibility for  > defining its  > meaning.    Perhaps changing this wording to explicitly talk about URLs allows the owner  to retain anonymity ... As is, this wording permits the Mr Example to  publish a press release (not on the web) to announce the meaning of  http://www.example.com/ .    Hmmm ... maybe I am reading this too closely.    Jeremy        

        I am sorry this is so late.  I forgot!  (We might need to delay approval until next week).    BRIAN, PAT: note action 19,20,21 (yours and mine) below which Jema lost.    Decision 6 was not scribed correctly, and hence not in Jema    ============      Agenda:  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Apr/0285.html    IRC Log:  http://ilrt.org/discovery/chatlogs/rdfcore/2002-04-19    Jema action/decision summary:  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Apr/0332.html    Scribe:  Jeremy Carroll    Executive Summary:    Decisions:    1:  Triples should be represented using correct n-triples  2:  close rdfs-online-char-encoding  3:  rdfs-container-membership-superProperty: there will be one  4:  rdfs-constraining-containers is out-of-scope and closed  5:  rdfs-subClassOf-a-Property, legal, in MT, closed.  6:  Do not publish Datatyping WD at this time.    >Jema noted the following actions during RDFCore WG Telecon 2002-04-19  >  >2002-04-19#1:  frankm sync up with eric concerning primer  >2002-04-19#2:  danb review primer, specifically schema stuff  >2002-04-19#3:  martyn review current primer  >2002-04-19#4:  pat provide MT WD for wg review  >2002-04-19#5:  jang review schema WD  >2002-04-19#6:  aaron review schema WD  >2002-04-19#7:  frank review schema WD  >2002-04-19#8:  jos review schema WD  >2002-04-19#9:  danb make schema WD available on Monday  >2002-04-19#10:  jan have test cases WD to review for Monday  >2002-04-19#11:  jeremy review test cases WD  >2002-04-19#12:  jos review test cases WD  >2002-04-19#13:  bwm propose how we move forward with datatyping  >2002-04-19#14:  danc do entailement test case for container with  rdfs:contains  >2002-04-19#15:  danbri propose name for container-membership-superProperty  >2002-04-19#16:  danbri review effect _NNN-superProperty on primer  >2002-04-19#17:  pat respond helpfully to rdfs-subClassOf-a-Property raiser  >2002-04-19#18:  jan produce test case for rdfs-subClassOf-a-Property    The following actions were lost by Jema, but still in IRC log.  2002-04-19#19: brian accept chance to review charmod  2002-04-19#20: jjc review charmod by 31st May  2002-04-19#21: path review charmod by 31st May      (Exact wording of decisions:  >1:  Triples should be represented using correct n-triples  >2:  close rdfs-online-char-encoding  >3:  resolve that there will be common superproperty  >4:  agreed propsoal in agenda 15  >5:  agree resolution in agenda item 16  )    DETAIL  ======    * 1: Allocate scribe  jjc (first bit gk)    * 2: Roll Call    Present:    Martin Horner    Frank Manola    Aaron Swartz    Patrick Stickler    Jos De Roo    Graham Klyne    Dan Connolly    Jan Grant    Ron Daniel    Brian McBride    Jeremy Carroll    Regrets:    Steve Petschulat    Dave Beckett    Mike Dean    Eric Miller    * 3: Introduce Observers    HP Observers:  - Andy Seaborne and three students: Alex, Olu, Tim.    * 4: Review Agenda  * 5: Next telecon 10am Boston time, 26 Apr 2002  * 6: Review Minutes of 2002-04-12    * See:  *  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Apr/0166.html    Approved after brief discussion.    * 7: Confirm Status of Completed Actions    Confirmed:  [[[    ACTION: 2002-04-05#4 Brian  sort out who will write text for updating test cases wd    ACTION: 2002-04-12#5 aaron  write up datatyping use-case for Dublin Core    see:    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Apr/0168.html    ACTION: 2002-04-12#7 jjc  post message to rdfcore with motivating example for dark triples?    see:    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Apr/0178.html    ]]]    * 8: outstanding issues  (See agenda for list)    * 9: Review of CharMod last call #2    2002-04-19#19: brian accept chance to review charmod  2002-04-19#20: jjc review charmod by 31st May  2002-04-19#21: path review charmod by 31st May    Strong preference for review to be significantly earlier.    * 10: Schedule and document status    * Primer    >2002-04-19#1:  frankm sync up with eric concerning primer  >2002-04-19#2:  danb review primer, specifically schema stuff  >2002-04-19#3:  martyn review current primer    Generally favourable comments have been made.      * Syntax  No discussion.    * Model Theory    >2002-04-19#4:  pat provide MT WD for wg review    By 26th April?  The next WD should be the one before last call.    * Schema    >2002-04-19#5:  jang review schema WD  >2002-04-19#6:  aaron review schema WD  >2002-04-19#7:  frank review schema WD  >2002-04-19#8:  jos review schema WD  >2002-04-19#9:  danb make schema WD available on Monday    Last call schedule unclear.  Friday 26th is last date for us to approve WD before  publishing moratorium in May.    * Test cases    >2002-04-19#10:  jan have test cases WD to review for Monday  >2002-04-19#11:  jeremy review test cases WD  >2002-04-19#12:  jos review test cases WD    * F2F in June:  * Does the WG believe it would be good to meet,    Yes it does.      * 11: How to represent triples in documents.    DECISION 1:  Triples should be represented using correct n-triples.    * 12: Datatyping WD  * Is this document ready for first publication?  Are the editors agreed?    The editors are not agreed.    DECISION 6:  Do not publish Datatyping WD at this time.    >2002-04-19#13:  bwm propose how we move forward with datatyping    * 13: Issue: rdfs-online-char-encoding  * Propose:  * o action Eric to update the schema file with the appropriate character      encoding declaration  * o close this issue    Hasty looking at file.  It seems to be OK.    DECISION 2:  Close rdfs-online-char-encoding.    * 14: Issue: rdfs-container-membership-superProperty    DECISION 3:  rdfs-container-membership-superProperty: there will be one.    Discussion included:  - entailment works one but not the other.  >2002-04-19#14:  danc do entailement test case for container with  rdfs:contains  - rdf:member or rdf:contains  >2002-04-19#15:  danbri propose name for container-membership-superProperty  >2002-04-19#16:  danbri review effect _NNN-superProperty on primer    * 15: Issue: rdfs-constraining-containers  [[[  Propose:      o the WG resolves that expressing such a constraint is beyond the      scope of RDFS.  Such functionality belongs with more powerful      ontology languages such as daml+oil and owl.      o The WG notes that DAML+OIL can express this constraint as described in:        http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Apr/0106.html      o The WG closes this issue  ]]]    DECISION 4:  proposal agreed.    16: Issue: rdfs-subClassOf-a-Property  [[[  Propose the WG resolves:      o an instance of the Property class may have an rdfs:subClassOf      property      o the meaning of such a property is defined by the model theory      o this issue be closed  ]]]  DECISION 5: proposal agreed.    Discussion that resolution is unhelpful.    >2002-04-19#17:  pat respond helpfully to rdfs-subClassOf-a-Property raiser  >2002-04-19#18:  jan produce test case for rdfs-subClassOf-a-Property    * 17: daml:collection  Small amount of discussion but time runs out.    Meeting adjourned.    * 18: Issue: rdf-charmod-resources  Not reached.    * 19: Suggest after hours discussion of dark triples  Suggestion was followed (profitably!).        

          DaveB:  > I prefer:  >  > Blank node identifiers are also generated when  > none is given explicitly with an rdf:nodeID attribute value.    Even though that's basically my wording it's not working for me.    I found the part of the sentence starting "with ..." seem to hang off the  "generated" rather than the "given". Maybe swap "also generated" to  "generated also"    >  [[  >  string-value  >  >  The value is a function of the value of the *identifier* accessor.  >  The value begins with "_:" and the entire value MUST match the  > N-triples *nodeID* production.  >  The function MUST preserve distinct blank node identity as discussed in  >  section 5.2 Identifiers.  > ]]  >    Yes looks good.    Jeremy        

          I still owe an example of a simple use of WordNet ...    this wasn't quite the one I had in mind, but has the advantage of being   more real:    http://norman.walsh.name/knows/where#dk-copenhagen    is described as having RDF type    http://xmlns.com/wordnet/1.6/City    clicking on the above URL gives an RDF/XML download ....  and uses words from WordNet as RDF classes ...    I think what Norm is trying to do is simply say that his copenhagen URI is   a resource which belongs to a class with some (strong) relationship to the   english word city in wordnet 1.6 sense 1 with description 'a large and   densely populated urban area; may include several independent   administrative districts; "Ancient Troy was a great city"'    This use of WordNet is fairly naive (in the sense that non-experts can do   it) and does not depend on any of the relationships between words.    Jeremy        

          I've been updating ARP trying to get it to pass the test cases in the  zip file and have hit a number of problems.    Earlier in:    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Sep/0062.html    and the related thread I queried    rdf-ns-prefix-confusion/test0007.rdf  rdf-ns-prefix-confusion/test0008.rdf      1: rdf-ns-prefix-confusion/test0007.rdf    I suggested that the triple    <http://example.org/resource/> <http://example.org/property> "bar" .    was missing from rdf-ns-prefix-confusion/test0007.nt    I got no response on that one.    2: rdf-ns-prefix-confusion/test0008.rdf    There was some discussion that didn't terminate on this one.    Dave in  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Sep/0063.html  wrote:  > test 8 contains an rdf:aboutEachPrefix and is thus now not in the  > RDF/XML language.  The file should be renamed as an error case or  > removed entirely (it does not test anything else that is not covered  > by other cases).    which I am supportive of.      A further problem is that a couple of files still have xml:base in them  as highlighted in  http://lists.w3.org/Archives/Public/www-rdf-comments/2001JulSep/0242.html    Jeremy        

          It was closed last week, along similar lines:  [[  16:51:28 <danb_scribe>  resolved: accept  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2003Mar/0155.html  16:51:43 <danb_scribe> (with 3 abstentions)  16:52:09 <bwm>  amended to empaphasize that the proposed equals operation is inappropriate  for the graph mechanism  16:52:28 <danb_scribe> oops (with 2 abstentions)  ]]  I have been waiting for the minutes in order to send the message to Tex.    Jeremy      > -----Original Message-----  > From: w3c-rdfcore-wg-request@w3.org  > [mailto:w3c-rdfcore-wg-request@w3.org]On Behalf Of Graham Klyne  > Sent: 04 April 2003 13:26  > To: w3c-rdfcore-wg@w3.org  > Subject: tex-02, proposal to close  >  >  >  > With reference to:  >    http://www.w3.org/2001/sw/RDFCore/20030123-issues/#tex-02  >  > and in view of:  >    http://www.w3.org/mid/3E8D48FB.72DFE4D8@i18nguy.com  >  > specifically:  > [[  > 2) As for the issue of comparing literals, it would be good to  > postpone the  > issue.  > ]]  >  > I propose that this issue be closed by postponing it for  > consideration by a  > future working group.  >  > #g  >  >  > -------------------  > Graham Klyne  > <GK@NineByNine.org>  > PGP: 0FAA 69FF C083 000B A2E9  A131 01B9 1C7A DBCA CB5E  >  >        

          Some of the HP team were talking about the WordNet TF over lunch.  We found the survey of current work that Aldo produced a useful resource,   but feel somewhat uncomfortable with it as scoping the TF.    In a sense, the survey showed what we think is the problem: too many   approaches, all of which have merits; rather than one mapping of WordNet to   RDF or OWL that is good enough for most users.    We felt that what would be most useful in the short term is to have a   standard representation of WordNet in RDF that people can use.  We think   this is what the community of implemetors needs and will most aid   deployment in the short term.    Some specific deliverables that we think would be very useful and   potentially could be achieved quickly are:    + an RDF schema or OWL ontology with which to talk about the main wordnet   relationships and concepts (e.g. words, senses, hyponyms, synonyms etc.)  + a namespace URI for this schema  + a version of WordNet converted into triples, using this schema and namespace  + some illustrative examples of use    I believe that at least some of the approaches listed already provide at   least some of these. Hopefully an understanding of these, and the expertise   of the TF, will allow a best of breed proposal.      It would not matter if a first version only covered some core concepts   (maybe the four above), and a later version added more sophistication.  The key problem facing a naive semantic web user, or a group producing   tools for semantic web developers is making the choice - of which of the   mappings to use, and hence which schema and which namespace URI.    An approach that would emphasize consensus and avoid blessing any one   solution would be to provide a namespace URI and the elements shared across   all prior solutions, and a forum in which the different wordnet mappers   could agree amongst themselves how to resolve differences (or enabling a   clear articulation of the differences, with their pros and cons)    When identifying the deliverables for this (or any) Task Force, we should   also identify the target audience, and possible use cases in which that   target audience may find the deliverables useful. It would be good to have   a clear idea from the target audience what they want, so the work is based   more on pull ("this is what you are asking for") than push ("take this   because the doctor says it will be good for you").    We do not think that the target audience for the WordNet TF is people   working on WordNet mappings, we think the target audience is any semantic   web developer who might find a particular WordNet mapping useful.  For example, anyone creating an OWL or RDFS class might wish to annotate it   with its intended meaning using *the* URI for a specific sense of an   English word, as classified by wordnet. The main requirement from this use   case is agreement over what that URI is, including the beginning bit (the   namespace) and the end bit (the mapping from Wordnet's representation of   senses)    Such basic agreement on the fundamentals will also help people doing more   advanced work on Wordnet mappings, by giving them a baseline from which to   start, and a shared vocabulary on which to build. When any research they do   is complete, the Wordnet TF (possibly reincarnated), or whoever is   maintaining the ontology recommended by the Wordnet TF, could then consider   how to integrate such completed research into the best practice.    Jeremy        

                                      

      My view is that exactly one spec should contain a normative defn of the RDF  graph.    Then this belongs there.    From the model theory perspective the graph is syntax.    From the syntax perspective the graph is (data) model.    Jeremy    > -----Original Message-----  > From: w3c-rdfcore-wg-request@w3.org  > [mailto:w3c-rdfcore-wg-request@w3.org]On Behalf Of Pat Hayes  > Sent: 25 April 2002 15:27  > To: Brian McBride  > Cc: w3c-rdfcore-wg@w3.org  > Subject: Re: notation for literals  >  >  > >At 11:39 25/04/2002 +0100, Dave Beckett wrote:  > >[...] excellent summary snipped  > >  > >>but as Pat said, the MT can consider literals opaque once the  > >>equality rules are clear.  > >  > >  > >I was thinking equality rules should be in the mt.  >  > Well, I could write a paragraph trying to capture Dave's summary and  > insert it into the section on graph syntax. It would be a bit of a  > detour, but that entire section is already a kind of meander in any  > case.  I guess I assumed that this would fit more naturally in the  > syntax document somewhere.  >  > Brian, your call.  >  > Pat  > --  > ---------------------------------------------------------------------  > IHMC(850)434 8903   home  > 40 South Alcaniz St.(850)202 4416   office  > Pensacola,  FL 32501(850)202 4440   fax  > phayes@ai.uwf.edu  > http://www.coginst.uwf.edu/~phayes  >  >        

            > Funny old world, ennit?      I've changed my mind on this one too, so it's quite easy to quote old   e-mails from me against my current position. I guess there are a few links.  I like the public exposure of my fickleness.      I have, of course, been persuaded by the force of the arguments made by my   colleagues on the working group.    Jeremy        

        %s/in this regard// ?    > -----Original Message-----  > From: Patrick Stickler [mailto:patrick.stickler@nokia.com]  > Sent: 10 September 2003 10:44  > To: Jeremy Carroll; ext Frank Manola  > Cc: w3c-rdfcore-wg@w3.org; pat hayes  > Subject: Re: about " 3 "^^xsd:integer  >   >   >   > Can we all just agree that the XML Schema spec  > is unclear and confusing in this regard, remove all  > XML Schema test cases touching on this issue, and  > formally recommend a clarification from the XML   > Schema WG (which is unrelated to our own schedule)?  >         

        As always I share both Jim's and Mike's concerns - despite them disagreeing.    It really doesn't help that the abstract syntax to triples mapping is   many-to-many ...    Jeremy        Jim Hendler wrote:    >   > At 20:09 -0800 3/30/04, Uschold, Michael F wrote:  >   >> I propose that by convention all OWL fragments are given using the   >> reader-friendly abstract syntax, rather than the parser-friendly XML   >> syntax.  Personaly, I cannot read OWL fragments well enough to be   >> motivated to ever understand the details, so I tend to skip over   >> them.  Even when I can get motivated, it takes way too much time.  >   >   > I object to this strongly -- that syntax is neither reader friendly nor   > actually a part of the recommendation.  Much more importantly, we should   > be creating fragments that people can cut and paste into their documents   > (and edit) -- forcing them to figure out the mapping from the so-called   > human readable syntax into actually RDF or OWL (XML or N3) makes no sense.  >   >>  >> I would argue very strongly that any public documents published by   >> this WG  do use the more readable syntax. Why not get used to it when   >> we communicate with each other? It will also make it easier to grab   >> things from discussions in the archive and plunk them into documents,   >> instead of having to translate into the abstract syntax suitable for   >> the public.  >   >   > I advocate use of "turtle" - which should be the first document this WG   > approves as a working note (if Dave is willing)  >   >>  >> Of course, if the discussion is about parsing, or about the syntax of   >> the language, then it is better to use the parser-friendly syntax,   >> both for internal discussions and for publised documents.  >>  >   > what is parser friendly?  >   >> What do people think about this suggestion?  >>  >> If the overwhelming majority of this WG actually PREFER to read the   >> parser-friendly syntax, then perhaps I'd best get used to it, but it   >> there are many like me, it makes sense to use a more reader-friendly   >> syntax.  >>  >   > well, we could get into whether this is a voting issue for a WG (be   > careful when you use words like "majority" in a W3C group) but my vote   > is for N3 (Turtle) which is a nice compromise - or else to stick w/the   > RDF/XML for cut and paste reasons  >  -JH  > p.s. Mike - have you noticed our world view doesn't always seem to align   > :->        

          Peter has sent this message to webont, which suggests the need to show some  relationship between lBase and one of the SWELs.    [[[  Also, is there a mapping from any semantic web language (RDF, RDFS, OWL  Lite, abstract OWL, Fast OWL, Large OWL) into LBase?  I would think that  it would be a good idea to have at least one such mapping before LBase gets  to be a W3C note.    Peter F. Patel-Schneider  Bell Labs Research  ]]]        

      >  > 1) maybe I am misunderstanding it but  > [[  > Axiom: Opacity of URIs  > The only thing you can use an identifier for is to refer to an object.  > When you are not dereferencing you should not look at the contents of  > the URI string to gain other information as little as possible.  > ]] -- http://www.w3.org/DesignIssues/Axioms.html#opaque  >    Isn't that very much in line with the xlink and XML erratum 26 text, which  mandate delaying of %-escaping until dereferencing. When applied to RDF we  then do not %-escape when constructing the graph; which is what we  resolved.    > 2) RFC2396 the URI spec so far, and I have to build  > stuff like our R representative mechanism on top of that  >    ??? (Sorry I haven't understood)    Jeremy        

          This might be a question about the meeting I missed ...      Have we added a horst-01 test case?    We should (or perhaps merely could) add a test that is more or less   Herman's initial comment and say that it is a non-entailment.    I would then also add this very same test to the OWL test suite as an   entailment.    If we have not done so then we could have this on the agenda.    (I may be a little late tomorrow, and will not be reading my e-mail before   the meeting. In one scenario I will also not be available after the first   60 minutes).    (I could probably manage to add the test case to the website this evening   if prompted to do so).    Jeremy        

      Anyone wanting a heads-up on current state of play:    http://lists.w3.org/Archives/Public/www-archive/2002Jan/0114.html    Patrick and I are now at integration stage and looking well-placed for  meeting the end-of-the-week deadline.    Jeremy        

        The unicode reference for making comparisons seems to be:    http://www.w3.org/TR/charmod/    which is a W3C Last Call Working Draft whose last call period ended on  23 Feb.    I haven't yet understood what it says. A speed read suggested that when  creating RDF data you should normalise your unicode strings. (i.e. RDF  processors just do a simple comparison).    I'll try and give a better summary sometime next week.    Jeremy        

            Basically I am now out of time on this one. I will be able to spend an  hour or two on it while in Sardinia a week after next but I have no more  time this week or next.    Where I have got to is:    - a draft I am happy with except for:    - the links to the test cases which are in the right place in the  document but are not are correct links (i.e. they link to the wrong  tests)    - the ref to XML 1.1 that I've not done    - there is a missing ref to a standard graph theory text.      The one I use (Stewart?) doesn't really treat directed graphs, so I  would prefer to refer to a different one.      There are one or two stylistic issues, Pat touched on one:    > Quick comment: its dangerous to simply say that the RDF graph *is* a  > graph, even in brief, as in 2 para 1.    As a style I have started each part of the description with a brief less  formal statement (e.g. "A string literal is a string paired with a  language tag.") This is intended as a useful oversimplification expanded  upon in the ensuing text). Similarly the text that Pat picks up on is  clarified ad nauseum (in my view).    Perhaps that particularly piece could be improved by linking the words  RDF Graph to the fuller definition in section 2.7.    I think the most important stylistic question is that raised by me at  the end of the text about "a system of typed objects with identity"    Another issue that we have not discussed is the normalization  requirement on XML Literals. I arbitrarily chose a Note "If  compatibility with XML version 1.1 is desired ..." which fits with our  treatment of the composing character at the beginning of string  literals.    I hope there is enough there to have a discussion at this week's  telecon. The issues I think we should check we have consensus on are  basically those already highlighted:    - no isolated nodes  - any URI can be a property (although note the RDF closure rule in the  model theory that allows one to infer that the URI is of rdf:type  rdf:Property)  - XML Literals have no normative (unicode) normalization requirement,  but we have an interoperability note.    If the chair believes it would be worth formalling recording such  decisions I would be prepared to formally propose a motion on each.    Other than that I think there may be editorial issues with my choice of  words but I believe that the substantive content reflects working group  decisions.    Jeremy      -          text/html attachment: RDF-XML_Syntax_Specification__Revised_.htm    application/x-zip-compressed attachment: RDF-XML_Syntax_Specification__Revised__files.zip          

          TEMPLATE Task Force Description    NAME XML Schema Datatypes and Semantic Web    STATUS: "Considered"      COORDINATORS:  Carroll + nominee of XML Schema WG    MEMBERS  approx 2 additional from SWBPDWG  and 2 additional from XML Schema WG      OBJECTIVES  This TF will consider two issues:  - what URI should be used within RDF and OWL for user defined XML Schema  Datatypes  - what is the relationship between the value spaces of the various XML  Schema built-in simple types when used within RDF and OWL    Resolution of these issues MUST be with consensus of  both SWBPDWG and XML Schema WG  A failure to reach consensus on either issue should be documented in a WG  Note.    DELIVERABLES  A WG Note describing the issue resolutions or the failure to resolve  An OWL Ontology describing the value spaces of the XML Schema builtin simple  Datatypes.    TARGET AUDIENCE & USE CASES  OWL and RDF Platform developers.  OWL and RDF ontology authors.  XML Schema Datatype library code developers (particularly those aiming at a  reusable datatyping component not solely targetted at XML Schema)      BACKGROUND READING  http://lists.w3.org/Archives/Public/www-archive/2002Nov/att-0092/  point 4 of  http://lists.w3.org/Archives/Public/www-webont-wg/2002Nov/0265    XML Schema links to do (i.e. to work in progress in that group)        

          I have looked at revision 1.216    Another great document.    I would be happy with this going out as is, but do have a few suggestions  for the editor.    ==============    (Fairly fast read).    Before last call I would like to give a thorough read and give  sentence-by-sentence suggestions for clarity improvement. I do not intend to  do that with this draft.      I was concentrating particularly on bagID this time round, and that seemed  OK.      Commnets:    section 3:    Note: "This particularly applies .... parseTypeLiteralPropertyElt."    somewhat confusing, in particular *all* info items are not available within  parseTypeLiteralPropertyElt.    I suggest    Unchanged:  "Note: Outside RDF/XML processing, all Information Items should be made  available to the application."    Changed:  "Note: The handling of XML content inside parseTypeLiteralPropertyElt  requires some other Information Items, to be determined."    or:  "Note: The handling of XML content inside parseTypeLiteralPropertyElt  minimally requires those Information Items required by Exclusive XML  Canonicalization."    (I think the second is the right answer with our resolution, but since this  draft does not make that explicit it is premature to say this).    Section 3.1.2  This handles xml:lang (and correctly deletes it), but fails to delete other  xml attributes.  ARP discards all attributes from the xml namespace. I have forgotten if we  have discussed this and decided what the correct behaviour is.    The ARP behaviour would be described by the following change:  Between  "value of the language property on the parent node."    "The subject property may be added "    insert new para  "Other attributes from the namespace "http://www.w3.org/XML/1998/namespace"  are removed from the list of attributes."    ***ISSUE***  The resolution we agreed on xml literals ignores xml:space on parent  elements. (i.e. the normal scoping of xml:space does not apply - if I  remember XC14N correctly). I did not highlight that at the time. That  behaviour is consistent with the text I suggest above, but might be  surprising.        Section 5.5  You want bagID to respect XML document order, as clearly stated  "3. Statements generated by the propertyEltList children by S4 in document  order "    I think the allowance to my sensibilities in  "S4 Handle the propertyEltList children nodes in document order (or any  order if none of them are rdf:li) "  is misplaced and could be simplified to  "S4 Handle the propertyEltList children nodes in document order"      Section 5.11 parseTypeLiteralPropertyElt is fine for now.    Section 5.13 parseTypeOtherPropertyElt    do we want this, since we seem to have decided that parseType is not an  appropriate extension mechanism. My preference would be to simply delete  this possibility. (It is a *change*).    Section 5.14  BagId stuff seems correct.    Jeremy                                >  >        

            Brian McBride wrote:    > At 11:42 09/04/2003 +0100, Jeremy Carroll wrote:  >   >> It seems that you just did propose ...  >>  >> I will if you were not proposing it ...  >   >   > As chair, I shouldn't propose, but I was trying to make a small   > contribution and save someone else the effort.  >       Thank you, I propose the text in Brian's message 0152      Jeremy        

        > > Dan:  > > > Brace yourself for mind-bogglinly deep  > > > formal argument:  > > >  > > > premise:  > > > <http://www.w3.org/> dc:title "W3C".  > > > conclusion:  > > > <http://www.w3.org/> dc:title "W3C".  > > >  > > > That's it.*      OK. Definitely a bug with TDL model theory.      I can describe the approach I will work on, but only in English at this  stage. Mathematics to follow later.    Pat's model theory (both the current draft and the editor's draft) on  entailment amount to:    An RDF Graph A entails another RDF Graph B if, given a set of URIRefs from  which the uriref labels are taken, and any interpretation of these uriref  into some universe, then:    whenever there is       some mapping of the blank nodes of A into that universe such that the  triples of A are satifisfied,    then       there is also a mapping of the blank nodes of B into that universe such  that the triples of B are satisfied.    In TDL what we should have is:    An RDF Graph A entails another RDF Graph B if, given a set of URIRefs from  which the uriref labels are taken, and any interpretation of these uriref  into some universe, then:    whenever there is       some mapping of the blank nodes and literal nodes of A into that  universe such that the triples of A are satifisfied (including all  datatyping triples, understood as in the TDL document)    then       there is also a mapping of the blank nodes and literal nodes of B into  that universe such that the triples of B are satisfied.    Peter suggests (if I have understood him correctly) that what I in fact  wrote had dropped the existential quantification over the blank nodes as  well!        Sorry for the mistake.  I haven't done model theory in the last fifteen years!    Jeremy        

      >  > we write stuff like:  >  > :Fred :hairColor "red".  >  > { ?x :hairColor "red" }  > log:implies { ?x a :RedHead }.  >  > and we expect our system to conclude  >  > :Fred a :RedHead.  >      Sorry Dan, I had missed this part of the message on Friday, (the first part  of your message was true so I didn't go further).      In TDL the model theory maps a literal to a pair.    So "red" ==> ( "red", x )    The first component is the (untyped) lexicalization, and the second  component reflects the (typed) interpretation of this string.    At an application level you could decide that you always wanted to refer to  the untyped lexicalization within your log:implies.    Personally, I think a better approach would be to declare a range constraint  on :hairColor e.g.    :hairColor rdfs:range xsd:string .    then "red" in the contexts given is unambiguously interpreted as < "red",  "red" > , and everything works as desired.  (Modulo the fixes to the model theory already required by the main "Duh"  example).      If I may change your example a little:      >  > :Fred :shoeSize "44".  >  > { ?x :shoeSize "44" }  > log:implies { ?x a :bigFoot }.    :Thelma :shoeSize "044".      In S-B we can declare that  :shoeSize rdfs:range xsd:integer.lex .    In this case, :Fred is a :bigFoot, but :Thelma isn't. S-B treats its objects  as strings, and does not interpret them, and so cannot equate "44" with  "044".    In TDL we can declare :shoeSize rdfs:range xsd:integer .    If we either:    make a closed world assumption about datatypes (i.e. that there aren't  datatypes that we don't know about)    or:      say that log:implies only cares about the typed values    then:       we also have :Thelma is a :bigFoot.      (The issue about the closed world assumption is that if there is say an  octal integer type, requiring lexicalization beginning in "0", and somewhere  a range constraint that  :shoeSize rdfs:range eg:octal .  then the description of :Thelma is ill-formed and the conclusion is false.)    I think TDL is a lot closer than S-B to what is desired in your example,  which in my view, is inference based on typed values. I don't think TDL is  perfect but ...    Jeremy        

      [Brian's message, below, was just to me, I guess he hit the reply button  rather than reply-to-all by mistake, or perhaps this was meant to be an HP  secret; if so, sorry Brian]    The basic serialization is much much better for machine 2 machine  communciations, which long term is the only use of RDF/XML. Basic  serialization is faster and simpler.    One needs to address the bNodes question at some point, then it works. But  since even the abbreviated syntax has the bNodes question it cannot be  avoided.    Jeremy    > -----Original Message-----  > From: Brian McBride [mailto:bwm@hplb.hpl.hp.com]  > Sent: 11 December 2001 17:00  > To: Jeremy Carroll  >  > At 12:49 05/12/2001 +0000, you wrote:  >  > [...]  >  > >The basic approach uses the basic RDF syntax from RDF Model &  > >Syntax([RDFMS]).  > >In this:  > ></p>  > ><ul>  > ><li>  > >All blank nodes are assigned arbitrary URIs.  >  > Whilst I have written code that does this, I don't think this is  > a good idea.  >  > Since we have agreed that bNodes don't have uri's, should the syntax spec  > be suggesting this way of serializing them?  >  > Brian  >  >        

          Sorry, I had missed that you had already sent a satisfactory draft for SOTD.    I've reread and commented on the (section of the) process document.    Your suggeted text  [[  This Working Draft consolidates changes and editorial improvements  undertaken in response to feedback received during the Last Call  publication of the RDFCore specifications which began on 23 January  2003.    ]]    is more elegant (IMHO) than the text you copied out below.    Let's pretend I hadn't spoken!    Jeremy          Dan Brickley wrote:    > The difference between the txt below and   > http://www.w3.org/2001/sw/RDFCore/TR/templates/sept-wd-sotd.html is   > that they're anticipating a CR as their next phase, whereas LC2 looks  > more likely for us. I don't feel the need to nail that one down at this   > stage though...  >   > There are a few phrases might be worth borrowing though.  >   > [[  > This  >   >>> interim publication is used to document the progress made on  >>> addressing the comments received during the second Last Call, as  >>> well as other modifications resulting from continuing collaboration  >>> with other working groups.  >>>  > ]]  >   > Perhaps dropping 'interim' since we don't name our next stage?  >   > Dan  >   > * Jeremy Carroll <jjc@hplb.hpl.hp.com> [2003-09-02 15:31+0100]  >   >>  >>They got very close to CR a month or two ago ...  >>  >>I would certainly prefer this sort of wording in our SOTD for the 5th Sept   >>publication.  >>  >>I guess that is Eric's call, as advised by the chairs.  >>  >>Jeremy  >>  >>  >>Dave Beckett wrote:  >>  >>  >>>Character Model for the World Wide Web 1.0  >>>W3C Working Draft 22 August 2003  >>>  >>>http://www.w3.org/TR/2003/WD-charmod-20030822/  >>>  >>>First one since April 2002.  Interesting wording:  >>>  >>> [[This is a W3C Working Draft published between the second Last  >>> Call on 30 April 2002 and a planned Candidate Recommendation. This  >>> interim publication is used to document the progress made on  >>> addressing the comments received during the second Last Call, as  >>> well as other modifications resulting from continuing collaboration  >>> with other working groups. A list of last call comments with their  >>> status can be found in the disposition of comments (public version,  >>> Members only version).  >>>  >>> Work is still ongoing on addressing the comments received during  >>> the second Last Call. We do not encourage comments on this Working  >>> Draft; instead we ask reviewers to wait for being informed about  >>> our disposition of their comments, or for Canditate Recommendation  >>> in case of new comments. ...  ]]  >>>  >>>maybe we could have something similar?  >>>  >>>The changes aren't entirely clear since they are in a member only web  >>>page that could be updated at any time compared to the above.  >>>  >>>Dave  >>>  >>>  >>>  >         

          They got very close to CR a month or two ago ...    I would certainly prefer this sort of wording in our SOTD for the 5th Sept   publication.    I guess that is Eric's call, as advised by the chairs.    Jeremy      Dave Beckett wrote:    > Character Model for the World Wide Web 1.0  > W3C Working Draft 22 August 2003  >   > http://www.w3.org/TR/2003/WD-charmod-20030822/  >   > First one since April 2002.  Interesting wording:  >   >   [[This is a W3C Working Draft published between the second Last  >   Call on 30 April 2002 and a planned Candidate Recommendation. This  >   interim publication is used to document the progress made on  >   addressing the comments received during the second Last Call, as  >   well as other modifications resulting from continuing collaboration  >   with other working groups. A list of last call comments with their  >   status can be found in the disposition of comments (public version,  >   Members only version).  >   >   Work is still ongoing on addressing the comments received during  >   the second Last Call. We do not encourage comments on this Working  >   Draft; instead we ask reviewers to wait for being informed about  >   our disposition of their comments, or for Canditate Recommendation  >   in case of new comments. ...  ]]  >   > maybe we could have something similar?  >   > The changes aren't entirely clear since they are in a member only web  > page that could be updated at any time compared to the above.  >   > Dave  >   >         

      Me:  >[8]  >RDF makes a distinction between equality and equivalence for  >Literals. RDF Literals are equal in accordance with [2].    gk:  > I'm having difficulty understanding the last sentence above, in its  > reference to [2].  Is this a typo?    Yes. The correct number is [4].  I renumbered the paragraphs this morning, and my awk script did not look for  refs.    Jeremy        

          > FWIW, I'm not sure why we need this term.       My preference would be to drop the term.    Jeremy        

            > -----Original Message-----  > If the restriction is that individuals can't be the _object_ of multiple  > triples, we could use an inverse of the 'depicts' of 'member'  > property instead,  > but that's an ugly hack. Is this restriction across all of OWL,  > or just the  > DL & Lite dialects?    Only OWL DL and OWL Lite.      A workaround is as follows.    <rdf:RDF xml:base="&my;"    xmlns:my="&my;" >  <owl:InverseFunctionalProperty rdf:about="#nodeID" />  <Image>   <depicts>    <Person>      <my:nodeID rdf:resource="gensym001"/>      <mbox rdf:resource="mailto:danbri@w3.org"/>    </Person>  </Image>    <Group>   <member>    <Person>     <my:nodeID rdf:resource="gensym001"/>     <homepage rdf:resource="http://www.w3.org/People/DanBri/"/>    </Person>   </member>  </Group>      This forces the two Persons to refer to the same resource, even though they  have different bnodes. You do need to pollute the URI space with the  gensym's, as far as I can tell. (You cannot use strings with  InverseFunctionalProperty's in OWL DL and OWL Lite).    Jeremy        

        > >From  > >  > >http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Sep/0104.html  > >  > ><rdf:Description>  > >   <eg:prop rdf:datatype="&xsd;deciaml">2.00</eg:prop>  > ></rdf:Description>  > >  > >is equal (i.e. syntactically)  > >  > ><rdf:Description>  > >   <eg:prop rdf:datatype="&xsd;deciaml">2.0</eg:prop>  > ></rdf:Description>  > >  > >  > >(We may first want to ask does the first entail [i.e. semantically] the  > >second, and/or vice versa).  >  > RDF entail?  RDFS entail?  Other entail?    Isomoprhic like an RDF/XML document and the corresponding N-triple document.  Hence, also all possible entailments.    Jeremy        

        Dan    I reworked appendix A, attached, if this is any help.    (Just reflects me getting annoyed with the bugs in   http://www.w3.org/2000/01/rdf-schema  which happens to be a URL in an ARP test case).    Changes from   http://www.w3.org/2001/sw/RDFCore/Schema/20010913/  appendix a    are:    1: delete 2nd para which refers to cycles  2: globally replace " ID" by " rdf:ID"                      " about" by " rdf:about"                      " resource" by " rdf:resource"  3: add the xml decl with the encoding.  4: changed one of the french terms which by poor french     suggested was wrong (isDefinedBy  estD?finiPar - jjc  or  esD?finiPar - old)    the old appendix A seemed to suggest   http://www.w3.org/2000/01/rdf-schema  (without any encoding statement).  Unfortunately   http://www.w3.org/2000/01/rdf-schema  is not legal XML.  The (omitted) XML declaration says it is in UTF-8, but the French escape  sequences are not legal UTF-8.    Jeremy        text/html attachment: fragaa.html          

          Pat,    the abstract syntax section of the first version of the paper is the most  finished and captures my current understanding of the treatment of blank  nodes, including the "blank nodes naming a graph" part, and blank nodes not  being shared, can you quickly review that and say what you think needs to  change.    Let's leave until after we've done the semantics the single issue of whether  blank nodes can or cannot be shared across graphs in the abstract syntax -  since we seem to agree that if we permit it, it has no semantic impact.  So once we've finished the semantics, we can experiment with removing the  constraint, and see whether we want to keep it or not.      Answering one of your points:  > >  except in the case  >  > I'd just have no exceptions, frankly. Why do you need to involve  > bnodes at all? Bnodes aren't supposed to be names of anything; that  > is the whole point of having bnodes in the first place.  >  > >where  > >the bnode names a graph and occurs (in a triple) in exactly one graph;    the motivation was in part to capture what N3 already permits with its  formulae, that can be seen as unasserted graphs that are named with a blank  node, which then participates in one other graph (typical the top-level  one).      Also, not permitting existentials to refer to graphs might require an  excessive use of skolemization to assign arbitrary names. I think blank  nodes capture such arbitrariness better than any name.    Jeremy    (No further comments, yet)        > -----Original Message-----  > From: Pat Hayes [mailto:phayes@ihmc.us]  > Sent: 15 March 2004 16:57  > To: Jeremy Carroll; patrick.stickler@nokia.com; chris@bizer.de  > Cc: www-archive@w3.org  > Subject: Re: Graphs: intension and extension  >  >  > >Thinking about other aspects of the paper, I reckon a key choice  > is whether we  > >think of a graph intentionally (like an rdfs:Class) or  > extensionally like a  > >set.  > >  > >The Carroll/Stickler paper went for extension, it might however  > be better to  > >go for intension.  >  > Is this really ext/int, or is it the type/token distinction (here the  > graph/document distinction, more or less)? It smells to me more like  > the latter. If I assign a name to a graph, am I claiming naming  > rights over the abstraction itself, or just over my instance of it?  >  > >  > >e.g.  > >if there is an RDF/XML document at http://example.org/x we can talk about  > ><rdfx:Graph rdf:about="http://example.org/x">  > >  > >we can annotate it with things like dc:creator  > >  > >we can compare it to other graphs with  > >    <rdfx:equivalentGraph> (graph isomorphism)  > >and  > >   <rdfx:subGraphOf> (understood as being isomorphic to a subgraph of)  > >  > >A blank node that names a graph is then just the usual existential ...  > >  > >The Carroll/Stickler paper also allows a blank node to be shared  > between two  > >graphs  >  > Ouch, I seem to have missed this. (Did I ever see a copy of this  > version of the paper?? I don't seem to have it.)  >  > >... this is seeming less than useful.  >  > Indeed, that is (forgive me) a terrible idea.  >  > >  > >Here is a test case in Chris TriG notation  > >  > ><a> ( _:a vc:name "Jeremy" )  > ><b> (_:b vc:name "Chris" )  > ><c> ( <eg> dc:creator _:a )  > ><d> ( <eg> dc:creator _:b )  > >  > >The problem is that <c> and <d> are equivalent, but if we accept all four  > >graphs they are saying different things. So if we accept some of  > the graphs  > >we need some mechanism for keeping track of which bnodes are  > which; which as  > >far as I can tell breaks more then we would want. I am currently inclined  > >just to prohibit bnodes to be shared between graphs,  >  > Right. That need not be a syntactic prohibition, only an  > understanding that there is a need to standardize apart when  > combining information from different graphs which both use a bnode.  >  > >  except in the case  >  > I'd just have no exceptions, frankly. Why do you need to involve  > bnodes at all? Bnodes aren't supposed to be names of anything; that  > is the whole point of having bnodes in the first place.  >  > >where  > >the bnode names a graph and occurs (in a triple) in exactly one graph; in  > >this case it is basically required to remember the graph named  > by the bnode  > >...  > >  > >The point of the example I guess is that the bnode _:a is  > playing a role in  > >linking two triples; the main reason for having those two triples in two  > >graphs is that some people might accept one of them without the  > other, which  > >then prevents the blank node from playing that role.  >  > It shouldn't. It is fine to infer (exists (x) P(x) ) from (exists (x)  > (P(x) and Q(x)) )  >  > >  > >I guess a potential use for blank nodes shared between graphs is  > that I can  > >copy one of your graphs and then make additional statements with  > one of your  > >blank nodes in an additional graph of mine - I think we could  > just ban that -  >  > No, let it happen. As long as when I import your blank nodes, they  > become my blank nodes, there is no harm in this and it might be  > useful.  >  > Don't mess with blank nodes: we had them completely understood, and  > they are totally debugged by 60 years of close attention from the  > logicians. All we have to do is to stick to the idea that they are  > bound in a graph, and have no connection with any names in any other  > graph. Use URIs for any naming process larger than a graph (including  > naming the graph.)  >  > Pat  >  >  > >it is certainly easier and the 80/20 rule seems to suggest we should.  > >  > >Jeremy  >  >  > --  > ---------------------------------------------------------------------  > IHMC(850)434 8903 or (650)494 3973   home  > 40 South Alcaniz St.(850)202 4416   office  > Pensacola(850)202 4440   fax  > FL 32501(850)291 0667    cell  > phayes@ihmc.us       http://www.ihmc.us/users/phayes  >  >        

        Having consulted with my colleagues I will *not* be proposing to drop  reification.    However, in the feedback I got the following suggestion was made:      > There are two use cases which, if not supported by reification,  > you need to at least document recommended solutions - provenance  > and quoting.  [ ... ]    > One approach might be to not remove reification but to relegate it to an  > advisory section. In particular, leave in the rdf:Statement,  > rdf:subject etc tags as reserved tags. Have two "how to's" which  > describe how one might represent provenance or quoting in RDF and  > say that you have reserved the tags  > "rdf:Statement" etc for this purpose but they have no special  > semantic status other than being the recommended type tags to  > use if you are trying to encode ground facts which happen to be about  > RDF statements.      This approach allows us to:  - avoid the "RDF is (NOT) its own metatheory" hole.  - avoid the stating versus statement problem (depends on usage).  - keep the good bits of reification (have standard vocab. for modelling  RDF).    It is characterised by there being no model theory for reification.    I am well aware that Pat may yet produce a reification rabbit out of his  hat, but currently this sort of approach is my favourite.    We could even throw out all the syntax for reification and still follow this  suggestion; it is more within charter not to do so, and I will not be  proposing such a step.    Jeremy        

        At the teleconference, I got the impression that Dave was after feedback, so  here's some more :-).    I do not believe that we have discussed the following issues (although I  have mentioned some privately to Dave). As such, it is appropriate that they  are not in the current WD; but I would hope they would be addressed before  the next WD.    1: Whitespace  =============  M&S does not describe how to process whitespace in RDF/XML. (Well it does,  but what it says doesn't work).  The grammar in the WD carries that error too.  I have two possible fixes:  a: extend the grammar with an explicit whitespace production  b: add text adequately capturing the whitespace rules.  e.g. "Whitespace is significant in attribute values, where XML whitespace  processing applies, and within literal values. Elsewhere it is ignored."    An example of (a) is the ARP grammar. I prefer (b) for the spec.    2: XML Attributes  =================  M&S and the new WD do not specify that attributes whose name starts in  [xX][mM][lL] are discarded when RDF processing, (although they may impact  XML processing, e.g. xml:lang, xml:space,  xml:someFutureThatHasNotBeenThoughtOf). Again, the grammar can be modified  to capture this, or text added. Again I prefer text in a specification, and  modifying the grammar in an implementation.    3: "(can be empty)"  ==================  This phrase occurs a couple of times and should be emphasised in the  supporting text, since XML does not allow this, i.e. the XML Infoset of the  document is missing the supposed text string rather than having an empty  text string as suggested by the grammar. Again, elegance and clarity of  exposition in my mind takes priority over having an exact correspondence  between the Infoset and the grammar.      Jeremy        

              http://lists.w3.org/Archives/Public/www-archive/2002Dec/att-0053/00-rc    Jeremy        

        Dave wrote:  > The various parsers do different things on this RDF/XML - which is  > wrong - so we must define one way or forbid it.    I agree with Dan C on this. The M&S grammar is clear. rdf:type takes a URI  reference as an attribute, everything else takes a string.    My view is, unless the implementation community have made plausible  mistakes, we should not consider changing the spec. To me, this mistake is  not sufficiently plausible.    If you want to give a URI for an rdf:subject property (or any other) it is  not hard (the rdf:resource attribute in a property element rule). I think  the change you are considering is just making life more difficult for parser  developers with insufficient compensation for rdf document writers. In  particular, I hope there are not people writing reified triples into  documents without any tool support. If there is tool support then the  current syntax is OK. If there isn't tool support then the model is overly  complex, and any syntax for an explicit reification is a nightmare.    To be clear:    <?xml version="1.0"?>  <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">    <!-- Test reified statement using attributes only -->    <rdf:Description  rdf:type="http://www.w3.org/1999/02/22-rdf-syntax-ns#Statement"                     rdf:subject="http://example.com/resource"                     rdf:predicate="http://example.com/predicate"                     rdf:object="literal" />  </rdf:RDF>      _:id1 <http://www.w3.org/1999/02/22-rdf-syntax-ns#type>  <http://www.w3.org/1999/02/22-rdf-syntax-ns#Statement> .  _:id1 <http://www.w3.org/1999/02/22-rdf-syntax-ns#subject>  "http://example.com/resource" .  _:id1 <http://www.w3.org/1999/02/22-rdf-syntax-ns#predicate>  "http://example.com/predicate" .  _:id1 <http://www.w3.org/1999/02/22-rdf-syntax-ns#object> "literal" .      Note this is different from both the other two versions we've had!  This is clearly an issue :-(.    Jeremy        

          Summary:  Prefer c++  modify  the test case to say that the case is D-consistent with the  empty graph, not that it is D-entailed by it;  add D-inconsistent test using a different rdfs:subClassOf triple between   xsd datatypes.          pat hayes wrote:      > (a) modify the test case doc by deleting the test case;    Not particularly OK, well unless the semantics doc discusses   rdfs:subClassOf in datatyping clearly. i.e. this should not be left as an   exercise for the reader.    > (b) modify the test case to say that this only follows under the   > strengthened extensional semantic conditions on rdfs:subClassOf   > described in section 4.1 of the semantics document;    not good    > (c) modify  the test case to say that the case is D-consistent with the   > empty graph, not that it is D-entailed by it;    OK  Also add a test case showing that  xsd:string rdfs:subClassOf xsd:integer .  is inconsistent.    > (d) modify the semantics of D-interpretations to insist that datatype   > class subsetting *is* treated extensionally, so that the rule rdfD4 is   > valid and the test case is OK. This can be done by adding the following   > semantic condition on D-interpretations:    Prefer (c) to this.  (Another option is to explicitly list rdfs:subClassOf relationships between   xsd datatypes as true by fiat).    Jeremy        

        [[This is an offlist thread I am moving on-list because I think this is of  wider interest]]    Graham and I are discussing the definition of a triple.    In the text of the current published draft:    http://www.w3.org/TR/2002/WD-rdf-concepts-20021108/#xtocid103646    which I essentially want to leave unchanged, the term blank node is not part  of the defintion of a triple, instead blank node is defined later, depending  on this definition of triple.    It is, however, confusing to suppress the key concept of blank node to the  extent that the current published draft does.    There is something quite elegant about the current negative definition of a  blank node - what is a blank node? we don't tell you, we only tell you what  it isn't. This elegance does capture something of the elusiveness of blank  nodes.    Graham prefers text like:    Graham:  > > An RDF triple contains three components:  > >  > > the subject, which is an RDF URI reference or a blank node  > > the predicate, which is an RDF URI reference  > > the object, which is an RDF URI reference, a literal or a blank node  > >    This is reminiscient of Pat's  earlier texts. Pat made these work by having  an explicit ready supply of blank nodes.  My text has an implicit ready supply of nodes.    Graham:  > Well, IIRC, you say later that a blank noide is one that isn't a URI or a  > literal.  I considered that the term blank node here would just be a  > forward reference to that description, as are URI reference and literal.  >  > I don't think this is critical.    My worry is that we then get to a circular defn:    Currently:    blank node depends on graph depends on triple depends on (uriref and  literal).    If blank node is added to the defn of triple we get:    blank node depends on graph depends on triple depends on (uriref and literal  and blank node).      Any thoughts?    Jeremy        

            Brian McBride wrote:    > Great stuff Pat.  I will upload the latest version so the WG page points  > to it as the ed's working draft.  >   > Re issue closures:  >   > We closed horst-01 last week so thats done and you can send the  > response, but you need to add a link to the decision.  >   > Regarding the others, since we don't have a telecon this week, is there  > anything to be gained by asking the commentors whether they would accept  > the proposed resolution in the meantime.  If there are some minor tweaks  > or discussion to be had, this could be done in the meantime.  >   > Brian      With the pfps-0X issues, Pat is proposing to accept all of them, as   addressed in the current editors draft.    I suggest that this is sufficiently uncontroversial to do by e-mail, and I   am prepared to second all the pfps-0X proposals.    pfps-02, pfps-04, pfps-06, pfps-09    http://www.w3.org/2003/06/Process-20030618/policies.html#Consensus  [[  Decisions MAY be made during meetings (face-to-face or distributed) as well   as through email.  ]]    I am sure Peter would prefer to have WG decisions to review.    The pan-01 and qu-03, since Pat is proposing to reject them, should, IMO,   be dealt with in a telecon.    Jeremy        

        Aldo Gangemi wrote:  >   >   > Yes I have. Some of them have replied and wait for drafts to take any   > action.  > A    Personally, as much as possible I would like to see all such messages   cc-ed to this list; if that is inappropriately public then cc-ed to   w3c-archive@w3.org (member confidential) and pointers posted to this list.    Jeremy        

      Hi Patrick,    I reply to some of your earlier questions below.    I attach a snapshot of where I am at with the Model Theory, along with some  comments on your text. The text I have produced so far is not either the  simpler or the more advanced text that I am planning to produce and hence is  not ready for insertion into the document yet. It's somewhere in between.  Once I have finished it at this level I will both simplify and embellish it  to produce the main text and the appendix text, respectively.    References for bit are:    The version of the RDF Model Theory I am working from is this one:    http://lists.w3.org/Archives/Public/www-archive/2002Jan/att-0007/01-RDF_Mode  l_Theory.htm    Patel-Schneider's document is:    http://lists.w3.org/Archives/Public/www-webont-wg/2001Dec/att-0156/01-swol2.  text    Jeremy      >  > Does it help to split the interpretation process onto two  > "levels" or "phases" where first one interprets the idiom  > to obtain the TDL pairing and then, once the pairing is  > known, interpret the pairing to get the mapping.    Unfortunately not, see on.    >  > The latter phase seems (in my admitted ignorance) to be  > rather simple, since there is a one to one correspondence  > between a pairing and a mapping. And since the TDL pairing  > includes the type and lexical form, they are both present  > for the interpretation of that phase.    In practice we have to address the question of what happens when there are  two types specified. This motivates a significant part of the complexity. S  is significantly simpler in this respect, but buggy. (i.e. on the "as simple  as possible but no simpler" axis, S-B, IMO goes too far).      >  > As for the former phase, the interpretation of the idiom,  > does this really need to be grounded in the MT?    Yes, because the global type information can only be accessed through the  MT. e.g. a range constraint may be through any number of subProperty  relationships etc.    >  > Also, for idiom S/B, the mapping is not explicit, but is  > as implicit as the TDL pairing, as all that is identified  > in the graph is the lexical space of the datatype (with the  > datatype itself implied by the relation of lexical space  > to datatype) and the lexical form. How is TDL different?  > (asking this humbly so that I understand it myself)  >  > The node that represents the actual member of the value space  > is always constant, being the object node of the statement,  > which is either labeled with the literal or an anonymous  > node with rdf:value property defining the literal.  >  > > I think we bite the bullet and make noises about tails and dogs).  >  > Right.  >  > > I am currently planning to get writing on Wednesday. I might  > have some time  > > tomorrow.  >  > Fair enough. I plan to work on the final verbage today and tomorrow,  > adding in the discussion of the desiderada and some clarifications  > suggested by recent comments.  >  > I think I'll put together a separate summary of what I see as the  > shortcomings of S, not including it in the TDL proposal itself.  >  > Patrick  >  >  > --  >  > Patrick Stickler              Phone: +358 50 483 9453  > Senior Research Scientist     Fax:   +358 7180 35409  > Nokia Research Center         Email: patrick.stickler@nokia.com  >  >  >          text/html attachment: TDL_Model_Theory.html          

          Thanks for catching that.  Will update in a few hours.    Jeremy    > -----Original Message-----  > From: Graham Klyne [mailto:gk@ninebynine.org]  > Sent: 22 July 2003 17:01  > To: Jeremy Carroll; w3c-rdfcore-wg@w3.org  > Subject: Re: RDF Concepts editors draft updated  >  >  > Jeremy,  >  > This doesn't cover the full extent of the WG agreement:  >  > [[  > Vocabulary terms in the rdf:  namespace are listed in  section 5.1 of the  > RDF syntax specification [RDF-SYNTAX]. Some of these terms are defined by  > the RDF specifications to denote specific concepts. Others have syntactic  > purpose (e.g. rdf:ID is part of the RDF/XML syntax) and should  > not be used  > in RDF to denote any kind of resource.  > ]]  >  > should be  >  > [[  > Vocabulary terms in the rdf:  namespace are listed in  section 5.1 of the  > RDF syntax specification [RDF-SYNTAX]. Some of these terms are defined by  > the RDF specifications to denote specific concepts. Others have syntactic  > purpose (e.g. rdf:ID is part of the RDF/XML syntax).  > ]]  >  > i.e. delete the final part of the last sentence.  >  > I've just realized this didn't make it to the minutes of that  > telecon [1],  > though the revised wording was recorded in the IRC [2].  >  > #g  > --  >  > [1] http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2003Jul/0173.html  >  > [2] http://ilrt.org/discovery/chatlogs/rdfcore/2003-07-11#T15-05-53  > and agreed:  >      http://ilrt.org/discovery/chatlogs/rdfcore/2003-07-11#T15-07-55  >  >  > At 23:04 21/07/03 +0300, Jeremy Carroll wrote:  >  >  > >I have done these four actions, as per the telecon minutes:  > >  > >I18N interest:  > >JJC   add warning to Concepts 3.4 to use XML if markup required  > >  > >more boring:  > >JJC   apply pfps-22/23 changes as agreed last week  > >JJC   remove normative references to RDFS URI  > >JJC   remove references to term "RDF core" in Concepts  > >(mainly impacting section 4)  > >  > >  > >Editors draft URI:  > >http://www.w3.org/2001/sw/RDFCore/TR/WD-rdf-concepts-20030117/  > >  > >  > >Graham, please review section 4, and if the overall text looks OK give  > >peter a  > >heads up to see if he is less unhappy.  > >  > >The text I have added to 3.4 is a normal paragraph at the end of  > the section  > >which reads:  > >[[  > >For natural language text that may require markup, the use of  > typed literals  > >with type rdf:XMLLiteral is suitable. In such cases, a language tag, if  > >required, must be explicitly included within the markup, usually  > as the value  > >of a xml:lang or lang attribute, possibly on a span or div element,  > >additional to the principal content [XHTML].  > >]]  > >  > >The informative reference to XHTML is new.  > >  > >Jeremy  >  > -------------------  > Graham Klyne  > <GK@NineByNine.org>  > PGP: 0FAA 69FF C083 000B A2E9  A131 01B9 1C7A DBCA CB5E  >  >        

          > Test case:  >  > <rdf:Description rdf:about="#something">  >   <p1>abc</p1>  >   <p2 rdf:datatype="&xsd;string">abc</p2>  > </rdf:Description>  >  > entails?  >  > <rdf:Description rdf:about="#something">  >   <p1 rdf:nodeID="X" />  >   <p2 rdf:nodeID="X" />  > </rdf:Description>  >  > (please add that to the test collection, Jeremy/Jan/et. al.)  >    Answer: no it does not.    It is a good question - and it demonstrates that langstrings and strings are  distinct types.    Jeremy        

        > as far as I understand it, we're not giving XML literals  > (parseType="Literal") an additional datatype URI, the datatype URI is  > fixed to the URI of rdfs:XMLLiteral    This is my understanding, too; however the suggestion is worth considering,  next time around - Brian's postponement is correct.    Jeremy        

        I wrote:  >  > things.xml                      http://www.example.org/things  >  [...snip...]  > Issues that strike me:  >  > In the rdfs:range statements just how do you refer to the types:  > I've used a  > qname maybe an rdf:resource="full-uri-ref-with-fragment" would have been  > better.  >    I attach things.xml in this latter style ...    Jeremy    ======    <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"       xmlns:eg="http://www.example.org/things#"       xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"  >   <!-- We assume this document is available at  http://www.example.org/things -->      <rdfs:Property ID="showSize">         <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#int"/>    </rdfs:Property>      <!-- issue: I've just stuck a qname in an attribute, ... -->    <rdfs:Property ID="favouriteColour" >       <rdfs:range rdf:resource="http://www.example.org/colour#Colour"/>    </rdfs:Property>    <rdfs:Property ID="squareRoot">       <rdfs:range  rdf:resource="http://www.example.org/complexNumber#complexNumber"/>    </rdfs:Property>  </rdf:RDF>          text/xml attachment: things.xml          

          I am happy to do:    > working draft, and 'Normalization' as a simple working draft. The  > last call for 'Fundamentals' is planned to be short, because the  > intention is mainly to allow previous commenters to make a  > cross-check of the changes we have made, which we think were all  > tweaks rather than big changes.      i.e. to look at which parts, if any, correspond to what we have already  commented on, and to have a review which hopefully would be short and sweet  (i.e. nothing that we have previously commented on has got worse, and  everything that we previously commented on has got adequately better)    Jeremy        

          Concepts ready.        

            pat hayes wrote:      > For some reason, the pubrules checker thinks that there is something   > wrong with the boilerplate, but it seems to have all the links and   > things that the checker says are missing, all cut-and-pasted from docs   > that the checker was OK with. The other filters are OK.  >       Yes it's very fussy - concepts gets through - I was following Frank's msg.    I suggest that whoever picks up on semantics SOTD copies it from concepts   or primer.    Guessing: the problem with DanBri's boiler plate was that a paragraph was   required to be in <em> and wasn't.    Jeremy        

      I should have linked to the dissent messages as well, how about adding the following as the last paragraph (before my name)    [[  The dissenters primarily considered this as a significant change to both RDF and the understanding of RFC2396 and hence an inappropriate step for rdfcore WG, independent of the technical merits or otherwise of the decision. [11] [12]    [11]  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Apr/0537.html  [12]  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Apr/0534.html  ]]    (I note that the message I pulled out for Aaron (0537) is mid-thread, but I judge it as powerfully expressing his position).    Jeremy    -----Original Message-----    From: w3c-rdfcore-wg-request@w3.org [mailto:w3c-rdfcore-wg-request@w3.org]On Behalf Of Jeremy Carroll    Sent: 02 May 2002 17:08    To: w3c-rdfcore-wg@w3.org    Subject: charmod-uri draft message          Draft:     - for www-rdf-interest           www-webont-wg           uri           w3c-i18n-ig           xml-names-editor@w3.org      The RDF Core WG has decided [1] that the URI ref labels used in an RDF graph are in Unicode rather than US-ASCII.    These are seen as "original character sequences" in the terminology of RFC 2396 (see [10]).       This is motivated by the clarity in XML Erratum 26 [2] (and equally in XLink section 5.4) that the %-escaping algorithm that is used for mapping international characters into US-ASCII is "performed only when absolutely necessary and as late as possible in a processing chain".       In the terms of the text from xlink [3] the labels on the RDF graph  "must be a URI reference as defined in [IETF RFC 2396], or must result in a URI reference after the escaping procedure [...] is applied."      Moreover, the WG decided, guided by charmod [4] that such labels should conform with Unicode Normal Form C.      For those unfamiliar with the RDF graph but familiar with XML Namespaces, the analogous decision would be that the identifier of an XML Namespaces "must be a URI reference as defined in [IETF RFC 2396], or must result in a URI reference after the escaping procedure [...] is applied." and that the escaping procedure is *not* applied before considering whether two such identiers are identical.      The decision was with dissent, and RDF Core WG welcomes feedback both positive and negative to www-rdf-comments@w3.org. We expect to review this decision in the light of the feedback.      We note that the current WD of Namespaces in XML 1.1 [5] does *not* follow the text from xlink or erratum 26, and would particularly value feedback from both the XML Names editors and I18N IG on this issue.      The test cases agreed to represent this issue are found in [6], and [7]      Detailed rationale:    - the normative dependency of M&S on XML Erratum 26, see  [8]    - the possibility of URI fraud with non NFC international URIs see [9]    - a test case that is unclear under M&S.    - an XML Namespace test case that is similar.      See appendix below.        An alternative would be specifying %-escaping before forming the graph. This is in line with common practice in the RDF community.    The test case below indicates that clarity would require specifying the case of % escaping. So that clarification    would involve adding to the well-known % escaping algorithm of RFC 2396.    Within the RDF/XML serialization the URI fraud issue would be addressed by requiring the XML to be fully normalized.     This would not address the security issue in non-XML uses of RDF, in which any reverse %-encoding (necessary for legibility in I18N environments) may introduce the problematic cases.              Jeremy Carroll    HP Rep on RDF Core    Issue owner        References      [1]    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Apr/0474.html    [2]    http://www.w3.org/XML/xml-V10-2e-errata#E26    [3]    http://www.w3.org/TR/2001/REC-xlink-20010627/#link-locators    [4]    http://www.w3.org/TR/2002/WD-charmod-20020430     [5]    http://www.w3.org/TR/2002/WD-xml-names11-20020403/    [6]    http://www.w3.org/2000/10/rdf-tests/rdfcore/rdf-charmod-uris    [7]    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Apr/0116.html    [8]    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Mar/0012.html    [9]    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Mar/0027.html    [10]    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002May/0008.html        More test cases      RDF/XML      <rdf:RDF        xmlns:eg="http://example.org/#">      <eg:Andr?? rdf:about="http://example.org/#x">        <eg:foo rdf:resource="http://example.org/#Andr%c3%a9"/>        <eg:bar rdf:resource="http://example.org/#Andr%C3%A9"/>      </eg:Andr??>    </rdf:RDF>      Is the label on the typed node the same as the label on the <eg:foo> object or the <eg:bar> object,    (or are they the same).        XML Names      <eg xmlns:a="http://example.org/#Andr%c3%a9"        xmlns:b="http://example.org/#Andr%C3%A9"       xmlns:c="http://example.org/#Andr%c3%a9       a:a="a" b:a="b" c:a="a" />      If this is not well formed, why? (under the current spec and the latest WD because ?? is not US ASCII?)     What about the three other cases formed by deleting one of the last three attributes.        

            I had assumed that:       aaa <rdf:type> <rdf:Bag> .       aaa <rdf:_NNN> bbb .     aaa <rdf:_MMM> ccc .         =>        aaa <rdf:_MMM> bbb .      where aaa is a bNode or URI and bbb, ccc are anything.    (This means that a bag with n members licenses n^2 edges ).        Jeremy        

          My message quotes from a member confidential document and can be found at:  http://lists.w3.org/Archives/Member/w3c-archive/2004Apr/0058    maybe Ralph will suggest how we discuss it, without violating  confidentiality rules.    I would be happy to repost it here with the member confidential quotes  deleted.    Jeremy        

        Jeremy:  > > I would not be opposed to deleting parseType="Literal"  DanC:   > I would prefer that to the extremely loose interpretation you're  > suggesting...    I do not want to break all RDF/XML processors (or all but one) and  anything other than an extremely loose interpretation or straight  deletion will do that.    Jeremy:  > Your .nt attachment suggests that represtentations that are  > indistinguishable from strings are OK. That's going to far, for me.    That is my intent.    >   > > Taking your challenge and following 2, I attach an n-triples file.  > >  > > The literal, (in pieces that need to be concatenated is)  > >  > > "\n      Ramifications of\n         <apply xmlns=\"http://www"  > > ".w3.org/TR/REC-mathml\" xmlns:dc=\"http://purl.org/metadata/d"  > > "ublin_core#\" xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-sy"  > > "ntax-ns#\">\n        <power></power>\n        <apply>\n      "  > > "    <plus></plus>\n          <ci>a</ci>\n          <ci>b</ci>"  > > "\n        </apply>\n        <cn>2</cn>\n      </apply>\n     "  > > " to World Peace\n    "  >   > That doesn't make it clear that it's a parseType="Literal"  > value.    No. The only way to tell is to stick it betwenn "<foo>" and "</foo>" and  try parsing it with an XML parser.      DanC:  > That .nt file (after I put a period at the end  > of the last line) also corresponds to this RDF/XML input:  >   > <rdf:RDF xmlns="http://purl.org/metadata/dublin_core#"  >     xmlns:log="http://www.w3.org/2000/10/swap/log#"  >     xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">  >   >     <rdf:Description rdf:about="http://mycorp.com/papers/NobelPaper1">  >         <Creator>David Hume</Creator>  >         <Title>  >       Ramifications of  >          <apply xmlns="http://www.w3.org/TR/REC-mathml"  > xmlns:dc="http://purl.org/metadata/dublin_core#"  > xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">  >         <power></power>  >         <apply>  >           <plus></plus>  >           <ci>a</ci>  >           <ci>b</ci>  >         </apply>  >         <cn>2</cn>  >       </apply>  >       to World Peace  >     </Title>  >     </rdf:Description>  > </rdf:RDF>  >     Well, I am not going to check it! But yes, that is the idea.    Jeremy        

        Uschold, Michael F wrote:    > "there is no reason for the whole world to have read the OWL   > S&AS document just so they can understand our examples "  >   > One way to address this might be to have a short/sweet tutoiral on the AS.  >   > One way to deal with the syntax shock Tim mentions (and that I continue to experience every time I see some), is to assume that in general, few folk in the world will be EXPECTED to read raw OWL (or RDF) syntax. Exceptions include those who need to be concerned about the syntax and parsing of the language. I advocate this position, something more readable is needed. If we agreed that far, we could begin discussion of what particular variant(s) are preferred.  >   > Mike  >       I don't think so - I tend to agree with Frank that there isn't a single   answer. It may be helpful to have a tutorial on the abtsract syntax, but   that won't make the universal answer.    One of the aspects of the syntax shock is that it is so XML unfriendly,   making a more friendly XML syntax for RDF I suspect would make it even less   palatable to naive users.    There is not one 'syntax shock' but many: RDF/XML is a compromise between   pressures in different directions. OWL AS is more palatable to some   communities, and less palatable to others.    Jeremy        

            Patrick.Stickler@nokia.com wrote:    > Somewhere, we have to draw the line, and pretending that "  10  "   > is a valid lexical form for xsd:integer is simply going too far.      Personally I find this compelling - but as HP rep I have to give more   weight to the HP implementation report.    ...    I am happy to make changes or not to concepts to follow whatever the WG   decides - it will take no more than a day, so that a puboishable version of   concepts could be ready on the Tuesday after a WG decision to publish -   (Monday if no change to the current text)    Jeremy        

      After what I have heard in the telecon, I think it is worth stepping through  some very simple examples, being aware of what xslt makes of them.    This is a fairly long message, sorry.    We will arrive at a single 'complete' proposal for xml literal.    The only thing we are considering here is namespaces within the xml literal  "<foo/>".    There is a zip file attached, but it is only if you wish to run the examples  with your own version of xslt.    I have used saxon 6.4      Outline  =======    0: Assumptions  1: Namepaces That Aren't Used Should Be Ignored  2: Use of Exclusive Canonicalization  3: Difficulties with QNames as Attribute Values  4: InclusiveNameSpaces & Attribute Value "Literal"  5: Comments  6: A Proposal  7: What's the other path?        0: Assumptions  ==============    I assume:  - we do not want "namespace pollution"  - we want RDF/XML to be processable through XSLT without getting corrupted.  - following Eric's comments about comments, that we do not want to lose  potentially relevant information.    The second condition is tested using the copy transform taken verbatim from  the XSLT recommendation (copy.xsl in zip):  [[[  <!-- This program is taken from the XSLT recommendation:  http://www.w3.org/TR/1999/REC-xslt-19991116#copying  -->    <!-- For example, the identity transformation can be        written using xsl:copy as follows:  -->    <xsl:template match="@*|node()">    <xsl:copy>      <xsl:apply-templates select="@*|node()"/>    </xsl:copy>  </xsl:template>  ]]]    1: Namepaces That Aren't Used Should Be Ignored  ===============================================    So applying this to file a_1.xml  i.e.  [[[  <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"     xmlns:eg="http://example.org/" >     <rdf:Description>       <eg:a rdf:parseType="Literal">           <foo/>       </eg:a>     </rdf:Description>  </rdf:RDF>  ]]]    We get c_1.xml:  [[[  <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"           xmlns:eg="http://example.org/">     <rdf:Description>       <eg:a rdf:parseType="Literal">           <foo/>       </eg:a>     </rdf:Description>  </rdf:RDF>  ]]]    The very similar a_2.xml:  [[[  <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"     xmlns:eg="http://example.org/" >     <rdf:Description>       <eg:a rdf:parseType="Literal">           <foo></foo>       </eg:a>     </rdf:Description>  </rdf:RDF>  ]]]    is 'copied' to c_2.xml which is identical to c_1.xml  This is an example of how differences that are not in infoset are ignored by  XSLT.    Now, slightly more to the point, in a_3.xml we have a difference that is in  infoset:  [[[  <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"     xmlns:EG="http://example.org/" >     <rdf:Description>       <EG:a rdf:parseType="Literal">           <foo/>       </EG:a>     </rdf:Description>  </rdf:RDF>  ]]]    The namespace prefix eg has been replaced by the namespace prefix EG.    c_3.xml, the result of copying a_3, is not surprising:  [[[  <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"           xmlns:EG="http://example.org/">     <rdf:Description>       <EG:a rdf:parseType="Literal">           <foo/>       </EG:a>     </rdf:Description>  </rdf:RDF>  ]]]    At this stage, it appears as though changing the namespace prefix has not  changed the xml literal (which doesn't use any namespaces!).    However, a different transform extracts the xml literal from its element and  makes it a complete xml document.  The first two examples (i.e. x_1.xml and x_2.xml) in the zip are  [[[  <a>           <foo    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"    xmlns:eg="http://example.org/"/>       </a>  ]]]    Whereas the third example (x_3.xml) is:  [[[  <a>           <foo    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"    xmlns:EG="http://example.org/"/>       </a>  ]]]    NOTE Both namespaces are part of the <foo/> element as far as XSLT is  concerned, and the namespace prefixes matter. Thus as far as xslt is  concerned, the xml literals in a_1.xml and a_3.xml are different, even  though both are "<foo/>" surrounded by identical whitespace.      OPINION (uncontroversial?)  =======    I regard these extracts as illustrating "namespace pollution".  I think that the two documents a_1.xml and a_3.xml describe the same RDF  graph despite the difference between them (prefix "eg" replaced by prefix  "EG").        Moving on to a_4.xml this is:  [[[  <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"     xmlns:eg="http://example.org/" >     <rdf:Description>       <eg:a rdf:parseType="Literal">           <foo xmlns:eg="http://example.org/" />       </eg:a>     </rdf:Description>  </rdf:RDF>  ]]]    If this is our RDF input file, the author may expect that the namespace "eg"  is present on the xml literal. If you look at the xml (as text) it is indeed  there!    But ...  If we xslt copy this we get c_4.xml  [[[  <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"           xmlns:eg="http://example.org/">     <rdf:Description>       <eg:a rdf:parseType="Literal">           <foo/>       </eg:a>     </rdf:Description>  </rdf:RDF>  ]]]  which is the same as c_1.xml and c_2.xml.    What has happened is that the data model used by XSLT uses namespace  attribtues to compute the namespaces on the elements and then discards them.  The new namespace declaration does not change the namespaces on that element  ("eg" was already in scope) and hence is ignored completely.    Indeed running the extract transform to get x_4.xml we also get (almost) the  same as before:  [[[  <a>           <foo xmlns:eg="http://example.org/"   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"/>       </a>  ]]]  (note that Saxon has reversed the order of the namespace attributes, this is  not in infoset, and should be ignored)    However putting the same text string into the context of a_3 we get a_5.xml:    [[[  <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"     xmlns:EG="http://example.org/" >     <rdf:Description>       <EG:a rdf:parseType="Literal">           <foo xmlns:eg="http://example.org/" />       </EG:a>     </rdf:Description>  </rdf:RDF>  ]]]    This one is distinguishable under XSLT from all the others.  If we look at the "copied" file c_5.xml we see that the extra namespace  declaration does not vanish:  [[[  <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"  xmlns:EG="http://example.org/">     <rdf:Description>       <EG:a rdf:parseType="Literal">           <foo xmlns:eg="http://example.org/"/>       </EG:a>     </rdf:Description>  </rdf:RDF>  ]]]    Moreover looking at the extract file x_5.xml, we see that the literal has  more namespaces than previously:  [[[  <a>           <foo xmlns:eg="http://example.org/"    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"    xmlns:EG="http://example.org/"/>       </a>  ]]]      My take on these examples is that:  - the first three examples are all the same.    (the first two have identical infoset, the third is identical text).  - so is the fourth, because XSLT cannot distinguish it from the first.  - also the fifth is the same as the fourth because the text version is self  contained and identical.    i.e. all the examples (1 to 6) are basically "<foo/>" which only refers to  the default namespace and so any other namespace declaration is irrelevant!!    This differs from Infoset which sees the namespace attributes and the  namespaces as part of the element content, and from XSLT which doesn't see  the namespace attributes but does see *all* the namespaces as part of the  element content.    2: Use of Exclusive Canonicalization  ====================================    There is only one XML spec that I am aware of which worries in this sort of  way about referring to namespaces; ignoring ones that are not used. That  spec is the exclusive canonicalization spec. The key concept is:  http://www.w3.org/TR/2002/CR-xml-exc-c14n-20020212#def-visibly-utilizes    [[[  An element E in a document subset visibly utilizes a namespace declaration,  i.e. a namespace prefix P and bound value V, if E or an attribute node in  the document subset with parent E has a qualified name in which P is the  namespace prefix. A similar definition applies for an element E in a  document subset that visibly utilizes the default namespace declaration,  which occurs if E has no namespace prefix  ]]]    (that is the only new concept in exc-c14n).      Using this concept we could imagine a statement like:    "An xml literal includes the namespaces which are visibly utilized by that  literal, and no others."    or (more strongly)    "An xml literal is formed by taking the exclusive canonicalization of the  element content."    Either of these statements would be consistent with all the examples 1 to 6  being of the same literal. Note that the examples 4, 5 and 6  in which the  original XML has explicit namespace declarations within the xml literal *do  not* visibly use those namespaces, and so the namespace declarations are  simply ignored.    I use the transform smaller.xsl in the zip to make the files s_1.xml etc.  These are like the x_1.xml etc but without the invisible namespaces.    <aside>  Two other possibilities other than using at least the concept of visible  utilization from exc-c14n are:  - follow M&S in *not* addressing the namespace in xml literal issue.  - do our own thing independent of XML groups.    I do not see either of these as attractive.  </aside>    3: Difficulties with QNames as Attribute Values  ===============================================    Moving on to example 7 a_7.xml:  [[[  <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"     xmlns:eg="http://example.org/"     xmlns:q="http://example.org/q"  >     <rdf:Description>       <eg:a rdf:parseType="Literal">           <foo bar="q:name"/>       </eg:a>     </rdf:Description>  </rdf:RDF>  ]]]    As far as XSLT is concerned the qname in the attribute value is well-formed.  If we take the extract x_7.xml we see:    [[[  <a>           <foo     xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"     xmlns:eg="http://example.org/"     xmlns:q="http://example.org/q"     bar="q:name"/>       </a>  ]]]    and the "q" namespace is still around.    But the rule of ignoring invisible namespaces applies also to the q  namespace and so s_7.xml is:  [[[  <a>           <foo bar="q:name"/>       </a>  ]]]    Note that even if we use a_8.xml where the namespace is only declared on the  xml literal it still is "invisible" by the definition used.  a_8.xml  [[[  <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"     xmlns:eg="http://example.org/"  >     <rdf:Description>       <eg:a rdf:parseType="Literal">           <foo bar="q:name" xmlns:q="http://example.org/q"/>       </eg:a>     </rdf:Description>  </rdf:RDF>  ]]]  still shows the following visible part s_8.xml  (same as s_7.xml)  [[[  <a>           <foo bar="q:name"/>       </a>  ]]]    This situation is envisaged by exclusive canonicalization and they have  three solutions, all clunky:  [[[  + the XML must be modified so that use of the namespace prefix involved is  visible or    + the namespace declarations must appear and be bound to the same values in  every context in which the XML will be interpreted or    + the prefixes for such namespaces must appear in the InclusiveNamespaces  PrefixList a special parameter to list the unusual namespace prefixes which  are needed despite being invisible.  ]]]    The first one means getting the document author to add q:ignoreMe="please"  as an attribute to the element and hoping that it doesn't cause problems.    The second one would work for a small set of well-known namespace prefixes.    The third one is the only general purpose solution.    4: InclusiveNameSpaces & Attribute Value "Literal"  ==================================================    Within RDF/XML unfortunately, the natural way to list these unusual  namespace prefixes would be to use additional xmlns declaration. This  doesn't work if we wish to be XSLT-safe. XSLT systematically ignores such  declarations which repeat something that is already in scope. A good example  of a likely case is xmlns:xsd.  xsd is a prefix that is likely to be defined  at the top level, and may occur in a qname in an attribute value in an xml  literal in RDF!    We could list these unusual namespaces using an additional attribute e.g.  rdfns:xsd ....    This suffers from being fairly not backwardly compatible.    Oh dear, what we could do is decide to add these unusual namespaces after  the word Literal within the parseType. e.g.    a_9.xml  [[[  <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"     xmlns:eg="http://example.org/"     xmlns:q="http://example.org/q"  >     <rdf:Description>       <eg:a rdf:parseType="Literal q">           <foo bar="q:name"/>       </eg:a>     </rdf:Description>  </rdf:RDF>  ]]]    This would identify q as a namespace prefix to be treated unusually, i.e. as  always visisble on any element in which it is in scope.  Thus the xml literal is (the hand-written x_9.xml)  [[[  <a>           <foo xmlns:q="http://example.org/q"           bar="q:name"/>       </a>  ]]]      So there we have it.  We can prevent namespace pollution using the concept of visible utilization.  We can allow the unusual namespace use (e.g. qnames as attribute values) by  listing the unusual namespaces on the parseType value.  This is XSLT safe.  For greater precision, particularly for defining equality, we can specifiy  the use of XML canonicalization.      5: Comments  ===========    This message is based around one extreme of the solution space. We try and  fully specifiy what an xml literal is, and we try and get it right. This  will give maximum interoperability, at the cost of difficulty for  implementors.    As such I support Eric's remarks:  "I strongly vote in favor of  preserving comments.  I have a knee-jerk reaction to deleting any  information, and I believe this is what would be expected by content  produces that take time to include comments."      Thus example a_10 is different from a_1    a_10.xml  [[[  <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"     xmlns:eg="http://example.org/">     <rdf:Description>       <eg:a rdf:parseType="Literal"><!--    this comment is part of the literal -->           <foo/>       </eg:a>     </rdf:Description>  </rdf:RDF>  ]]]    the literal is extracted as s_10.xml  [[[  <a><!--    this comment is part of the literal -->           <foo/>       </a>  ]]]        6: A Proposal  =============    This proposal is based on maximally specifying the behaviour to minimize  interoperability problems, at the expense of requiring work from  implementors.    There is the assumption that the WG wishes to address xml literals that:  - use namespaces  - use namespaces within attribute values    Propose that:   - rdf:parseType="Literal" is replaced by rdf:parseType=literal     where literal is a list of names starting with the name "Literal"   - the value of such literal is the xml literal with string component given  by the exclusive canonicalization of the element content.   - that the c14n used includes comments   - that the c14n used uses the second and subsequent names from the value of  the rdf:parseType attribute as the InclusiveNameSpace Prefix list parameter  to the exclusive c14n algorithm.   - equality between the string components of xml literals is given by binary  equality   - close the xml literal issues.    Moreover, I could be actioned to draft an appendix to the syntax doc showing  how minimal RDF implementations that:  - do not need equality  - (and/or) can assume a complete set of namespaces for xml literals#    can be implemented satisfactorily without use of a c14n module.        7: What's the other path?  =========================    If the above proposal looks too heavy, I would suggest dropping qnames in  attribute values from the level of ambition, and merely trying to not  prevent implementations from treating unusual namespaces unusually. We would  then stick with "Literal" and "Resource" as the only two values of  parseType. Vagueness is possible about precisely what string is produced. A  more limited interoperablity could be achieved by concentrating the spec on  the equaity of literals.    I am happy to produce a second proposal based around that path.        Jeremy                                      application/x-zip-compressed attachment: literal.zip          

      (Another resend - I've had some problems)    Dave:  > >   * Provides only one way to encoded the literal-structures  > >     and so in that sense is canonical.  Graham:  > Also good - simple-minded applications may still do string  > comparison, right?      Hmmm, ....    we still have to decide that, ....    Dave:  >   xml("<b>foo</b>")              XML content, no language  what about xml("<b >foo</b>") is this:  a) not legal ntriple  b) legal but different from xml("<b>foo</b>") (and not representable in  RDF/XML?)  c) legal and the same as xml("<b>foo</b>")      Personally I prefer (c), but I think it is better for the group to not make  this decision until after we have completed the xml literal issues.    For our test cases I think we can choose appropriate canonical strings, so  this needn't slow us down at all.    Jeremy        

        Nick Gibbins wrote:    > Jeremy Carroll wrote:  >   >   >>The following came up on Jena-dev, with the refrain "that sounds like a  >>job for best practices" ... (not exactly)  >>  >>[[  >>given an arbitrary source of semantic  >>web data on the 'net, what *is* the best practice for determining which  >>semantic-web language and encoding is being used?  >>]]  >>(e.g. use OWL Full or DL or RDFS semantics)  >   >   > I'm not sure if this counts as best practice, but we use a simulated  > stochastic process to determine which Semantic Web language is being used  > by a particular file. You can see a demo of our technique at:  >   > http://triplestore.aktors.org/demo/OwlBall/  >     I think that qualifies under the "sorting out the mess that we've made"    Isn't  http://www.w3.org/2002/07/owl  intended as an RDFS file, not OWL Full?  (The semantics differ ...)    It made me laugh though.    Jeremy        

        >  > then there is no suggestion that the process has to generate the infinity  > of values, only that it needs to be able tell when two lexical  > forms it is  > given denote the same value.    Hence my proposal that we do not approve any test cases involving a typed  literal on the RHS which is not in canonical form.    Jeremy        

              containers.html        text/html attachment: containers.html          

        Summary: No API changes etc are needed for syntactic RDF manipulation for  semantic untidiness.    Jan:  >  > However, while it's not overly onerous to implement in every case  > (although it might be in many implementations), the resulting API was an  > absolute fag to code to; small experiments quickly descended into  > graph-grovelling.  >    I am finding the API and syntactic discussions very hard to understand.    I am seeing it differently from many of the other implementors.  The decision we made was about semantics not syntax, so why do we need to  make the syntax more difficult.    I'll try and explain how I see it with a test case:    <rdf:Description>    <eg:a>10</eg:a>    <eg:b>10</eg:b>    <eg:c>10</eg:c>  </rdf:Description>    There are three literals in the XML here, "10" "10" and "10".  Logically there seem to be five possibilities:  (A)  all three map to one node.  (B,C,D) the three literals in the XML map to two nodes (three different  choices of the odd one out)  (E) the three literals in the XML map to three different nodes.    I do not believe that there has been anyone who has advocated the *two node*  options (B,C,D) here.  I believe that with appropriate range constraints the untidy semantic  decision may be understood as enabling say the first two to have the same  value and the third to have a different value; but that is at the semantic  level not the syntactic level.    I have understood that there is no enthusiasm for my proposed tidy syntax  with untidy semantics. This rules out the first option (A).  Thus we are left with option (C).    Jan:  > Incidentally, the test cases are going to be somewhat delayed since we  > no longer have any way of comparing ntriples-expressed graphs for  > equality, so parser tests are (for the moment, at least) impossible to  > automate.    Thus the ntriples (with qnames) for this is unambiguously:    _:b eg:a "10".  _:b eg:b "10".  _:b eg:c "10".    And the two documents represent the same graph using exactly the same code  as we have being running for over a year now.    We may need minor changes to the documentation:    e.g.  [[    equals(RDFGraph a,RDFGraph b)    Graph a is isomorphic to Graph b as defined in the first RDF Concepts and  Abstract Data Model WD.  ]]  changes to  [[    equals(RDFGraph a,RDFGraph b)    Graph a is isomorphic to Graph b as defined in the second RDF Concepts and  Abstract Data Model WD.  ]]  but no code changes.    Moreover, we have not seen anyone wishing to express the B,C,or D options in  RDF/XML and so there is no need to put these options into the abstract  syntax. Hence my proposal to restrict untyped literals in the abstract  syntax to occurring in precisely one triple, and committing the abstract  syntax to option E.    So in terms of API changes, some are needed, but these are for support of  datatyping and semantics in general, not for syntactic changes.    e.g.    Add methods:    sameValueAs()    sameLabelAs()  to Literals.    Modify documentation of equals on Literal      equals(Literal a, Literal b)    Reports true if the two literal nodes have the same label.    Triples too, then have syntactic equality and semantic equality  (sameValueAs). I do not believe that we have yet resolved the issue of  whether two syntactically identical triples (with Literal objects) can have  different semantics.    The test case is the dc example:    <eg:Document rdf:ID="doc">    <dc:Creator>J. Smith</dc:Creator>    <dc:Creator>J. Smith</dc:Creator>  </eg:Document>    My understanding is that this only ever produced one triple, and so I would  want it to still produce one triple, which restricts the Literal 2 Value  mapping to depend on the literal, property and subject of the triple and  nothing else.    (Contrast with)  <eg:Document rdf:ID="doc">    <dc:Creator eg:name="J. Smith"/>    <dc:Creator eg:name="J. Smith"/>  </eg:Document>    which produces two triples but is entailed by and entails the one triple  case;  or with    <eg:Document rdf:ID="doc">    <dc:Creator eg:name="J. Smith" eg:sex="Male"/>    <dc:Creator eg:name="J. Smith" eg:sex="Female"/>  </eg:Document>    which finally has a document with two authors.      Jan:  >  > PS. On the untidyness of literals: I'm still not certain why untidy  > literals are tagged with what PS calls "system IDs" as opposed to  > bnodes, the space of which may intersect with non-literal-labelling  > bnodes.    The decision on Friday was about the semantics (of RDF/XML). I think the  space of how we get those semantics is still open; we could do the sort of a  literal is a bnode and a triple approach that Pat suggested in  simpledatatypes2. (Occam-slashed datatypes)    http://www.coginst.uwf.edu/users/phayes/simpledatatype2.html    Or alternatively by use of tidy syntax and tidy semantics at the abstract  level and a simple transform to add the bnode as we read the RDF/XML (from  my ...)    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Jan/0369.html  [[[  Match:    ?x  ?y ?z    where ?y != rdf:value and          ?z a literal node      replace with    ?x ?y NewNode    NewNode rdf:value ?z      where NewNode is a newly minted bNode.    For example:    <a> <foo> "ss" .    is transformed to    <a> <foo> _:b.  _:b <rdf:value> "ss".  ]]]      Jeremy        

          > rdfms-literal-is-xml-structure :  > A literal containing XML markup is not a simple string, but is an XML  structure.    > This issue was put on hold pending the outcome of the datatypes  discussion.      Again before this was on hold I suggested using XML Canonicalization.    From:    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Sep/0378.html    [[[  [36]  + MAY have their Unicode string component as given by the    Unicode string of the XML Canonicalization of the document    subset consisting of the element content. See XML    Canonicalization section 2.4.    http://www.w3.org/TR/2001/REC-xml-c14n-20010315#DocSubsets    The XML Canonicalization specifies a UTF-8 string, the    RDF Literal is the encoded Unicode string.    Such a canonicalization MAY or MAY NOT include comments.      [50]  For maximum interoperability RDF processors are RECOMMENDED  to use XML canonicalization without comments as the string  in the RDF Literal formed by the rdf:parseType="Literal"  property element production.  ]]]    I would now modify this a bit.    1: Use the latest canonicalization spec.    Exclusive XML Canonicalization    http://www.w3.org/TR/2002/CR-xml-exc-c14n-20020212    see particularly:    http://www.w3.org/TR/2002/CR-xml-exc-c14n-20020212#sec-Specification         This has a parameter the InclusiveNamespaces PrefixList  http://www.w3.org/TR/2002/CR-xml-exc-c14n-20020212#def-InclusiveNamespaces-P  refixList     which should, for RDF/XML processing, generally be empty.      2: I would try to phrase it so that RDF/XML applications may return any  representation that can be transformed into the above "canonical"  representation; without requiring that conformant RDF processors actually do  the canonicalization.        e.g.      "Literals arising from rdf:parseType="Literal" correspond to an XML  structure and MAY be represented as a canonical XML string using Exclusive  XML Canonicalization. Two such literals are equal whenever their Exclusive  XML Canonicalizations are equal."      Thus RDF processors that want to worry about equality of literals need to do  the works, whereas the DPH who isn't worried is provided with a semantics  for rdf:parseType="Literal" in terms of the abstract graph syntax  (it is  the canonical form as a representation of an XML structure), but the DPH has  no obligation to actually canonicalize.        Jeremy        

      > RDF C14N XML Literal Equality  > =============================  > Should C14N be used to describe the processing of  > rdf:parseType="Literal" or  > only in the definition of XML Literal equality.      This is where I start trying to be clever, perhaps too clever.    The obvious way of how the RDF specs should use the C14N spec is to say that  the literal delivered by the rdf:parseType="Literal" production is  canonicalized using the C14N method.    A different way is to not say that, but to say that two xml literals are  compared by comparing their canonicalizations.      In more detail ....    C14N as part of parsing  =======================    Add text to appropriate specs in appropriate places like:  [[[  An XML Literal in RDF consists of an optional language tag paired with a  unicode string that is a well-balanced XML fragment, without use of entity  reference except the predefined entities, and in which all visible  namespaces are declared.    In the literal production  http://ilrt.org/discovery/2001/07/rdf-syntax-grammar/#literal  the string value of the XML Literal is found by using the canonicalization  algorithm of C14N (with/without) comments.    Two XML Literals are equal if the language tags are either both absent or  equal (ignoring case) and if the unicode strings are equal.    NOTE: any XML Literal that does not canonicalize to itself in some XML  context cannot be serialized in an RDF/XML document.  ]]]      C14N as part of equality  ========================    Add text to appropriate specs in appropriate places like:  [[[  An XML Literal in RDF consists of an optional language tag paired with a  unicode string that is a well-balanced XML fragment, without use of entity  reference except the predefined entities, and in which all visible  namespaces are declared.    In the literal production  http://ilrt.org/discovery/2001/07/rdf-syntax-grammar/#literal  a possible string value of the XML Literal can be found by modifying the  string as in the input file, to ensure that all (non-predefined) entity  references have been expanded, and that any namespace declarations that are  visibly used are present in the string value. Any other equal string  representation is permitted. Any other representation from which the  canonical string representation can be generated is permitted.    Two XML Literals are equal if the language tags are either both absent or  equal (ignoring case) and if the unicode strings canonicalize to the same  string when put into the following XML context:    <foo><!-- Insert Here --></foo>    NOTE: different RDF processors may treat the underdefined aspects of XML  Literals  differently. These include aspects that are not in XML Infoset and  (maybe) XML comments  and (maybe) non-visible XML namespaces.    NOTE: RDF processors may choose to use an alternative communication band to  transmit a different XML context in which XML Literals should be compared.  In particular, many metadata applications may choose to use a context:  <foo xmlns="http://www.w3.org/1999/xhtml"><!-- Insert Here --></foo>  ]]]      Looking at our example:      <rdf:Description    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"    xmlns:dc="http://purl.org/metadata/dublin_core#"    xmlns="http://www.w3.org/1999/xhtml"    rdf:about="http://example.org/papers/paper1">    <dc:Title rdf:parseType="Literal"><!-- Relevant text start. -->      Foo<em>bar</em>    <!-- Relevant text end. --></dc:Title>  </rdf:Description>    the former approach (using C14N during parsing):  - requires all RDF parsers to implement C14N  - does not require graph matchers to implement C14N  - specifies precisely which string an RDF parser must produce.  - no current RDF parser will comply  - maximises the ease of interoperability between different RDF processors    e.g. with comments, then we must retain the comment strings.      the latter approach (using C14N during equality)  - does not require RDF parser to implement C14N, but parser writers must  have some awareness of the issues  - does require RDF graph matcher implementors to implement C14N  - is explicitly vague about what string an RDF parser produces  - does address the issues on our issue list  - blesses at least some current implementations (more or less) (ARP and CARA  I think - although ARP does not do processing instructions, I don't know  about CARA).  - still leaves some interoperability questions    e.g using exclusive without comments, then implementations that retain the  comments and all the namespace will nevertheless be conformant, as long as  the equality algorithm (if any) strips the comments and the non-visibly used  namespaces.    I note that nearly all RDF implementations provide RDF/XML input, not that  many provide equality.        

          (Resend - forgot I18N first time)        The main planks of Pat's text from    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2003Jul/0452    seemed to get support at the RDF Core WG telecon on Friday, I was actioned  to move the conversation forward, and ensure that Martin and I18N were in on  it.  My understanding is that the main goal was to avoid any possibility of  confusing XMLLiteral with xsd:hexBinary as in Martin's test case.    I also am trying to adequately address Patrick's concerns while changing  Pat's text as little as possible.    Brian used the term "XML fragment" at the telecon, I am however sticking  with Pat's "XML value" because of the existence of    http://www.w3.org/TR/xml-fragment    which makes Brian's preferred term misleading.  I would be happy to consider other words for XML value.    For completeness I also include stuff on the lexical space, since there was  some concern that the wording is not about Unicde strings ... and the word  "corresponding" ...    I have numbered the notes for the sake of this e-mail, further discussion  below.    Patrick - please indicate whether the last two notes (2,3) adequately  address your concerns. (3) ended up perhaps more geared towards some of  Martin's concerns.    I ended up unclear as to whether note 2 was wanted by the WG or not.    [[  The lexical space    is the set of all strings which:    + are well-balanced, self-contained XML data [XML];    + correspond  under [UTF-8] encoding to exclusive Canonical      XML (with comments, with empty InclusiveNamespaces      PrefixList ) [XML-XC14N];    + when embedded between an arbitrary XML start tag and an end tag      correspond to a document conforming to XML Namespaces [XML-NS]      The value space is a set of entities, called XML values, which is:    + disjoint from the lexical space    + disjoint from the value space of any XML schema datatype [XML-SCHEMA2]    + disjoint from the set of Unicode character strings [Unicode]    + in 1:1 correspondence with the lexical space.        The lexical-to-value mapping     is a one-one mapping from the lexical space onto the value space,     i.e. it is both injective and surjective.        Note (1): Not all lexical forms of this datatype are compliant with XML 1.1  [XML 1.1]. If compliance with XML 1.1 is desired, then only those that are  fully normalized according to XML 1.1 should be used.    Note (2): XML values can be thought of as the [XML Infoset] or  the [XPath] nodeset corresponding to the lexical form, with an appropriate  equality function.    Note (3): RDF applications may use additional equivalence relations, such as  that which relates an xsd:string with an rdf:XMLLiteral corresponding to a  single text node of the same string.    ]]      I seem to recall concern about putting too much into notes. Either the stuff  is sufficiently important to go into the design, or it isn't.    This may be sufficient to kill notes (2) and (3). I am reluctant to drop  note (1) since the RDF specs have largely followed charmod on NFC which puts  us into a somewhat anomolous position between XML 1.0 and XML 1.1 ...    If the notes add clarity then it is probably best to keep them.        

        > RDF XML Canonicalization Intro  > ==============================  > Intended for the RDF group, summarising C14N and XML subsets.  >    There are two XML Canonicalization specifications.    http://www.w3.org/TR/xml-c14n    and    http://www.w3.org/TR/xml-exc-c14n      These are produced by the XML Signature working group who wish to make it  possible to provide digital signatures for XML documents and XML document  subsets.    One solution would be to sign just the preprocessed document, but that would  mean that documents that are identical as XML would have different  signatures. XML Infoset defines a minimum set of things that may differ  between identical XML documents, including the character encoding, white  space in various place, attribute order, empty element tags vs a start tag  followed by an end tag etc.    The C14N route is based around first turning any XML document or document  subset into its canonical form, (which is the same for equivalent documents)  and then signing that.      Moreover, the XML C14N work, decided that character and entity references  would also be subject to canonicalization, and their use not be regarded as  part of the document to be signed. In contrast, namespace prefixes, which  are also in infoset, were determined to be part of the document, and  namespace prefix rewriting (i.e. the process of renaming namespace prefixes)  is *not* part of canonicalizing.    So two documents that:  - have the same infoset  - or differ only in their use of entity and character references    canonicalize the same.    Key aspects of canonicalization are given in the short section  http://www.w3.org/TR/xml-c14n#Terminology  e.g. "Empty elements are converted to start-end tag pairs"      C14N addresses document subsets both within the main spec at:  http://www.w3.org/TR/xml-c14n#DocSubsets    and within the exclusive spec (which only addresses document subsets).    It should be noted that within C14N document subsets are not assumed to be  contiguous.    The two C14N specs differ in the exact treatment given to namespaces.    C14N can be used to address the parseType="Literal" problem because:  - it allows us to clarify that two RDF/XML files that only differ in the  exact nature of XML in an xml literal, but whose infosets are the same, are  in fact the same.  - it does specify (a number of alternative ways) how to address the  namespace issue.  - it does provide an answer to what is an XML document subset, in that it  tells us if two such subsets are the same.      However, it does leave a number of things to be decided.    1: The exact treatment of namespaces (whether to use exclusive or inclusive  canonicalization).  2: The treatment of XML comments  3: In precisely what way we the RDF specs depend on the XML C14N specs.    There are also some limitiations with C14N identified at:  http://www.w3.org/TR/xml-c14n#Limitations    Moreover the exclusive form has additional limitations, to be described  later.    Jeremy        

            Dan Brickley wrote:    > Just to de-lurk, yes this all makes sense. One technique that I believe   > to be deployable (even if a pragmatic hack) is PGP signing RDF files.  > For eg see http://usefulinc.com/foaf/signingFoafFiles  >   > PGP only assures that the file hasn't been changed since the signer   > interacted with it, doesn't assure that the signer asserts it. My   > working guess is that, if the doc itself claims that the signer is its   > creator, that is enough to bootstrap the claim that the signer asserts  > the triples encoded in the rdf/xml. Potentially tenuous but I can't  > think of how else to roll this stuff out...  >   > Dan  >     My guess is that with only a little bit of common practice to that effect,   that this would stand up in a court of law. A digital signature is a pretty   heavy duty device and is already understood as the analog of a written   signature - and if the RDF stacks up as saying affirmed by Jeremy and I   have digitally signed it as Jeremy, I think I would have a hard time trying   to repudiate it.    Jeremy (not digitally signed, not affirmed, take it or leave it!)        

      Jeremy:  > [where] the model theory stops there is an implicit and  > ill-articulated extended conceptual model    Patrick:  >  [the conceptual model?] it's meant to  > be explicit    OK. I withdraw the venom of my attack on the conceptual model, it's work in  progress. I (at least) have found your point of view clear and consistent -  although I haven't seen that as the WG's point of view; the earlier messages  in this thread seemed to want to emphasise the stringiness of "25" rather  than it's integer-ness.    Jeremy:  > But the [non-monotonicty]  > argument still stands as far as the conceptual model goes.    Patrick:  > Neither level is non-monotonic, and the datatyping level only clarifies  > but does not change the knowledge at the lower idiom level, so the  > transition between levels also is not non-monotonic.    This seems close to my discussion about non-monotonicity about containers,  so I don't think I will pursue the difference between the levels too much -  except that there is an unnecessarily broad gap. E.g. the TDL model theory  was much closer to the pair of a datatype and a string found in the  conceptual model. The breadth of this gap fails (IMO) our principle charter  goal of clarity.    As for non-monotonicity the datatyping conceptual layer that we are  discussing is non-monotonic in its own right.    e.g.    <Jane> <age> "25" .    delivers the unicode string "25", i.e. <xsd:string,"25">.    <film> <title> "25" .    similarly delivers  <xsd:string,"25">.    At this datatyping conceptual level    <Jane> <age> "25" .  <film> <title> "25" .    allows us to conclude that Jane's age and the film's title are the same.    Then we add the range constraint on <title>    <Jane> <age> "25" .  <film> <title> "25" .  <title> <range> <xsd:string> .    I take it that the range constraint changes nothing, we are still having the  value  <xsd:string,"25"> delivered in both cases, and so we are still concluding  that Jane's age and the film's title are the same.    Now we add the range constraint on <age>    <Jane> <age> "25" .  <film> <title> "25" .  <title> <range> <xsd:string> .  <age> <range> <xsd:integer> .    We now have the film's title delivered as <xsd:string,"25"> the woman's age  delivered as <xsd:integer,"25"> and they are different.  Hence we see defeasible reasoning: in the light of new information we revise  our knowledge that Jane's age is <xsd:string,"25">, which in turn causes us  to revise our conclusion that Jane's age and the film's title are the same.    This is non-mononotonic, and the WG cannot escape that by simply saying that  it is not in the MT. The only escape route is to acknowledge that in the  absence of type information, the datatype is unknown (e.g. xsd:anyType or  maybe xsd:anySimpleType). If we stay aware that    <xsd:anyType,"25"> != <xsd:anyType,"25">  because anyType does define a mapping, then the problem begins to disappear.    Unfortunately this is bringing untidiness back into the datatyping layer. We  now are reading    <Jane> <age> "25" .    not as 'Jane's age is "25"' but as 'Jane's age can be written as "25"'. That  is rather than having a 'tidy' reading of the triple, we are having an  'untidy' reading.    If we are going to allow untidiness anywhere, it seems to me to be more  consistent and less of a intellectual somersault to allow untidiness at the  lower levels of the analysis (such as in the syntactic graph, or perhaps  only in the first level of interpretation in the model theory) rather than  sneak it in at the last moment in the final less formal layer.    I am sorry that my critique seems to jump all over the place. Fundamentally  the decision by the WG for tidiness was critically wrong. At the time, I  abstained since it felt that we were going to get a samll fudge where we had  syntactic tidiness but untidiness from there on.    As is, now any place where I attack any of the consequences of that decision  I am told that the problem is fixed elsewhere - but IMO the complete  end-to-end picture does not fix the problem.    Fixing the tidiness problem in the datatyping layer is firstly not in the  current proposal, secondly would need to be explicit and examples showing  how these critically conflict with the MT interpretation should be given,  and thirdly it is unnecessarily complicated.    The simplest fix is to allow untidy graphs (in the graph syntax).    The next simplest fix is Pat's simpleDatatypes2, which is a very elegant  fudge.    The next simplest fix is to allow an untidy interpretation of tidy graphs as  the first step in the model theory ('Jane's age can be written as "25"').    Jeremy        

          By namespaces we meant the binding of rdf to a uri prefix.    This is not just a syntax issue since it would change all the documents.    The expected content of section 3.1 is something like:    [[[    RDF uses the following URI prefixes, which correspond to namespaces in the  RDF/XML serialization:      rdf  http://www.w3.org/....#    rdfs http://www.w3.org/....#      NOTE: The RDF namespace prefix is unchanged since RDF Model & Syntax. We  actively seek feedback ...    ]]]    Jeremy    -----Original Message-----  From: w3c-rdfcore-wg-request@w3.org  [mailto:w3c-rdfcore-wg-request@w3.org]On Behalf Of Patrick Stickler  Sent: 24 June 2002 10:10  Subject: Re: Outline for new RDF document        On 2002-06-21 18:31, "ext Graham Klyne" <GK@NineByNine.org> wrote:    >  > A first cut (dated 21-June) of the document is at:  >  >  http://www.ninebynine.org/wip/RDF-basics/Current/Overview.htm  >  > This version has some textual content, but that is under active review,  and  > the document is being offered at this time mainly for consideration of the  > outline structure.    In general, looks good. One comment:    I think that section 3.1 Namespaces should be left out, and the  only place where namespaces are mentioned is the Syntax spec,  as that is the only context where they are relevant.    Also, in the sections that list the RDF vocabulary, we should  include full URIs and not qnames.    Cheers,    Patrick    --    Patrick Stickler              Phone: +358 50 483 9453  Senior Research Scientist     Fax:   +358 7180 35409  Nokia Research Center         Email: patrick.stickler@nokia.com        

          This is OK, but might not be what you want.  e.g. normal XML rules would suggest that in addition    <xmlnum     >one</xmlnum>  --> 1    (Whitespace differs).    This could be thrown in the lexical-to-value mapping, but we do not have an     extensible mechanism for rdf:XMLLiteral.  There might be a postponed issue; and one could experiment with       <rdf:Description>       <eg:prop rdf:datatype="⪚mynum" rdf:parseType="Literal">          <xmlnum          >one</xmlnum>       </eg:prop>     </rdf:Description>    but to do so would not conform with the WDs.    Jeremy      pat hayes wrote:    >   > Is it legal to include XML markup inside non-XMLLiteral literal strings?   > For example, suppose I wanted to define a datatype called ex:XMLnumber   > whose lexical space was all strings of the form  >   > <xmlnum>English-number-phrase</xmlnum>  >   > and whose L2V mapping looked like  >   > <xmlnum>one</xmlnum>  --> 1  > <xmlnum>two</xmlnum>  --> 2  > ...  > <xmlnum>three hundred and ninety seven</xmlnum>  --> 397  > ....  >   > and write literals like  >   > "<xmlnum>three hundred and ninety seven</xmlnum>"^^ex:XMLnumber  >   > to refer to 397, would that be legal RDF? There are no semantic reasons   > to exclude it.  >   > Pat  >   > PS> This information has been requested by Roland and I don't know the   > answer.        

          Hi,    here are the test cases.    The last three are a new format of test case.      The orignal example  ====================  1. The orig example (DaveB)  2. The orig example flattened (DaveB)  3. modified version of 1       (clarifying what happens when no rdf:ID)  4. modified version of 1        (clarifying that non-nested bagID has same semantics)    Dave: I have put your name on 1 & 2 and both our names on 3 & 4.  Is this OK?    Systematic exercise of cases  ============================  5. rdf:Description  6. typed node  7. empty element with rdf:resource  8. empty element with rdf:ID  9. empty element with neither    (note: the version of ARP I have on this laptop failed 7. but not 8. or 9.)    Two prop attrs  ==============    10. rdf:Description + two prop attrs  11. typed node + two propattrs  12. empty element + two prop attrs      Test cases 10, 11 and 12 each have two possible answers.  To pass the test case an RDF/XML to N-triple converter needs to get one or  the other.            application/x-zip-compressed attachment: rdfms-nested-bagIDs.zip          

      brian:  > I think we can close this with a clear  conscience.    I would be grateful if Mike and Jos checked my DAML+OIL first.    Jeremy        

        This message addresses the main criticisms of TDL.  I will follow up with more detail concerning query, Brian's B3 & B4.    The proponents of S furnish us with an implementation of S, and a model  theory for S (which includes, naturally self-entailment).    I now can create an implementation of TDL in the following fashion.    As I read in any RDF graph I apply the following syntactic transformation.    Match:    ?x  ?y ?z    where ?y != rdf:value and          ?z a literal node      replace with    ?x ?y NewNode    NewNode rdf:value ?z      where NewNode is a newly minted bNode.    For example:    <a> <foo> "ss" .    is transformed to    <a> <foo> _:b.  _:b <rdf:value> "ss".      We then use the S implementation and S model theory (idiom S-P is the only  idiom used).    Hence:    If S is implementable then so is TDL    The maximum overhead required for TDL is the same as that for S idiom A  and/or S idiom P.    All problems to do with entailment, query, implication, etc. are clarified  and addressed with this process (as long as they are clear and addressed  with S).    From an implementators point of view, it is clearly easier to implement the  syntactic transformation and S-P, than to implement S-A, S-B and S-P.    Graham, does this adequately address your concern about self-entailment?    [Small technical detail:    S-P uses a closed world assumption on data types, whereas TDL uses an open  world assumption. The two can be made equivalent by using S-P with at least  two incompatible types in its closed world  both having domain being the  complete set of unicode strings. Two such types are:    xsd:string = { < x, x > | for any unicode string x }  appendA    = { < x, x."A" > | for any unicode string, . being string  concatenation }    ]    Jeremy        

          I am sick now, we will see later.    Jeremy        

          > Can someone please provide me with a concrete counterexample of this, if  > it's not the case?    rdfs12a        

          > > Yes, but a URIref is an identifier with unambiguous  > > and globally consistent meaning. A bare literal,  > > without any explicit or implicit datatype denotation  > > is ambiguous,  >  > no it isn't, it's unambiguously meaning  > the *token* itself, always and everywhere  > there just is no other interpretion involved  >    Whilst I don't begrudge you three or four rounds in the ring with Patrick  (that I haven't been following), I find this somewhat exaggerated.    If we consider the classic example of <Jenny> <age> "10" . I take it, that  at some point, some piece of software might decide to read the "10" as a  number, and decide that Jenny is older than Bob, ( <Bob> <age> "3" . ) So as  far as I can see, somewhere there is some other interpretation. If there  really isn't any other possible interpretation we should perhaps deprecate  bare-literals all together. We could retain parseType="Literal" for carrying  fragments of XML documents which are to be interpreted as self denoting, but  most of the other usage of literals in RDF seems to have some implicit  referent other than the string.    Thus the choice seems to boil down to *where* is this mapping from "10"  (string) to 10 value made, and how is it licensed.    My understanding of the tidy position is that this mapping is made by the  application at its own initiative, and it is unlicensed, or licensed only by  private channel.  The untidy position is that the mapping can be made in response to a range  constraint.    Unfortunately the (only?) intuitive implementation of this depends on a  non-monotonic step: the thing that we used to regard as a string, we now  regard as a number. The monotonic way of looking at this, (the thing is  *untyped*, and hence distinct from an identical untyped thing) is not really  going to convince any but a handful of people (most of whom belong to this  WG).    Thus the untidy position ends up with RDF software that takes a  non-monotonic step; the tidy position ends up with RDF applications that  take (essentially the same) non-monotonic step.    Really using syntactic means to allocate datatype, and requiring all  Literals to be typed, would be preferable - but then that's a "I wouldn't  start from here" argument.    Jeremy        

          I've tried this morning to sketch another approach.    Like the LFG approach of last week this is declarative.  However it is XML based, presumably implementable in XSLT, and  compatible with the Infoset grammar rather than an EBNF grammar.    Again, this is intended as a discussion document, primarily for the  syntax subgroup.    Jeremy        text/html attachment: Transforming_RDF.html          

          Hi Pat,    I think you asked earlier whether there were any specific requests for   things to link to in the semantic doc.    I had two:    + definition of semantic extension  + definition of XSD entailment (Entailment with respect to xml schema   datatypes and rdf:XMLLiteral)    Jeremy        

          >    - Internationalization?        I propose that:    - The Unicode strings within RDF literals are required to be in NFC.  - We note that literals whose unicode strings start with a combining  character may not be serializable in an XML document that conforms with  forthcoming Character Model Recommendations.  - We include a test case of such a literal as legal, to be reviewed if  Charmod reaches rec before we do.        

        Brian:  > I guess this sort of test case does not fit the "here's the RDF/XML, this  > is what it means in n-triples" pattern very well    In testing ARP I work through a zip file finding all pairs of RDF and NT  and check they are the same.   I noticed that this test case still supports that.    I think it is important that someone wishing to run automated tests off  the test cases should be able to, without having to code in lots of  specific filenames.    I note that the zip file version is more useful than the web version for  automated testing, since it is fairly hard to automatically work through  all the files in a web directory.    Jeremy        

          > rdfms-not-id-and-resource-attr:    > The propertyElt production 6.12 of the grammar does not  > allow both an ID attribute and a resource attribute to  > be specified (owner Dave Beckett)    > Dave has made a proposal in the syntax WD; awaiting counter  > proposal from Jeremy.        My counter proposal was made a while ago:     http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Jan/0018.html    i.e.    [[[        An rdf:ID attribute is permissable on all property elements and always  refers to the resource that is the reification of the triple corresponding  to that property element.    ]]]      The only issue seems to be whether this is a change or a clarification.  I don't care which.    Given that we are trying to make reification usable for provenance and to  force a "reification is intended for provenance" reading from M&S, I think  this is sensible.    With what I understand of the lack of uniformity in the other proposal  actually using the syntactic mechanism for reification becomes a  hyper-specialized activity.    Jeremy        

          Particulary Fran?ois and Martin    RDF Core considered and agreed this text below, contingent on I18N comment   ..., we also agreed to move to second last call.      Is this satisfactory? Or are there possible further edits that should be   made (without losing consensus)?    Jeremy        Jeremy Carroll wrote:    >   >   > We seem to have consensus on weakening MUST to SHOULD.  >   > Maybe we can remain silent about the areas we still disagree on. In   > general, the RDF specs do not specify behaviour on ill-formed input.  >   > I note that the only explanatory text offered anywhere is a pointer to   > charmod, so that implementors chosing to permit non-NFC, can only honour   > the RFC 2119 requrement to understand the full implications of not   > implementing SHOULDs by first reading CHARMOD.  >   >   >   > Possible edits:  >   > Syntax:  > (latest editors draft  > http://www.w3.org/2001/sw/RDFCore/TR/WD-rdf-syntax-grammar-20030117/  > )  >   > (IN order searching for "NFC" through the document - all these changes   > might benefit from further polish).  >   > change  > [[  > MUST be a Unicode[UNICODE] string in Normal Form C[NFC]  > ]]  > to  > [[  > MUST be a Unicode[UNICODE] string and SHOULD be in Normal Form C[NFC]  > ]]  >   > change  > [[  > MUST be in Normal Form C[NFC].  > ]]  > to  > [[  > SHOULD be in Normal Form C[NFC].  > ]]  >   > change  > [[  > This string x MUST be in Unicode[UNICODE] NFC Normal Form C[NFC]  > ]]  > to  > [[  > This Unicode[UNICODE] string x SHOULD be in NFC Normal Form C[NFC]  > ]]  >   > change  > [[  > a.string-value MUST be a Unicode[UNICODE] string in Normal Form C[NFC],  > ]]  > to  > [[  > a.string-value MUST be a Unicode[UNICODE] string and SHOULD be in Normal   > Form C[NFC],  > ]]  >   >   > In concepts  > (editors' draft)  > http://www.w3.org/2001/sw/RDFCore/TR/WD-rdf-concepts-20030117/  > change  > [[  > The string in both plain and typed literals is required to be in Unicode   > Normal Form C [NFC]. This requirement is motivated by [CHARMOD]   > particularly section 4 Early Uniform Normalization.  > ]]  > to  > [[  > The string in both plain and typed literals is recommended to be in   > Unicode Normal Form C [NFC]. This is motivated by [CHARMOD] particularly   > section 4 Early Uniform Normalization.  > ]]  >   > Section 5 datatypes  >   > change  > [[  > The lexical space of a datatype is a set of Unicode [UNICODE] strings in   > Normal Form C [NFC].  > ]]  > to  > [[  > The lexical space of a datatype is a set of Unicode [UNICODE] strings.  > ]]  >   > Section 5.1 XML Content within an RDF Graph  >   > change  > [[  > The lexical space  > is the set of all strings:  > - in Normal Form C [NFC];  > - which are well-balanced, self-contained XML content [XML];  > ]]  > to  > [[  > The lexical space  > is the set of all strings:  > - which are well-balanced, self-contained XML content [XML];  > ]]  >   >   > 6.5 RDF Literals  >   > change:  > [[  > All literals have a lexical form being a Unicode [UNICODE] string in   > Normal Form C [NFC].  > ]]  > to  > [[  > All literals have a lexical form being a Unicode [UNICODE] string, which   > SHOULD be in Normal Form C [NFC].  > ]]  >   >   >   >   >         

            Rich Salz wrote:      > And, by the way, shouldn't we all be using exc-c14n instead of c14n  > whenever possible?      Why?    (My analysis let the RDF group to make this decision [exc-c14n], but it   seemed to depend on aspects of our application. In particular the problem   of namespaces that are used but not so visibly so, seems to be a reasonable   argument for using c14n rather than exc-c14n).    Jeremy        

            Frank Manola wrote:      >   > I've already mentioned the issue of consistent references.  Also, I  > notice Concepts editors draft now has a CR format.  Etc.      If we wanted to go to CR format I would also need to attack the references ...    I just need the easy bit yesterday.    I have to close one thread on comments, will do that sometime today    Jeremy        

        Gasp, horror! maybe compromise is possible :)      >   > > 3. Requires four (4) URIs for each datatype rather than just one. How  > > can we ask every authority that has already defined datatypes and given  > > them URI identity to now go back and mint three more URIs so that RDF  > > can use them?! TDL has already shown that one URI is sufficient.  >   > S-A and S-P can live with a single URI. In [1], different URIs were  > introduced for clarity, so that a precise distinction can be made  > whether lexical spaces, value spaces, or mappings are used for typing in  > a given idiom.  >  >     (First sign of movement on either protagonist's part).    Jeremy        

          > Jeremy:  >   > maybe there are a few words that should added to the Concepts draft?  e.g.  >   > [[  > In publishing a statement with potentially significant legal or social   > consequences, one should take care to use vocabulary whose meaning is   > well-defined, stable and known to correspond to the intended meaning.    > For important documents, such as contracts, this may mean that use of   > third-party vocabulary is restricted to terms defined by legislature,   > recognized standards bodies or other reputable organizations.  Using   > terms from untrustworthy sources may have unintended consequences.  > ]]  >       ?? insert  [[  restricted to terms defined by legislature,  recognized standards bodies or  other reputable organizations,  *** or to terms with well-established social meaning. ***  ]]      Jeremy        

        > I can't think of a better way to insure   > that what people think RDF is (including both RDF/XML and Schema) is   > what's described in the Primer than to make all the normative specs   > "bare-bones normative" (and hence virtually unreadable).  The specs   > people can read tend to become "normative" by usage.    Very well-argued.     Jeremy        

            Christopher Welty wrote:    >   > I agree that we shouldn't be making or considering changes to OWL in   > this WG, however it is important to point out representational   > limitations of OWL and how (when possible) to work around them - agreed?  >       Yes agreed - however I would prioritise more basic problems in documenting   how to make good use of RDF and OWL.    Jeremy        

          I have completed the action from Friday to produce a new draft of concepts at:    http://www.w3.org/2001/sw/RDFCore/TR/WD-rdf-concepts-20030117/    in addition to the changes agreed on Friday, I changed the heading of   "Substantive Revisions" to "Non-Editorial Revisions".    This is because the definition I have worked to is that:    [[  Editorial changes are those which do not result in any change in the   meaning of an RDF document or the behaviour of an RDF application.  ]]    which is stricter than the criteria that Eric e-mailed out for the defn of   substantive.    Jeremy        

          >   > >Pat,  > >  > >don't we need RDFS closure rules that add range and domain constraints  > >e.g.  > >  > >aaa [rdfs:range] yyy  > >yyy [rdfs:subClassOf] zzz  > >  > >then add  > >  > >aaa [rdfs:range] zzz  > >  > >  > >and similarly for rdfs:domain.  >   > NO. That would be disastrous for the datatyping and in any case not   > make sense. Why do want them?  >   >     We don't *want* them, they are just true!  Or maybe I've been talking to Peter too much!    Any interpretation of any     > >aaa [rdfs:range] yyy  > >yyy [rdfs:subClassOf] zzz      is an interpretation of    > >aaa [rdfs:range] zzz      thus the closure rule holds.    (Not) Proof:    Ahh, it depends on rdfs:range not being in the domain of discourse.  neglecting that little factette and invalidating the proof ...    Whenever   iii aaa jjj .  then  jjj [rdf:type] yyy .  hence  jjj [rdf:type] zzz .    hence    aaa [rdfs:range] zzz .    ==    I smell danger.      Jeremy        

        Here is the beginnings of a doc - there is a 15 page limit, so I think we   should a) provisionally decide whether we wish to cover the topics indicated   b) flesh more of them out. I guess we need to be concise - e.g. the abstract   syntax section is not too short in my view. (We could cut the isomorphism   discussion ...)    I have tried to use many files, to enable independent working without too much   change control. I am going to try and get some of the work we have done on   trust and affirmation and pki and publishing written up today. Probably a   methodology of just announcing what you are working on will enable a   light-weight locking process. I am happy to co-ordinate merges.    Hmmm, doing the vocab summary soon might be a very useful thing - it's the   essence of the information model. Probably just doing that in e-mail is good   e.g.    Classes  rdfx:Graph  "An RDF graph, intensional semantics?"      Properties  rdfx:equivalentGraph - Dom: rdfx:Graph - Rng: rdfx:Graph  "The two graphs are equivalent as defined by RDF Concepts."  rdfx:subGraphOf - Dom: rdfx:Graph - Rng: rdfx:Graph  "The subject graph is equivalent to a subset of the object graph"      I am hoping the query language and provenance stuff is more or less covered by   work that Chris has already done, or from the TriX paper.    Once we have most of it in place we can guage whether we can fit more in, we   seem to have lots in the e-mail log, and/or whether we need to prune what   we've got.    Jeremy          application/x-tgz attachment: ng.tgz    application/pdf attachment: ng.pdf          

      >   > 11: Datatypes  > The only outstanding issue against datatypes at present (did I   > really say that?) is the whether we need rdfs:dlex.     Sound of distant coughing ... what happened to Jeremy's entailment?    Jeremy        

        NP    Take two directed graphs G and H    Construct an RDF Graph R as follows.    Let the nodes of R = V(G) U V(H) U { g, h, x }  (all distinct blank nodes)    Let the triples of R all have predicate rdf:value (which we will omit)    Let the triples of R be E(G) U E(H) U { <g, g'> | g' in V(G) }                        U { <h, h'> | h' in V(H) } U { <x, g>, <x, h> }    then if R is irredundant we have that H is not a subgraph of G.  The directed subgraph problem is NP complete, which forms the interesting   90% of a proof of NP complexity of RDF graph irredunancy.    Your approach neglects the long distance interactions involved in blank   node structures.    Jeremy      pat hayes wrote:    >> NO  >>  >> The problem of eliminating such blank nodes is plausibly NP complete.  >>  >> Certainly GI complete, i.e. exponential.  >   >   > Actually, I think its only cubic.  > for each bnode B  >     for each triple T containing B  >         if there is a triple instantiating T, remove T  >     loop  > loop  >   > But OK< pretend I never mentioned it.  >   > Pat  >   >   >> (See related work on irredunancy of conceptual graphs  >> [[[ Michel Chien et Marie-Laure Mugnier, Conceptual Graphs:   >> fundamental notions in Revue d'Intelligence Atificielle, Vol 5, no 4,   >> 1992, pp 365-406.  >> ]]  >> most applicable to RDFS though)  >>  >> Jeremy  >>  >>  >> pat hayes wrote:  >>  >>> While fixing a silly mistake in the MT document, I noticed the   >>> following. We require that RDF graphs contain no redundancies in the   >>> sense that the same triple cannot occur more than once in the graph.   >>> However, they can contain redundancies in the sense that a triple   >>> with a bnode in it can be duplicated with a different bnode, even   >>> though the resulting triples would look the same in a graph diagram.   >>> The resulting graph has no extra information in it, but this quirk   >>> allows an RDF graph to have infinitely many consequences. For   >>> example, a single triple  >>>  >>> a p b .  >>>  >>> has infinitely many consequences;  >>>  >>> _:x p b .  >>> a p _:y .  >>> _:z1 p _:z2 .  >>> _:z3 p _:z4 .  >>> -:z5 p _:z6 .  >>> ....  >>>  >>> where all these bnodes are distinct; see attached jpeg.  >>>  >>> My question is, does the WG feel that it might be worth ruling this   >>> out as a syntactic possibility? If this kind of bnode-duplication   >>> were ruled out, then the set of graphs simply entailed by any RDF   >>> graph would be finite.  That would generalize the   >>> no-duplicate-triples condition implicit in our definition of a graph   >>> as a set, to treat triples which 'look' the same when you erase the   >>> bnode labels as though they literally were the same.  >>>  >>> Pat  >>  >   >         

        Aaron:  >   > Ahh, I'd not been following recent syntax threads too carefully.  > Indeed the document[1] reads:  >     Dave:  > """  > rdfms-difference-between-ID-and-about  >   > What is the difference between using and ID attribute to  > 'create' a new resource and an about attribute to refer to it?  >   > Action: rdf:ID="attr" is an abbreviation for rdf:about="#attr"  > and the handling of rdf:ID has been[will be] updated to show  > this.  > """  >     Aaron:  > """  > Usage of an rdf:ID attribute to identify the subject of a  > description, is equivalent to usage of an rdf:about attribute  > with the the '#' character followed by the URI-encoded form of  > the content rdf:ID attribute.  > """    Dave's text is currently neutral vis-a-vis internationalized URI's.  Aaron's text takes a URI-ref to be precisely a US-ASCII URI ala RFC  2396.    I owe the group some work on internationalization, but currently am of  the opinion that we should allow internationalized URIs wherever we  allow uri-references; these being resolved into US-ASCII URIs ala RFC  2396 (as modified by RFC 2732) at the same time as relative URI's are  resolved, using the standard algorithm.    Jeremy        

          > The "pairing" model itself should absolutely be defined as part of  > the MT. It was only the idioms that would be left out of the MT. But  > perhaps the idioms also need to be in the MT, but modularly, as a  > layer on top of the pairing model, so we retain the insulation of  > the core data typing model from changes/evolution of idioms.      A subtly with the P approach is that there isn't just one type, there can be  any number of range constraints. These, in the logicians world, create a  single intersection type, but for the rest of us they look suspiciously  different from one type. Thus P (in some instances) doesn't follow the  elegant pair picture.    The primer level material on PD needs to suppress that complication. I think  viewing the pairing as something that gets discussed in the less formal  section, gets implemented in actual code but is  extended/side-stepped/ignored in the more formal section will probably be  OK.      Jeremy        

            >   > Fair enough.  >   > My view in a nutshell is that there *are* defining authorities, both  > for datatypes and for URI denotations, but they need not be the *same*  > authority for a given URI denoting a given datatype.  >   > And the text in question IMO says that they are the same authority.  >   > Patrick  >   >     *I* agree with that, but note the world did not.    Jeremy        

        > I think we can fairly safely assume that RDF implementations can  > determine  > character-level equivalence between XML literals.  But it will be  > problematic for some applications (think: DPH) if the ability to  > determine  > deeper levels of equivalence is required.  I'm not sure why we *need* any  > deeper level than character equivalence.  I think this falls into  > the same  > category as being able to detect entailments:  some true facts may be  > overlooked, but we don't end up concluding falsehoods.    I am feeling happier with XML Literals now they are a datatype.  Graham's discussion above shows that failing to do canonicalization is  merely one of the many forms of incomplete reasoning that a  cheap-and-cheerful rdf implementation will exhibit.    Jeremy        

          > >  > > No it doesn't entail at all.  > >  > > " 3 " is not an integer but "3" is. So the second graph is  > > not a consequence  > > of the first, because the whitespace makes a difference.  > >  > > (I frankly haven't a clue what the second graph means - I  > > promised Brian I  > > would read the semantics editors draft before the telecon, so  > > I might know  > > by then).  >  > Hmmm....  >  > This is an interesting entailment.  >  > I think the key question is whether XML Schema whitespace processing  > is part of the XML Schema specific interpretation of typed literals  > having XSD datatypes.  >  > You are saying that it is not. Is there anything from the XML Schema  > specs or the XML Schema WG that support that?  >  > IMO, it's really for the XML Schema folks to say whether "  3  "  > is or is not an acceptable lexical representation when interpreted  > in terms of the datatype xsd:int.  >  > It might be.  >  > My presumption was that it would be.  >  > If there is some clear evidence showing that my presumption is  > incorrect, I'd like to know it.      We might not be ready to close this one.    The XML Schema rec is clear (sort of like the RDF working drafts :) that  whitespace normalization is performed in part 1, but precisely which  processing is specified in part 2.    i.e. the processing chain is:    input-text => entity substitution => whitespace normalization => [[Lexical  Form]] => lexical-to-value mapping => value      If you look at  http://www.w3.org/TR/xmlschema-2/#decimal    for example, the defn of lexical space does not include the leading and  trailing blanks.    Whitespace normalization is specified in  http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#section-White-Space-Norm  alization-during-Validation    Jeremy        

          > >  > > This is the usual weekly call for agenda items.  Please can I  > have any by  > > noon uk time Thursday please.  > >  > > On my list of possibles I have:  > >  > >   o abstract syntax - I'd prefer a whole proposal rather than specific  > > questions  >  >    Sorry, I missed the deadline ...      I suggest an abstract syntax along the lines of:    An RDF Literal Node can be labelled with one of:    - an RDF String Literal (as now)  - an RDF XML Literal  (as now)  - a value from the value space of a datatype.    We simply note that an implementation that is unaware of a specific datatype  used in an RDF/XML document will need to store the datatype URI + lexical  form pair as a fall-back.    An RDF Graph contains precisely one triple for each Literal node in the  graph.    [As I have previously indicated this extreme syntactic untidiness is  practically indistinguishable from extreme tidiness, but leaves Pat more  room to wriggle.]    I will send another e-mail, replying to this to motivate the use of values  rather than Patrick's preference for pairs.    Jeremy        

        Thanks Aldo for your reply, thanks particularly for pointing me at this:       > 1) Datatype remapping of WordNet, in order to arrive at a preliminary   > namespace  (what are the classes, the individuals, the properties, and   > how many levels are currently collapsed in wordnets?).    which does seem to address many (possibly all) of my concerns.    If the WordNet TF has a first phase that completes this task, and succeeds   in making it useful (more useful than it being done outside this WG), by:    - successfully persuading say Princeton to use it to publish an OWL version   of WordNet  - successfully getting consensus from the other WordNet mappers that this   is a good point to start, so that they use the same schema and terminology   at this meta-level  - successfully persuade tool developers that this schema is worth having   some built-in support for    then I would be very happy. For my part, I would do my best to persuade my   colleagues that having some WordNet support in Jena, following the TF's   suggestions, would be valuable.    I think that first phase looks quite hard, you seem to see it as easy.   Technically you may well be right that it is addressed by:     > Namespace(rdf   = <http://www.w3.org/1999/02/22-rdf-syntax-ns#>)   > Namespace(xsd   = <http://www.w3.org/2001/XMLSchema#>)   > Namespace(rdfs  = <http://www.w3.org/2000/01/rdf-schema#>)   > Namespace(owl   = <http://www.w3.org/2002/07/owl#>)   > Namespace(a     = <http://www.w3.org/2004/03/WordNetSchema#>)   >   > Ontology( <http://212.34.219.175/WN_Schema.owl.rdf>   >   >  ObjectProperty(a:Hyperonym)   >  ObjectProperty(a:Hyponym   >   inverseOf(a:Hyperonym)   >   domain(a:Synset)   >   range(a:Synset))   >  ObjectProperty(a:Sense   >   domain(a:Word)   >   range(a:Synset))   >  ObjectProperty(a:Synonym Symmetric   >   domain(a:Word)   >   range(a:Word))   >   >  Class(a:Synset partial   >   restriction(a:Hyperonym someValuesFrom (a:Synset)))   >  Class(a:Word partial   >   restriction(a:Sense someValuesFrom (a:Synset)))   > )   >    however, the technical part is only the beginning of the task.  (I haven't reviewed this suggested ontology)    I did note two related confusions between our postings:  - WordNet or wordnets?     I see the main reason for having a wordnet task force is that there is   already a deployed and widely used resource that is appropriate and useful   for the Semantic Web; WordNet, in English, from princeton. This has   specific synsets that may or may not be "best" depending on your   application or linguistic needs; but it is *deployed* and used.    You seem to see the purpose of the task force to be about encouraging   better wordnets, and alternative synsets etc. that might be more useful as   an upper ontology (I am not an ontologist, sorry if I am misusing the term)  - methodology or triples?    You seem to see the key deliverables of the TF as methodological advice.   (How to build better wordnets) I see the key deliverables of the TF as   triples (here is some deployed knowledge that people have found useful,   here is that knowledge expressed in RDF/OWL)      Given that princeton are a key partner in the success of the first phase, I   would be nervous about us being too keen to denigrate what they have done.  Of course, any work on the scale of wordnet is not perfect, and will not be   ideally suited for any specific purpose, since it has to be a trade off   between different needs. But it exists. It is useful. An 'ontological'   argument about best practices is that a necessary part of being a best   practice is being deployed and used :)      Anyway, we seem to agree about what needs to be done first, and we don't   need to disagree about what comes next, until we get there, when both of us   will be older and wiser.  I would suggest a timeline that just concentrated on phase 1 would be more   realistic, but I'm not very fussed about that. I would like to see exit   criteria for phase 1, before the next phases you indicate get going.    e.g.    - agreement from princeton or someone else to make WordNet available using   the schema devised by the TF  - agreement from two or more software developers of Semantic Web tools to   add API support for the schema  - some simple examples (for the application and deployments TF?) of how to   use the schema for some particular tasks      A few more detailed points below, (I have snipped those bits of the message   to which I am not replying, maybe because my thoughts are indicated above)    Aldo Gangemi wrote:  > Granted that I agree on the need to use WordNet in a common format as   > soon as possible for SW applications (it's my first step in the   > guideline list), I'd rather discuss what are we committing to. Jeremy,   > do you think the TF should  build the standard WordNet for the SW? Or a   > "minor" or "preliminary" standard? I understand we have to provide best   > practices to use or build resources, not to create them directly.  >   Princeton have already built WordNet - it is not a standard nor is it   perfect, but it has that key characteristic of perfection: it exists.  I see our task here as about encouraging deployment of this resource in the   SW. I don't think this TF is about a '"minor" or "preliminary" standard' at   all, simply about helping SW users who wish to use primarily the Princeton   WordNet (but potentially other WordNets) with their SW data.        > On the other hand, if someone suggests that WordNet (*as is*) is a best   > practice for annotating the Web, this is patently misconceived,   I think that *currently* it could be argued that it is best practice, best   does not been best in some possible world but in the world as it actually   is. To demonstrate that it is 'patently misconceived' you have to describe   in detail something I could use now to annotate the Web that would be   'patently' better practice.      >   > Let me put some preliminary distinctions, then I will come to the   > individual issues.  >   > 1) WordNet is ambiguous in nature:  > - it is a network of words, but also a network of senses.  > - it contains relations between individuals (e.g. part-of), relations   > between concepts (e.g. antonymy), and relations between words (e.g.   > synonymy, POS mapping)  > - it contains both senses of concepts (classes), and senses of individuals  >   > 2) There exists a schema of WordNet as it is (as a relational database),   > but WordNet senses can be considered as a giant schema in itself to be   > exploited in SW applications.  >     Of course these points are important as qualifications on any implicit   endorsement we give to WordNet. I would also add that it has a further   highly significant limitation in that it is in (US) English. Thus   distinctions that are important in other cultures, such as that between   prosciutto crudo and prosciutto cotto, are not adequately reflected.        > This refers to the use of WordNet as a database. In other words, since   > WordNet is a database of matadata, you are suggesting to define a   > metaontology (in the past, these were called metamodels ...) of the   > primitives used for creating wordnets.  > Perfect, I agree with you (this has been a theme in many papers I have   > written!). I concede that I have not defined such a metaontology in OWL   > or RDF, and this can be the first goal for the TF.    Good, good, good - we agree on the key point.        > There exists also some reusable work made by ISLE (International   > Standards for Language Engineering) that you probably know.  >     No, sorry ...    jjc:  >> + some illustrative examples of use  >   >   > That's one point: use for what? if you want just triples encoding   > hyperonymy, synonymy, etc., the instances in your triples will actually   > represent concepts, individuals, or words time to time. Annotating web   > pages with that mess would be a nightmare ...  >   I'll send a simple example after lunch ... but we should have some clear   use cases for any work we do, otherwise why bother?      > I agree, but the differences are usually related to the synset network,   > rather than to the parts that are easily encodable in schemata like the   > one above.    Ahh that's interesting - so the issue in using WordNet is that anyone who   makes it available decides to change the synsets while they are about it.   That does not seem the right way to do things to me. A very basic best   practice for doing anything in software I think, is to  choose an   appropriate tool, and use it in the way it was intended as given, and   deviate as little as possible. So if I choose to code a program in Java  I   will write it differently, with different conventions and different   algorithms than if I choose to code in Prolog or C. Similarly if you don't   find the WordNet synsets fit your needs I would have thought a best   practice is not to use WordNet, but use something else.      >   >> When identifying the deliverables for this (or any) Task Force, we   >> should also identify the target audience, and possible use cases in   >> which that target audience may find the deliverables useful. It would   >> be good to have a clear idea from the target audience what they want,   >> so the work is based more on pull ("this is what you are asking for")   >> than push ("take this because the doctor says it will be good for you").  >   >   > Pull is different for someone that just wants some tag to put on a web   > page, and someone else that wants a clever coverage for her domain, or   > even for someone that wants to make automatic translation on the Web.    Pull is whatever pull there is ... we should ask on the interest group   lists how people have been using wordnet and what they would find helpful.  This will give us our use case. If the only pull is  "someone that just wants some tag to put on a web page" then so be it, we   can do tht quickly, achieve the result and move on to soemthing more useful.    >   > Push is something we can do wrt to wordnet and ontology developers   > rather than to basic implementors. I agree on this.    The SWBPD group is not going to make friends by pushing anything at anyone.  As individuals we can make comments. When invited to comment as a group we   can make consensus comments. But the SWBPD is not a forum for reeducating   the wordnet developers. (No push please - not to anyone - we should only   consider producing a note as to how to build a better wordnet if the people   who build wordnets want it)    >   >> We do not think that the target audience for the WordNet TF is people   >> working on WordNet mappings, we think the target audience is any   >> semantic web developer who might find a particular WordNet mapping useful.  >   >   > See previous comment, btw I know of many people out there trying to make   > mappings or to find a minimally good ontology      Yes that's pull. Documenting what they are after would help scope phase 2.      >   >> For example, anyone creating an OWL or RDFS class might wish to   >> annotate it with its intended meaning using *the* URI for a specific   >> sense of an English word, as classified by wordnet. The main   >> requirement from this use case is agreement over what that URI is,   >> including the beginning bit (the namespace) and the end bit (the   >> mapping from Wordnet's representation of senses)  >   >   > What do you mean by "annotating an OWL or RDFS class"? Wordnet can be   > used either as a source of reusable classes (sense network reengineered   > as an ontology), or as a source of lexicalizations for classes,   > individuals, or properties. Maybe you mean the second use ...    Example later (after lunch).      > Therefore, let's define such a metaontology asap (see first point of my   > guideline list),    because that will be a valuable resource for Semantic Web deployment.    > so that we can provide best practices for more   > substantial things :)  >   > Ciao  > Aldo  >   A dopo    Jeremy        

        Can I state again what I think is proposed here:    + RDF/XML may have "duplicate triples" in as much as it has triples.  + N-triples has duplicates and an N-triple doc is a bag (multiset).    Hence, the N-triples doc corresponding to an RDF/XML doc has the same number  of occurrences of each triple.    [Note: jena.compare does not do this. I am not aware of any implementations  of this. I could modify the jena.compare code to make a stand alone Java app  which was multiset aware]    + the RDF abstract syntax is the graph, this too has mutliple triples, and  has a multiset of edges not a a set of edges.  + the model theory uses tidy graphs in which duplicates have been removed.      Stated that bluntly, the last two points don't feel quite right to me. Can't  we have a set in the abstract syntax and note that multisets occur in other  places. Shouldn't the abstract syntax be a tidy graph? untidy graphs just  being an implementation detail.    Jeremy        > -----Original Message-----  > From: w3c-rdfcore-wg-request@w3.org  > [mailto:w3c-rdfcore-wg-request@w3.org]On Behalf Of Pat Hayes  > Sent: 24 October 2001 05:18  > To: Brian McBride  > Cc: w3c-rdfcore-wg@w3.org  > Subject: Re: Closing rdfms-difference-between-ID-and-about (was: RDFCore  > WG minutes for the telecon 2001-10-12)  >  >  > >Pat Hayes wrote:  > >  > >>>Brian/Pat - were does the WG stand on duplicate triples?  > >  > >  > >Actually, I'm not sure :(  > >  > >Let me try a strawman position:  > >  > >I agree with Pat that this seems to be more of an implementation  > >issue which is hard to discuss without a processing model.  However,  > >using terms like parser, loosely:  > >  > >   o it doesn't seem reasonable to require parsers to eliminate  > >duplicates - that  would prohibit the development of streaming  > >parsers.  > >  > >   o we need say nothing this in terms of representing an RDF graph -  > >it's up to the implementor whether they filter duplicates or not.  > >that way we don't break existing implementations of either family  > >for no good reason.  > >  > >   o Pat seems to reckon the model theory is simpler with a set.  >  > Its only a slight matter. Sets are more traditional and its slightly  > easier to state some of the lemmas. No big deal either way. What I  > would like however is for us to decide it one way or the other,  > because I have to re-do the math every time we change it.  >  > >Can we extend the notion of a tidy graph so that it removes  > >duplicate statements.  Any untidy graph has an equivalent tidy  > >graph, and the model theory is defined in terms of that.  >  > Yes, we can do that. Everyone go on that?  >  > Pat        

          I will try and avoid getting into a long procedural discussion and just   continue with two detailed points ...    Jeremy:  >> I am at a lost to see why the section title changed, why a new   >> paragraph on  >> Clark Kent appeared, etc. etc.  >   >   Graham Klyne wrote:  > The new paragraphs were additional elements in response to issues   > macgregor-01, macgregor-02.  Maybe they're unnecessary, but I was trying   > to respond to the spirit of the issues raised as well as the letter of   > the issue resolution.        I felt the WG resolutions were clear - we were going to say less because   what we had said was inadequate and we didn't have enough effort left to   say it well. Hence I find it unaceptable to say more.  I am not an expert on proposotional attitudes etc. but I saw this new text   and assumed that at least some of the people who are would find it   unacceptable. Adding it seems to go against what I understood as the WG   position which is a recognition that we wanted to stay clear of some   philosophical minefields.      > As for the section title changes, I viewed these were editorial   > refinements that reflected the change of emphasis of the section contents.  >   >   >> For instance, the change in the section title breaks W3C guidelines on   >> case,  >> and so one of the reviewers who was fairly positive would be less so now.  >   >   > Oh, grumble.  That change may have been wrong to make, but the   > capitalization of section headings is something that grates quite   > severely on me.       My point here is not that capitalization is good - but simply that the   documents have been reviewed as is, and while not wanting to freeze them as   they were at LC I would like to see process in which changes are made   explicit on the list - having said this, I realise that semantics has   needed a bigger overhaul than that - but I hope the other documents are not   getting changed more than is apparent in the e-mail traffic.    Jeremy        

          > >  > > MUST:  > > replace "This document address these two requirements." with  > > <<<  > > These two requirements  are primarily addressed by the RDF Model Theory  > > (ref) and the RDF Test Cases (ref).  > >  > > This document describes an alternative complimentry approach.  > > >>>  >  Dan:  > I wrote the status section.  Per  > http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Oct/0256.html  > I propose a simpler change:    >s/This document addresses these two requirements./  >  This document is motivated by these two requirements./    > Does that satisfy your concern?    Sorry I missed that ...    That's certainly an improvement in the status.    I am convinced that the Model Theory needs to be in the references, and  mentioned in the introduction, and an acknowledgement that using model  theories as the basis for layering, while not unproblematic has not been  disastrous.    In my view, those requirements are fully addressed by the MT and Test Cases.  This document legitimately takes another view of the same requirements. But  it should not diminish the value of our REC track docs.    A possible change which would clarify that, would be section 1.    e.g.  Add  <<<    Model theoretic semantics has already proved a useful tool for discussing  and resolving issues related to layering in the semantic web. Specifically,  the semantics of OWL [in preparation] is related to the semantics of RDF and  RDFS [RDF MT], by model theoretic means.    >>>    And then move on to the difficulties with this approach in section 2.    Jeremy        

        The problem with this argumentHHHH^Hdiscussion is that you're  both right, which is why it is making fairly painful progress.    Aaron is clearly correct when he says that RDF specs and usage do not  conform (even a little bit) with RFC 2396 section 4.1.    Dan is also right to defend the current specs and usage as not actually  causing real problems in practice.    As far as I am concerned RDF really could be the Random Description  Framework (cf:  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Dec/0028.html ). For  RDF, in my view, the important part about URI-refs is the U bit not anything  else. It is just a convenient framework for identifiers. In the case when  the URIref is a property or class name in RDF then sometimes you are really  intended to retrieve the base URI and treating it as an RDF document find  the description of that URIref in order to understand what it means; but  that is only rarely and, that is as close to RFC 2396 section 4.1. as it  gets.    If you want to know what these identifiers mean then ask the RDF Model  Theory, not the RFC.    Hence in my view :) the RDF specs could (but shouldn't) start with the  following disclaimer:  [[[    In these specifications a URI means a lexical form that conforms with the  production URI-reference in RFC 2396; however any other resemblence with RFC  2396 is co-incidental except in the one case when the URI reference is:  + a URL reference  + the URL refers to an RDF document (in any serialization)  In which case, it is conventional that the RDF document provides a schema in  RDFS or some other schema language which may give a decription of the URI  reference.  ]]]    In practice, RDF usage picks and chooses and modifies RFC 2396, we could  make this explicit, or we could let it continue unclarified. I don't think  we can undo it.    I am convinced that Aaron's proposed resolution is way too radical - but he  has all the good arguments (except pragmaticism).        Jeremy        

          > > What graph does this denote?  > >  > >    <rdf:Description>  > >      <eg:prop>foo < bar</eg:prop>  > >    </rdf:Description>  > >  > > I think it should be:  > >  > >    _:a eg:prop "foo < bar" .  >  > I agree.  >  > > but others (including the W3C RDF validator service) seem to  > > think differently.    The validator is confused.  If you ask it for n-triples, it gives the correct answer, but it presumably  doubly escapes by default.    Jeremy        

          > (though there is always the risk of having too many targets in one  > paper for reviewers to aim at... and some folks take query rather  > passionately ;-)  >    That's a good point - we do need to have a round later in the process where  we imagine hypothetical reviewers and see how to please them.  It might be helpful to think of particularly people - e.g. I tend to try to  think what Peter might find acceptable (I don't believe I often succeed).        

      >  > A little unparliamentary that.  I hear calls of "withdraw".  >  > It may be a little old maidish of me, but one of the virtues this WG has,  > in my view, been the respect in which members hold each other and each  > others views.  >  > I'm sure this was meant in a jokey way, but I'd like to take the  > opportunity to remind folks that's not the sort of language we have  > typically used around here.    I am sorry, and withdraw - I was only referring to Pat's self-deprecation.    Jeremy        

        I responded to DanC on RDF-interest, RDF-logic    http://lists.w3.org/Archives/Public/www-rdf-logic/2002Jan/0037.html    I started from Dan's most recent version of the problem and concluded:     "TDL is backwards compatible and S isn't."    More to the point, on bended knee     "Can't we just drop this one -- please, pretty, pretty please with a cherry  on top?"    we have done it to death.    Jeremy      > -----Original Message-----  > From: w3c-rdfcore-wg-request@w3.org  > [mailto:w3c-rdfcore-wg-request@w3.org]On Behalf Of Brian McBride  > Sent: 31 January 2002 11:00  > To: Patrick Stickler; RDF Core  > Subject: Re: Datatyping Summary V2  >   >   > At 10:57 31/01/2002 +0200, Patrick Stickler wrote:  >   > [...]  > from Sergey's.  > > > Under TDL, consider the graph:  > > >  > > >  _:f <rdf:type> <film> .  > > >  _:f <dc:Title> (_, "10") .  > > >  <mary> <age>   (_, "10").  > > >  > > > Does this entail:  > > >  > > >  _:x <dc:Title> ?y .  > > >  _:z <age>      ?y .  > > >  > > > I believe there is agreement that it does not under the   > current TDL model  > > > theory.  > >  > >No. This is not correct.  >   > I've just chatted to Jeremy, who tells me you and he have also   > talked this   > morning, that Jeremy will sending out you joint position on this   > question soon.  >   > Brian  >   >         

            Frank Manola wrote:    > (I thought Pot was illegal over there.)        It's being reclassified as "Class C".    Politicians point out that this is *not* de facto legalization.    (If they need to say it, some might say that the opposite must be true).    Jeremy        

          Dan Connolly wrote:  >   > Er... whoa! I'm having trouble following this thread...  > I doubt I'll be prepared to decide on this by Friday.    I had misunderstood the earlier silence.    >   > I need direct implementation experience with whatever  > proposal we come up with in order to be comfortable.  > (test cases are really important for that, btw.)    I think we need to agree something, and then review it in light of  implementation experience.    Without some initial agreement it is very hard to know what we should be  getting experience of.      URI or lang tag  ===============    I had a little trouble understanding Dan's comments about the (string,  URI) pair.    What the text was trying to say is that we were still considering that  possibility and for now we agree that at least we have a (string,  lang-tag) pair, and that since lang-tags can be given URI's like in  Graham's rfc draft, we see that work we do now based on (string,  lang-tag) is sufficiently likely to be extensible to (string, URI) pair.    I personally didn't feel able to do the (string,URI) pair idea justice,  and would like someone else to have a stab at it. For now, I am  suggesting we agree on a (string, lang-tag) baseline without ruling out,  the (string,URI) extension.    Perhaps paras [2] and [3] need rewording to emphasize that possibility.  If you feel that would improve this aspect of the document sufficiently,  I can have a go.    Datatypes  =========  > > [3]  > >    NOTE: The RDF Core Working Group has yet to consider whether  > >    such an approach would be useful for integrating XML schema  > >    datatyping with RDF.  >   > I'm not comfortable with that either (as I've said).    We do need to consider how XML Schema datatypes fits, and  the literals  document deliberately does not.  This is simply to partition the issues. Once we have a proposal for XML  Schema datatypes and RDF we will need to review the Literal  representation.    On the other hand, I *am* trying to rule out ideas like the Literal is  really a complex datatype and not a string. Jan, if I have understood  correctly, would like a Literal to be almost an arbitrary object, in an  OO sort of way (sorry if I misrepresent that position). I think it has  been considered whether an xml literal value should be represented in  RDF by its infoset (not a string).    I have tried to argue the "string" corner here. We can represent a  complex object like an xml nodeset as a string, we just need to agree on  canonicalization rules.    I hope, naively, that this same approach can be extended to other  datatypes, so that from an RDF point of view all Literals are just  strings, with one other piece of information (e.g. the URI) that allows  us to interpret them appropriately in an application setting.      rdf:parseType="Literal" etc.  =======================  DanC:  >   > For the rest, I'd have to have my implementation-source-code  > open in the other window to review it carefully. No  > time for that just now. (I'm in another telcon :-( ).    It would be very useful, the intent with rdf:parseType="Literal" is  that, modulo bugs, any reasonable interpretation of M&S should remain  legal. It was quite hard to say that and constrain the RDF processor at  all!      W3C & NFC Normalization  (last item - message can be abandoned when you  get bored with this bit!)  =======================    >   > > [1a]  > > The Unicode String in an RDF Literal is normalized according  > > to Unicode Normalization Form C [NFC, NFC-Corrigendum], using  > > a framework of early uniform normalization.  >   > Yikes! I haven't seen enough motivation to change the RDF 1.0  > spec in that way. (maybe the motivation is there and I  > just haven't read it.)    I will start with two quotes from charmod about early normalization:    "Current receiving components (browsers, XML parsers, etc.) implicitly  assume early normalization by not performing normalization themselves.  This is a vast legacy."    and    "Not all components of the Web that implement functions such as string  matching can reasonably be expected to do normalization. This, in  particular, applies to very small components and components in the lower  layers of the architecture."    I think RDF is one such component (lower layer) and the stuff I wrote on  normalization has the intent of being that RDF implementators do not do  any normalization, since it is all done elsewhere.    I am not deeply wedded to para [1a], it is however a consequence of the  rest of the document.  I'll replay the argument.    The short version is:  + Under charmod document producers  must produce W3C-Normalized  documents, i.e. in NFC when transcoded and after charcater reference  expansion.  + More simply, the documents MUST be W3C-Normalized (this is implicitly  a requirement on the producer).  + A W3C-Normalized document is, when in Unicode, in NFC.  + An NFC RDF document will necessrily only contain NFC literals.    Here's the long version:    In the old M&S there is a reference to the difficulty of equality for  unicode strings. vis:       (P217) Two RDF strings are deemed to be the same if their ISO/IEC      10646 representations match. Each RDF application must specify      which one of the following definitions of 'match' it uses:        (P218) the two representations are identical, or       (P219) the two representations are canonically equivalent              as defined by The Unicode Standard [Unicode].         Note: The W3C I18N WG is working on a definition for string identity       matching. This definition will most probably be based on canonical       equivalences according to the Unicode standard and on the principle       of early uniform normalization. Users of RDF should not rely on any       applications matching using the canonical equivalents, but should  try       to make sure that their data is in the normalized form according to       the upcoming definitions.     I feel that my text is an attempt at clarifying this. In particular  (P219) above is deleted, and the Note upgraded to being normative. I  admit that putting Normal Form C right at the beginning makes it look  like a burden on implementators when in fact it is less burdensome than  M&S.    2: charmod contains the definition of equality referred to, this  definition is based on a (proposed) basic underlying principle of a  world-wide web architecture: "Early Uniform Normalization".    Quick intro to normalization  ----------------------------  The example given in charmod about unicode normalization concerns  precomposed or decomposed characters, vis:       http://www.w3.org/International/Group/charmod-edit#sec-normalization-examples    (charmod section 4.2)  > The string "su?on", expressed as the sequence of five characters   > U+0073 U+0075 U+00E7 U+006F U+006E and encoded in a Unicode encoding   > form, is both Unicode-normalized and W3C-normalized.     > The string "su?on", expressed as the sequence of six characters U+0073   > U+0075 U+0063 U+0327 U+006F U+006E (U+0327 is the COMBINING CEDILLA)   > and encoded in a Unicode encoding form, is [not] Unicode-normalized   > (since the combining sequence U+0063 U+0327 is replaceable by the   > precomposed U+00E7)       W3C normalization is expressed as concerning the role of charcter  references etc in the document. For RDF literal values I believe this  concept needs extension since  "suc<!-- A comment separating two composable characters -->̧on"   is W3C-normalized according to the current draft, but comment stripping  makes it unnormalized.      Early uniform normalization  ---------------------------    http://www.w3.org/International/Group/charmod-edit#sec-Normalization    The key idea is that as soon as an text is converted into unicode (any  UCS-based encoding) then it should be normalized, and that any  application that does not *create* new unicode text does not need to do  much more than treat unicode string as uninterpreted binary.    The motivations for this *early* normalization are given in charmod  (section 4.1)    Normalization responsibilities  ------------------------------      Charmod section 4.3.    In trying to understand the relevance of this section to RDF we have to  equate terms like producer, recipient and proxy with the elements of RDF  processing.    I treat an RDF/XML processor (in my view the parser) as a recipient, and  my      [11]    RDF/XML processors MUST NOT normalize input from an XML document     that is encoded in a UCS-based encoding. c.f. [CHARMOD] for     rationale.    follows from       "The recipients of text data [...] MUST NOT normalize it."     in charmod.    The requirement to use a normalizing transcoder, my para [10] and [14]         [10]    When parsing RDF/XML the XML processor, if necessary, converts    the XML document to the UCS character domain. When doing this    from any encoding that is not UCS-based this conversion SHOULD    use Unicode Normalization Form C [NFC, NFC-Corrigendum].      [14]    Summary of text normalization for RDF/XML processors.    RDF/XML processors MUST use a normalizing transcoder    from non-UCS-based encodings.    RDF/XML processors MUST NOT do any other text normalization.    (cf. http://www.w3.org/TR/charmod/#def-normalizing-transcoder )    follows from charmod:    "Recipients which transcode text data from a legacy encoding to a  Unicode encoding form MUST use a normalizing-transcoder."      My paras [9] and [12]     [9]    RDF/XML documents MUST be W3C-normalized.     An early uniform normalization framework is used.    See [CHARMOD] for definition.      [12]    RDF/XML documents SHOULD be W3C-normalized as specified in    [CHARMOD]. Moreover, after the stripping of comments and    processing instructions an RDF/XML document SHOULD still be    W3C-normalized. It is the responsibility of the document    creator to fulfil this requirement. RDF/XML processors MUST NOT    correct input that is not W3C-normalized. (RDF/XML processors     may detect lack of W3C-normalization in an input document, and     issue a diagnostic).    follow from charmod's     "Producers MUST produce text data in normalized form."       Having got to [9] that RDF/XML documents must be W3C-normalized (which  was Graham step), I noted that then the Literals in them are also  Unicode Normalized form C, and it seemed sensible to propogate this up  to the top level.    It does leave the problem of then specifying that rdf/xml processor must  not normalize unnormalized input, and prohibiting unnormlized input,  which is ugly.          Jeremy        

        Typo?    I think you missed the following from Idiom B example:    exB:birthDate rdfs:range exP:date.lit .    Jeremy    > -----Original Message-----  > From: w3c-rdfcore-wg-request@w3.org  > [mailto:w3c-rdfcore-wg-request@w3.org]On Behalf Of Graham Klyne  > Sent: 11 January 2002 18:55  > To: RDF core WG  > Subject: RDF datatyping goals (action from teleconference)  >   >   > Attached..  >   > #g  >   >   > --------------------------  >         __  >        /\ \    Graham Klyne  >       /  \ \   (GK@ACM.ORG)  >      / /\ \ \  >     / / /\ \ \  >    / / /__\_\ \  >   / / /________\  >   \/___________/  >   >         

          Thursday, I have an earlier meeting of higher importance but unknown   duration.  I may or may not have a time conflict.    Jeremy        

          Brian McBride wrote:  >   > The use case is to:  >   >    o merge two graphs using different lexical representations of an int  >     We can use fiat to solve this use case:    "1: All RDF datatypes MUST provide a canonical lexicalization      s.t. a = b iff canonical-lex(a) = canonical-lex(b)"   2: A well-formed RDF/XML document MUST use the canonical lexicalization     for each literal."      Then an out-of-the-box M&S RDF will work.  Somewhat ugly, but robust; well up-to rounding errors.    I note that CHARMOD uses this approach to strings, where there is more  than one equivalent lexicalization of certain (non-US English) strings,  one (known as NFC) is the canonical form, and well-formed XML documents  must use that one.   Perhaps I am too uncritical of CHARMOD.    Jeremy        

      It was proposed at the Dec 14 telecon that the current syntax  working draft resolved the issue:     http://www.w3.org/2000/03/rdf-tracking/#rdfms-not-id-and-resource-attr      It was noted that agreeing to publish the working draft *does  not* implicitly agree this.    I oppose this proposed resolution.  I currently intend to vote against it at the next telecon.    I find two possibilities acceptable:  + dropping reification in its entirity  + having a plausible syntax for reification    I am concerned about the proposed meaning of the rdf:ID attribute  in certain empty property element productions (those with one or more  propertyAttr).  http://ilrt.org/discovery/2001/07/rdf-syntax-grammar/#emptyPropertyElt      gives rdf:ID in this case the meaning of identifying the object node of  the property element triple.    In all other cases, an rdf:ID on a propertyElt identifies the reification of  the property element triple.    The phrase "property element triple" above means the triple created as a  result of the property element with predicate given from the qname of the  property element start tag.      As I have previously argued M&S is inconsistent and has been  inconsistenly implemented and can be clarified in a number of  different ways. Dave's clarification has the side effect of  being to continue to apply the death of a thousand cuts to  reification.    Dave's position is that in the document:    <rdf:RDF xmlns:rdf="..."           xmlns:x="http://example.org/">    <rdf:Description>       <x:prop rdf:ID="r1">val</x:prop>       <x:prop rdf:ID="r2" rdf:parseType="Resource">           <x:prop>val2</x:prop>       </x:prop>       <x:prop rdf:ID="r3" rdf:parseType="Resource"/>       <x:prop rdf:ID="r4"/>       <x:prop rdf:ID="x5" x:prop="val2" />      </rdf:Description>  </rdf:RDF>      That the property attribute rdf:ID within a property element  maps to reification in the graph for almost always (e.g. cases  r1, r2, r3, r4) and just occassionally, according to some baroque  rules that are still incorrectly articulated, it has some other  semantics. (See following posting for feedback on the mistake - this of  course can be fixed, but is symptomatic of a bad rule).    The result is that anyone who isn't an RDF syntax expert cannot use  reification, because every so often this corner case will come back  and bite them.    If that is what we want, we should kill reification completely.      Hence,    given that:  -  M&S gives two inconsistent readings for the relevant productions  -  implementations have varied in their misreadings of M&S on this issue  -  it was raised very early in RDF comments that M&S is inconsistent    (and this comment has not yet been satisfactorily addressed)      I propose that we  +  decide that rdf:ID on property elements productions uniformly     signals reification  +  action the syntax WD editor to make the necessary changes      Moreover, but independently,    I propose that we allow rdf:ID and rdf:resource on empty property  element productions.    (This is a change, but seems to me to be only a simple tidying up.  If no one else agrees with this last point, I would not oppose  the opposite resolution).      Links:    A previous thread:  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Oct/thread.html#332    The first posting to rdf comments on this issue:  http://lists.w3.org/Archives/Public/www-rdf-comments/1999JanMar/0026.html    On killing reification:    That is a serious suggestion, I have prepared a proposal to that  effect but I am seeking feedback from HP colleagues before making it.  i.e. as HP rep, I should try to check whether any HP people use, or  intend to use, reification before finalising my position on it.  (It would be kind of embarrassing if I had to oppose my own proposal because  my colleagues felt strongly the other way!).,      Jeremy        

        >  > PS in that same minutes I found this, BTW. So why are we still  > talking about it??  >  > 19: Issue rdf-containers-otherapproaches  > The design of the RDF Model collection classes exhibit various  > awkward features. Might these be augmented with a 'better' design?  >  > Propose:  >  >    o   the WG resolves this issue is out of scope for this WG  >        but places the issue on the list of to be considered by a  >        future WG.  >  > See:  >    http://www.w3.org/2000/03/rdf-tracking/#rdf-containers-otherapproaches  >  > APPROVED      I think we are talking only about closed-containers, which was the  daml:collection issue.    Otherapproaches I saw as a much more general rethink.  (Procedurally I think I am the only one who might want to go this route ...  if discussing daml:collection is currently out-of-order because the  rdf-containers-otherapproaches issue is closed, then we may well have enough  support to reopen it; which I would like in order to discuss other things. I  am clear that this isn't the desire of the group).    Jeremy        

        I've not read the comment yet, going on Graham's quote.    Suggested response is:    [[  In RDF/XML it would be unnatural to restrict bnode identifiers to US ASCII.  This would prevent document authors from using bnode IDs with mnemonic  identifiers in Thai for example.  Given the goals of N-triple - a testing language, the restriction to  US-ASCII is well-motivated.    Thus it is not possible to align the two concepts while being faithful to  the design goals of the two languages.  ]]    It would be better to quote from the docs - I suspect there's a suitable  piece about Ntriple being in US ASCII.    Jeremy        > -----Original Message-----  > From: w3c-rdfcore-wg-request@w3.org  > [mailto:w3c-rdfcore-wg-request@w3.org]On Behalf Of Graham Klyne  > Sent: 28 October 2003 11:54  > To: w3c-rdfcore-wg@w3.org  > Subject: Fwd: N-Triples VS RDF/XML bNode identifiers  >  >  >  >  From RDF-comments [1]:  >  > >While parsing the RDF/XML, the parser generated bNode IDs that were  > >legal according to the RDF/XML specs and these were written as-is to the  > >N-Triples document. An example bNode identifier is "node09FC-1E4A-2". In  > >RDF/XML, the dashes (and underscores, etc.) are legal characters for  > >bNode identifiers. In N-Triples, however, only (ASCII-)letters and  > >number can be used. Thus the procedure sketched out above resulted in an  > >illegal N-Triples document.  > >  > >So, my question is: wouldn't it be convenient to make the two  > >definitions identical?  >  > Maybe it would be convenient, but I think any response should point out  > (and Concepts is quite clear about this [2]) that any particular  > representation of bnodes is always an artefact of the particular syntax  > used.  When reading any syntax that uses bnode identifiers, applications  > must always be prepared to re-allocate the identifiers.  >  > I might even argue that having different syntax for N-triples and RDF/XML  > is (almost) a Good Thing, since it reinforces this point.  >  > #g  > --  >  > [1]  http://lists.w3.org/Archives/Public/www-rdf-comments/2003OctDec/0067.html    [2] http://www.w3.org/TR/rdf-concepts/#section-URI-Vocabulary       http://www.w3.org/TR/rdf-concepts/#dfn-blank-node-id      ------------  Graham Klyne  For email:  http://www.ninebynine.org/#Contact        

          Sorry Dave, I am having difficulty reconciling what you say here, with your   message to Jan on the comments list.    I had given him a zip of the current W3C CVS, and I believe he had picked   up the change you made (on Friday?) to make the object a literal not a   blank node.    My understanding of the approved test is that the object is a blank node,   and that there are no literals in this test case.    If this differs from yours we need to discuss it.    In particular I disagree with:  [[    Revision : 1.2  Date : 2002/12/18 11:31:28  Author : 'jgrant'  State : 'Exp'  Lines : +2 -2  Description :  Raptor fix: this now gives an empty literal, not a bnode.  ]]    Revision 1.1 was correct and did not fixing.    Jeremy    Dave Beckett wrote:    > We just had a comment on this test case on the rdf comments list:  >   http://lists.w3.org/Archives/Public/www-rdf-comments/2003JanMar/0043.html  > and this means an approved test case needs to be corrected to match  > the rdf/xml grammar.  >   > This result:  >   http://www.w3.org/2000/10/rdf-tests/rdfcore/rdfms-not-id-and-resource-attr/test003.nt  >   > needs the following change:  >   > 15c15  > < _:j88096 <http://example.org/prop1> "" .  > ---  >   >>_:j88096 <http://example.org/prop1> :j88097 .  >>  >   > to match http://www.w3.org/TR/rdf-syntax-grammar/#emptyPropertyElt  > where when both rdf:ID and rdf:bagID are both present, the statement  > value is a blank node (the "Otherwise" clause) not an empty literal.  >   > The good news:  >   > [[P.s.Using SWI-Prolog from the CVS snapshot it processes the rest of  > the test-suite properly now.]]  >   > So that makes nearly 4 full implementations of the parser test cases  > (detailed evidence for this will have to be collected).  >   > Dave  >   >         

        I forgot to put a pointer to further limitations of exclusive  canonicalization:    http://www.w3.org/TR/2002/CR-xml-exc-c14n-20020212#sec-Limitations        

          > > (but a short note clarifying no canonicalization for RDF/XML  > > is required would be enough to satisfy me ;-)  >  > <pause for Jeremy to write it> :)    Hardly ... it is there in the implementation note in concepts from the  resolution:    <<<<    add implementation note at end of abstract syntax section (old 6, new 5)    [[  <a name="implementation-note"> </a>  IMPLEMENTATION NOTE:  This section describes an *abstract* syntax which describes  equality of literals and equivalence of graphs. This is the  syntax over which the formal semantics are defined.  Implementations are free to represent literals and RDF graphs in  any other equivalent form.  As an example:  literals with datatype <tt>rdf:XMLLiteral</tt>s can be represented  in a non-canonical  format, and canonicalization performed during the comparison between two  such literals. In both this example, and in the example  <a href="#lang-implementation-note">above</a>  the comparisons may be  being performed either between syntactic structures or  between their denotations in the domain of discourse.  Implementations that do not require such comparisons can  hence be optimized.  ]]  >>>>>>>    There is also a sentence in syntax that draws parser writers attention to  this:    by  [[  This specification permits any  <a href="rdf-concepts#implementation-note">representation</a>  of an RDF Graph (see [RDF Concepts]); in particular, it  does not require the use of N-Triples.  ]]    Jeremy        

          I am increasingly worried by    http://www.w3.org/2001/sw/RDFCore/20030123-issues/#xmlsch-04    see    http://lists.w3.org/Archives/Member/w3c-xml-schema-ig/2003Apr/0281.html    (it does not seem to have made it into www-rdf-comments yet)    Jeremy        

        Dave wrote:  > The WD-to-be does not add or remove anything from the infoset - it  > currently lists various patterns of infosets that match RDF/XML.  The  > next stage is to say what bits of graph they create.  At that point  > it might be an infoset=>infoset transformation if we choose to  > continue down this route.    My point is expressed by an example like    <rdf:RDF xml:lang="fr" xmlns:rdf="..." />    which does not match the production 4.2/6.1, while being a legal empty RDF  graph.    >  > We furthermore have issues with xml:lang (and literals) that have not  > yet been decided.    Fine, as a WD it's OK I think, and certainly I don't want to force  resolution of issues that we have not yet properly considered.    Jeremy        

      Jim:  > >R11. Internationalization  >  > I think this is out of scope unless very focused on ontology-specific  > issues of internationalization - W3C has other folks  > w/internationalization as a specific focus and we don't want to stray  > into their area.    With respect, the I18N-wg will disagree.    The charmod wd will probably come to rec before we do, and we will be bound  by the constraints that charmod places on W3C recommendations.    http://www.w3.org/TR/charmod    I do not believe these will be heavy, but we will need to give some account  of i18n and the webont language. In fact, a quick scan suggests that all the  current suggestions for requirements for specificiations (marked in S) are  ones that should be met at a lower layer (e.g. XML or RDF).      The core issue for webont and I18N, as I see it at the moment, is that in an  ontology that has a property named in american english "color", there is no  way currently in any of the lower layers (XML, RDF) to express that this is  american english, and that the british english is "colour", and the italian  "colore". This is because the property names are the fragment IDs of URI  references, and there is no way in the current stack of attaching a language  tag to URIs, URI references or fragment IDs.    I note that in some cases where the same word means different things in  different languages (e.g. "shopping" in English & Italian) this could become  a significant problem.    We may well need to have a fairly significant effort to explain how  ontologies can be internationalised.    Jeremy        

          Dan Connolly wrote:  >   > You're not saying the XML solution conflicts with what RDF needs,  > are you? This issue is so messy that I have a hard time following...  > but if I understand correctly, the XML processors can  > follow the advice that the XML Core WG has given, and RDF  > stuff can be layered on top, and it all works out. True?    TRUE.        >   > If folks are reading in RDF/xml with the intention of  > writing it back out as RDF/xml, I might suggest they  > keep the pre-decoded unicode string around as well  > as the US ASCII URI....    Yes that would be a good idea.        Jeremy        

        > [[  > Why we didn't accept I18N's objection to the design of XML literals  >  > 1. Review status of the WG, noting that we're long overdue, losing  > participation, and that the I18N desideratum for "seamless plain and XML  > literals" was only articulated well after the end of LC1.  This might use  > material from my earlier message [1].    Hmm, while finding much of your msg compelling .. I note that this  requirement "seamless plain and XML literals" is not part of the objection -  so we don't particularly need to justify not addressing this.    More later    Jeremy        

          Should we have any tests for this issue?    It would be helpful in discussing xml literals in the graph syntax.    Jeremy        

              > My preferences, in order, most prefered to least preferred:  >   > Option 4, 1, 3, 2  >   > > Option 4 in my mind is simply incorrect - there are XMLLiterals   > for which the   > > language is semantic meaningful.  >   > Well, why is it not unreasonable to require that, where an xml:lang tag  > is relevant to an XML literal, that it be specified *within* the XML   > literal. Why do we have to do it for *every* XML literal automatically?  >     That feels to me like a step backward from what M&S provides (sort of).    e.g.  <rdf:RDF xml:lang="en">  ...    <eg:prop rdf:parseType="Literal">I did <em>not</em>   like that</eg:prop>  ...  </rdf:RDF>    ==>    <eg:prop rdf:parseType="Literal"><span xml:lang="en">I did <em>not</em>   like that</span></eg:prop>      Jeremy        

          I thought I would summarise where I had understood we had got to during  the teleconference - although noting no decisions were made.      We should consider pair ( Unicode-String, URI ) as generalisation of (  Unicode-String, lang ).    There was agreement with the treatment of equality proposed.    Desire to find wording that is consistent wioth current implementations  of rdf:parseType = "Literal" while suggesting canonicalisation as a good  idea.      ----    The main points in the e-mail still outstanding are from Graham.    Graham:  > At the risk of stating the obvious, I'd like to distinguish:  > - a literal specified as an attribute value  > - a literal specified as XML element content conforming to #PCDATA  > - a literal specified as XML element content conforming to ANY, using   > rdf:parseType="Literal".  >   > In the first two cases, I think the resulting literal is a Unicode string   > corresponding to exactly the content of the property element or attribute.    IMO, we should say this explicitly, and explicitly prohibit whitespace  trimming.      [ ... snip ... in the third case ... ]  Graham again:  > I see two possibilities:  > (a) for parseType="Literal", treat the literal as an infoset (not a Unicode   > string) and define equality based on infoset equivalence, or  > (b) apply canonicalization to achieve an equivalent result on Unicode strings.    My reading of the WG was that there wasn't a lot of support for option  (a) and I am currently not seeing exploring it as part of the action   2001-09-07#5. If the WG is unhappy with whatever Bill and I come up  with, we may wish to review that.    Jeremy        

          stylistically this is more formal than I would have made it, but that's no   big deal ...    I am not entirely comfortable with the word 'endorsed' used twice - I am   not at all sure that any of our WG Notes constitute endorsement by the W3C.   My understanding is that the Rec track process is for that.    Suggest the following changes:    1) delete sentence    [[  But this work has never been endorsed by any of relevant standard   organizations (W3C and ISO).  ]]    (Or alternatively replace 'endorsed' by 'followed through')      2) modify  [[    endorsed by both W3C and ISO.  ]]  to  [[     potentially jointly published by both W3C and ISO.  ]]      Jeremy      Bernard Vatant wrote:    >   > As decided during Cannes meeting, below is a draft message proposal to be  > sent by SWBPD WG to the standard body in charge of Topic Maps standard,  > namely ISO/IEC JTC1/SC34/WG3.  > See http://www.isotopicmaps.org for more information about this WG.  >   > The message is specific, but my view is that it could be used as a  > 'template' for dealing with other groups, organizations or communities,  > when we think their work is relevant to the SW, and would like to trigger a  > process of collaboration.  >   >   > <draftMessage>  >   >>From :  > whoever@w3.org  > on behalf of W3C Semantic Web Best Practices and Deployment WG  >   > To : ISO/IEC JTC1/SC34/WG3  > James David Mason, Chairmxm@y12.doe.gov  > Steve Pepper, Convenor  pepper@ontopia.net  >   > Gentlemen  >   > The new W3C Working Group 'Semantic Web Best Practices and Deployment' [1]  > has put Topic Maps on the list of (many) legacy and technologies that it  > would like to be made  > interoperable with the Semantic Web infrastructure and languages.  > For those technologies, the SWBPD WG purpose is to identify and promote  > best practices for interoperability.  > The intended process needs to involve participation of qualified experts,  > assuming organizations and communities of users have expressed interest in  > the Semantic Web initiative.  >   > Relevant preliminary work has been made in recent years in the TM  > community, including various proposals for TM-RDF mapping. But this work  > has never been endorsed by any of relevant standard organizations (W3C and  > ISO).  >   > This message is intended to trigger a process in this direction, provided  > you agree on :  >   > - A common declaration of interest in collaboration at the organizational  > level, respectively W3C SWBPD and ISO/IEC JTC1/SC34/WG3. ( Consider this  > declaration is made from our side through the present message. )  >   > - Definition of a task force, including people proposed by ISO/IEC  > JTC1/SC34/WG3 as invited experts.  > This task force would have as first objective to deliver a Technical Note  > on best practices for TM-SW interoperability, endorsed by both W3C and ISO.  >   > We are looking forward for a positive feedback.  >   > Regards  >   > ...  >   > [1] http://www.w3.org/2001/sw/BestPractices/  >   > </draftMessage>  >   >   > Remarks:  >   > - A TM-RDF workshop mentioned by DanBri during Cannes meeting  > http://www.w3.org/2001/sw/Europe/events/2004-tmrdf/  > could it be used as a place to kick-off this process ?  >   > - The most relevant expert in RDF-TM interoperability is AFAIK Lars Marius  > Garshol  > See : "Living with topic maps and RDF"  > http://www.ontopia.net/topicmaps/materials/tmrdf.html  >   > - Some personal contribution can be found in the paper  > "Ontology-driven topic maps" I will present next month at XML Europe  > http://www.idealliance.org/europe/04/call/xmlpapers/03-03-03.91/.03-03-03.h  > tml  >   > Thanks for your attention  >   > Bernard Vatant  > Senior Consultant  > Knowledge Engineering  > Mondeca - www.mondeca.com  > bernard.vatant@mondeca.com  >   >   >   >         

      > I've pencilled in 9.00-11.00 on Tuesday  [..snip..]  > OK?  >     OK by me; Brian?    Jeremy        

          Sergey:  >Finally, I think that global datatyping (Sec. 3.2) is out of scope of the  >current document. At this point of time we do not have a mechanism  >robust enough to standardize on global datatyping.    Brian:  > I interpret these comments in the light of your preference for tidy  literals.    I think not ...    my understanding (which dates from before my holiday and during Brian's!) is  that the WG appeared to have a consensus (minus at least Patrick) forming  around not doing a global idiom.    I am not up to date on what has happened while I have been relaxing.    My understanding of the motivations are:  - the WG has had a mild majority in favour of tidy global idiom  - the community process showed a majority in favour of untidy global  - many members of the WG, including myself, concluded that we cannot reach  *consensus* on a global idiom    Thus, I have argued that even with the community backing, while I still  believe in the untidy global idiom, I do not think it is ready for  standardization.    This discussion is deliberately punting on tidiness an issue that Patrick at  no point let us forget is model theoretic in nature.    My sense at the last telecon I attended was that if we had been asked the  following questions:    * we resolve not to do a global datatype idiom  * we agree that we all can live with both a tidy or an untidy model theory  * we will have an e-mail discussion and then a straw poll on tidiness    that, with the probable exception of Patrick, many of the WG would have gone  along with that. For instance, my position of favouring untidiness is a lot  less rigid once we have dropped the ambition to do global datatyping. I  suspect that those who favour tidiness likewise could live with untidiness  if it purely in the model theory and not part of datatyping.    Jeremy        

          (actually this msg)  Jeremy Carroll wrote:    >   > Dear Chris  >   > with luck this msg is:  >   > http://lists.w3.org/Archives/Public/www-archive/2004May/0006  >   > other msgs can be found in  >   > http://lists.w3.org/Archives/Public/www-archive/2004May/  >   > which you should check for further msgs  >   > Jeremy  >         

        Brian:  > then to be consistent     I agree.    >  we must also decide that anything (and nothing) entails:  >  >   _:s <rdf:type> <rdf:Statment> .  >   _:s <rdf:subject> <subject> .  >   _:s <rdf:predicate> <predicate> .  >   _:s <rdf:object>    <object> .    > for any subject, predicate and object.    And consistently, I disagree with any special entailment for reification.    Jeremy        

        > > > As far as I understand freenet URIs have an owner, who often wishes to  > > > remain anonymous. (Hence the use of freenet).  > > >  > > > Thus, putting too much weight on URIs having an authoritative owner  >  > Where do we put any weight on that?  >    Sorry:  (that's a funny fragID)   http://www.w3.org/TR/2002/WD-rdf-concepts-20021108/#section-RDFDifference    also third para of    http://www.w3.org/TR/2002/WD-rdf-concepts-20021108/#section-Interaction    Here is the current text:    [[  The social conventions surrounding use of RDF include the idea that each URI  'belongs to' somebody who has authority and responsibility for defining its  meaning. The social conventions are rooted in the URI specification  [RFC2396] and registration procedures [RFC2717]. A URI scheme registration  refers to a specification of the detailed syntax and interpretation for that  scheme, from which the defining authority for a given URI may be deduced. In  the case of http: URIs, the defining specification is the HTTP protocol  specification [RFC2616], which obtains a resource representation from the  host named in the URI; thus, the owner of the host's DNS domain controls  (observable aspects of) the URI's meaning.  ]]    and    [[  RDF assumes that for any URI some individual or organization has the  authority to define the meaning of that URI. An RDF predicate is defined by  the individual or organization with such the authority with respect to the  its URI, and misuse by others should not be permitted to undermine that  authority.  ]]      while the text could do with polishing, I think the idea is, at least in  part, needed, for our resolution of the rdfms-assertion issue.    http://www.w3.org/2000/03/rdf-tracking/#rdfms-assertion  [[  Resolution: On 23rd August 2002, the RDFCore WG resolved:    that the text in section 2.3.2 of the Concepts and Abstract Data Model  document resolves this issue and it be closed.  ]]    The text referred to in that resolution is found in:  http://lists.w3.org/Archives/Public/www-archive/2002Aug/att-0002/02-Overview  .htm#section-Social    which reads    [[  RDF/XML documents, i.e. encodings of RDF graphs, can be used to make  representations of claims or assertions about the 'real' world. RDF graphs  may be asserted to be true, and such an assertion should be understood to  carry the same social import and responsibilities as an assertion in any  other format. A combination of social (e.g. legal) and technical machinery  (protocols, file formats, publication frameworks) provide the contexts that  fix the intended meanings of the vocabulary of some piece of RDF, and which  distinguish assertions from other uses (e.g. citations, denals or  illustrations).    [[[This needs reviewing...]]]    For example, a media type, application/rdf+xml [RDF-MIME-TYPE] is being  registered for indicating the use of RDF/XML that might be published with  the intent of being such an assertional representation (as distinguished  from other XML or text that may just happen to look like RDF assertions).  ]]    ++++++++++    The key problem here is that the issue resolution really only talks about a  single RDF document making an assertion.  The editors have bravely tried to extend this issue resolution to multiple  related independently authored RDF documents which when combined have  slanderous entailment.  (See particularly:  http://www.w3.org/TR/2002/WD-rdf-concepts-20021108/#section-InteractionExamp  le  )    To make that work then the idea of a URI owner is needed, and this idea  seems, somewhat problematic.    However, a single document is hardly a semantic web!  And without text such as that I am questioning, we could end up with the  situation where in the clown example none of the original authors are liable  but someone who sucks up that part of the semantic web and spits it out as a  single document then has a legal liability!    Jeremy        

          I assume we shold be looking at  http://www.w3.org/2000/10/rdf-tests/rdfcore/Manifest.rdf  for the tests to run.    I have just updated the xml-sch-02 tex-01 and horst-01 Manifests as   actioned last week. Please can someone rebuild the big Manifest.    Jeremy    Eric Miller wrote:    >   > Working group member developers,  >   > We are in the process of assessing RDF implementation for drafting a   > directors decision and we need your help.  >   > Please run your code base against the test cases [1] and report your   > finding to w3c-rdf-comments as soon as possible. We need this in the   > next week.  Please include in your finding the toolkit name and   > description. Describing your toolkits in RDF gets you bonus points :) [2]  >   > Please feel free to forward this request to other developers who are   > working on RDF toolkits.  >   > thanks for all of your help,  >   > --eric  >   > [1] http://www.w3.org/2000/10/rdf-tests/rdfcore/  > [2] http://www.w3.org/2001/sw/EO/usecases/tools  >         

        References for Unicode stuff:    http://www.unicode.org/charts/    particularly    http://www.unicode.org/charts/PDF/U0300.pdf    and    http://www.unicode.org/charts/PDF/U0080.pdf    Jeremy        

          The I18N group also raised the following XMLLiteral related issue:    http://lists.w3.org/Archives/Public/www-rdf-comments/2003OctDec/0120.html  [[  - XML Literals containing only text should be equivalent to the     corresponding plain literals and to the corresponding string type     literals.  ]]    I propose we add a new issue to the issue list: relationship between  XMLLiterals and plain literals, and postpone it.    Rationale:    It is too late in the day to add new requirements. The lack of semantic  equivalence between XMLLiterals and plain literals has been clear since the  first WD of RDF Concepts, and was arguable in RDF Model and Syntax.  The RDF Semantics does not preclude RDF applications using additional  information to determine that two literals are equivalent, but does not  mandate that they should be.  Hence, RDF applciations which require this equivalence may operate in such a  mode, and so this issue is not a show stopper.        Jeremy    Proposed response:    ====================    Dear Martin    thank you for your comment      http://lists.w3.org/Archives/Public/www-rdf-comments/2003OctDec/0120.html  [[  - XML Literals containing only text should be equivalent to the     corresponding plain literals and to the corresponding string type     literals.  ]]    The RDF Core WG have decided to add a new issue to the issue list and  postpone it.    This decision to postpone is on the grounds of timeliness. We noted that  applications which require this equivalence are not prohibited from  asserting it, so we do not regard this issue as a showstopper.    Please reply cc-ing www-rdf-comments@w3.org, indicating whether this  response is acceptable or not.    Jeremy        

      > > DanBri:  > > > I propose section 6 be dropped for now, until this is fixed.  Jeremy:  > > Opposed.  DanBri:  > Ah, we disagree.    Less than we might think.    I agreed with all the facts you laid out; only disagreeing with the action.    A different action could be:  - add some test cases to clarify the difficulty  - indicate that often we have to serialize an "instance of" a graph rather  than the graph itself. (see model theory section 0 for defn of "instance  of")  - add sufficient warning text  - change status to non-normative    Test cases:    error001.nt  _:foo <eg:test> _:foo .    has no corresponding RDF/XML (we already have one of these error001.nt  somewhere).    B:    <eg:sk1> <eg:test> <eg:sk1> .    C:    <eg:sk2> <eg:test> <eg:sk2> .    Then two entailment tests and four non-entailment tests (between the three  graphs above) clarify the relationships between these graphs. By referring  to these test cases in the serialization text the limitations of the method  can be made clear.    > > I think a minor change highlighting that the meaning of the graph has  > > changed in such a serialization may improve the document.  >  > If the meaning changes, it's not a serialization so much as a  > transformation...  >  >    It's a fairly small transformation, and that smallness can be made clear  model theoretically.    Jeremy        

          I am happy - I think the TAG have enough comments without us adding to them  ...    Jeremy      > -----Original Message-----  > From: w3c-rdfcore-wg-request@w3.org  > [mailto:w3c-rdfcore-wg-request@w3.org]On Behalf Of Brian McBride  > Sent: 18 March 2004 14:32  > To: rdf core  > Subject: Draft RDFCore comments on web architecture document  >  >  >  > Here is a strawman formal comment from RDFCore to the TAG concerning the  >   architecture document last call.  >  > I would like to decide by email that the WG approves sending this.  > Accordingly, I will send it on behalf of the WG if I hear sufficient  > specific endorsement and have no unresolved objections by Tues 23  > Mar 2004.  >  > Brian  >  >  > ===========  >  > RDFCore would like to congratulate the TAG for making an excellent start  > on documenting the principles that govern the design of the architecture  > of the web.  We also recognise the great difficulty of the task the TAG  > has taken on.  >  > In response to the call for review of [1], several members of the  > RDFCore WG have submitted many detailed comments on the document [2][3]  > [4] which we hope the TAG will find useful.  We are confident the TAG  > will give due consideration to each comment on its merits with or  > without specific endorsement by the RDFCore WG.  RDFCore requests,  > however, that the tag pay particular attention to comments that relate to:  >  >    - having a clear vocabulary and meaning for fundamentatal notions  > such as resource, representation, naming, identifying etc.  >    - interpretation and use of fragment identifiers  >    - notions of authority and ownership of URIs and resources  >  > We trust that the citation of the RDF Model and Syntax specification be  > replaced with a citation of the new RDF Concepts and Abstract Syntax  > document [5] in due course.  >  > Brian McBride (co-chair)  > On behalf of the RDFCore WG  >  > [1] http://www.w3.org/TR/2003/WD-webarch-20031209/  > [2]  > http://lists.w3.org/Archives/Public/public-webarch-comments/2004Ja  nMar/0024.html  [3]  http://lists.w3.org/Archives/Public/public-webarch-comments/2004JanMar/1053.  html  [4]  http://lists.w3.org/Archives/Public/public-webarch-comments/2004JanMar/1057.  html  [5] http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/        

          RDFCore WG Minutes for the Telecon 2001-12-14  =============================================    Transcript: http://ilrt.org/discovery/chatlogs/rdfcore/2001-12-14      Agenda:  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Dec/0094.html    EXECUTIVE SUMMARY  -----------------  Syntax WD will be published.  Model Theory WD to be considered for publication next time.  Primer is progressing.  Difference between ID and about test cases approved (in part).    DECISIONS  ---------  DECISION 2001-12-14#1 Publish syntax WD, with editorial changes.  DECISION 2001-12-14#2 Test cases ID-and-about test1,error1 are approved.    ACTIONS  -------  ACTION 2001-12-14#1 Pat Hayes         Copy current editor's draft to www-archive@w3.org         and tell WebOnt WG of its existence.  ACTION 2001-12-14#2 Jos De Roo; Review Model Theory WD.  ACTION 2001-12-14#3 Jeremy Carroll; Review Model Theory WD.  ACTION 2001-12-14#4 Patrick Stickler; Review Model Theory WD.  ACTION 2001-12-14#5 Dave Beckett; Get revision to be published to Eric.  ACTION 2001-12-14#6 Eric Miller; Act as team contact for publication.  ACTION 2001-12-14#7 Jeremy Carroll; look at #rdfms-not-id-and-resource-attr  closely  ACTION 2001-12-14#8 Jan Grant; look at #rdfms-not-id-and-resource-attr  closely  ACTION 2001-12-14#9 Aaron Swarz; Sing golden triples for us all.    1: Allocate scribe     Jan Grant scribe.     Jeremy Carroll to write minutes.    2: Roll Call    Present  -------  Brian McBride  Eric Miller  Dave Beckett  Jeremy Carroll  Jos De Roo  Jan Grant  Frank Manola  Stephen Petschulat  Patrick Stickler  Mike Dean  Pat Hayes  Sergey Melnik (late)    Absent  ------  Dan Brickley  Frank Boumphrey  Ron Daniel  Bill dehOra  Rael Dornfest  Martyn Horner  Yoshiyuki Kitahara  Michael Kopchenov  KWON, Hyung-Jin  Ora Lassila  Satoshi Nakamura  Pierre G. Richard  R. V. Guha    Regrets  -------  Dan Connolly  Graham Klyne  Aaron Swartz      3: Review Agenda    No AOB    4: Next telecon - 10am Boston time, 11 Jan 2002    Agreed.    5: Review Minutes of 2001-12-07 with correction    Approved.  [[[  See:    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Dec/0089.html    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Dec/0092.html  ]]]    6: Confirm Status of Completed Actions  [[[  ACTION: 2001-11-16#4 Eric  Have updated copy available to group by 5PM EST Monday 19-Nov-2001    see:    http://www.w3.org/2001/09/rdfprimer/rdf-primer-20011101.html    ACTION: 2001-11-16#5 Pat  Post updated copy of model theory, with datatype discussion elided, for  group review by Wednesday 21-Nov-2001    see:    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Dec/0082.html    ACTION: 2001-11-16#9 FrankM  Clarify the architectural and other broader concerns with any datatyping  scheme that must be considered.    see:    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Dec/0070.html    ACTION: 2001-11-30#1 Dan Connolly  Review rdfs-transitive-subSubProperty test cases.    ACTION: 2001-11-30#9 Jeremy Carroll  Write up XML Schema structures datatyping proposal as e-mail to group.    ACTION: 2001-12-07#1  bwm  add link on wg page to primer rought working draft    see:    http://jigedit.w3.org/bmcbride/WWW/2001/sw/RDFCore/Overview.html#documents    ACTION: 2001-12-07#4 Aaron  Relay comments from RDFIG on difference between id and about    see:    http://www.w3.org/2000/03/rdf-tracking/#rdfms-difference-between-ID-and-abou  t    see:    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Dec/0084.html    ACTION: 2001-12-07#5 bwm  review test cases for rdfms-difference-between-id-and-about    see:    http://www.w3.org/2000/03/rdf-tracking/#rdfms-difference-between-ID-and-abou  t    see:    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Dec/0091.html    see:    http://www.w3.org/2000/10/rdf-tests/rdfcore/rdfms-difference-between-ID-and-  about/    ACTION: 2001-12-07#6 DaveB  to flag aboutEach removal in Syntax document and bring this to the attention  of the RDFIG    see:    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Dec/0075.html    ACTION: 2001-12-07#8  Sergey  produce new data type document by next Wednesday for review by next Friday's  teleconference    see:    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Dec/0065.html  ]]]    So confirmed.      7: Confirm Status of Withdrawn Actions  [[[  ACTION: 2001-11-30#7 Pat Hayes  Write up P for inclusion in Sergey's document  ]]]  Not confirmed; action in open state.      8: CVS Access to W3C  [[[  ACTION: 2001-11-30#3 Jan Grant Get access to test case areas of W3C site  ]]]  Continued.    9: Status of Primer  Currently work progressing on outline.  Plenty of body material already, but structure needs iteration.      10: Model Theory WD  We are aiming to approve publication at the next telecon.  We wish to draw the WebOnt WG's attention to the current  editor's draft. (WebOnt WG Face2Face on 14th/15th Jan).    ACTION 2001-12-14#1 Pat Hayes         Copy current editor's draft to www-archive@w3.org         and tell WebOnt WG of its existence.  ACTION 2001-12-14#2 Jos De Roo; Review Model Theory WD.  ACTION 2001-12-14#3 Jeremy Carroll; Review Model Theory WD.  ACTION 2001-12-14#4 Patrick Stickler; Review Model Theory WD.  11: Syntax WD  [[[  Propose publish new syntax WD  ]]]  DECISION 2001-12-14#1 Publish syntax WD, with editorial changes.    The chair noted that   - the amount of WG review was disappointing   - a Working Draft is a Draft.    The editor identified the following changes still to be made:    - add an example    - add a URI ID example    - add a "changes" section (everything has changed).      ACTION 2001-12-14#5 Dave Beckett; Get revision to be published to Eric.  ACTION 2001-12-14#6 Eric Miller; Act as team contact for publication.      12: Issue: #rdfms-difference-between-ID-and-about  [[[  Propose the WG:      o  resolves that new syntax WD resolves this issue.      o  Approve test cases for this issue    See:    http://www.w3.org/2000/03/rdf-tracking/#rdfms-difference-between-ID-and-abou  t    http://www.w3.org/2000/10/rdf-tests/rdfcore/rdfms-difference-between-ID-and-  about/    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Dec/0091.html  ]]]  DECISION 2001-12-14#2 Test cases ID-and-about test1,error1 are approved.    Test case  http://www.w3.org/2000/10/rdf-tests/rdfcore/rdfms-difference-between-ID-and-  about/test2.rdf  was not approved because it interacts with I18N issues,  that are unresolved.    13: Issue: #rdfms-not-id-and-resource-attr  [[[  Propose the WG:      o  resolves that new syntax WD resolves this issue.    See:    http://www.w3.org/2000/03/rdf-tracking/#rdfms-not-id-and-resource-attr  ]]]  Some discussion, resulting in.  ACTION 2001-12-14#7 Jeremy Carroll; look at #rdfms-not-id-and-resource-attr  closely  ACTION 2001-12-14#8 Jan Grant; look at #rdfms-not-id-and-resource-attr  closely    We will try to close it next time.    14: Review test cases on para 196  [[[  ACTION: 2001-11-30#5 Dave Beckett Create test case showing that the 2nd URL  in Para 196 is permitted.  See:    http://cvs.ilrt.org/cvsweb/redland/rdfcore/rdfms-para196  ]]]    Jos has reviewed it,  ACTION 2001-12-07#3 Jeremy Review test cases on para 196  continued.    15: Datatypes  General discussion.      Closing discussion  -------------------  ACTION 2001-12-14#9 Aaron Swarz; Sing golden triples for us all.  Frank's seasonal triple: "ho" "ho" "ho" .    Meeting closed.  (Datatyping discussion continued).    16: Issue: rdfms-assertion  NOT REACHED        

          Dan Connolly wrote:  > ... but I don't see any proposed solution.    I take that as an invitation to sketch a strawman.    The goal is to define what value is created by production [6.34].  I think in M&S a literal is basically a string, rather than a complex  structure (xml:lang notwithstanding).  I take the key part of the syntax clarification to be that RDF/XML is  defined over infoset.  I would define being a legal value for production 6.34 by means of a  document edit operation that replaces the RHS of production 6.34 by a  string. Such a string is a legal value according to that production if it  leaves the infoset or the XPath nodeset unchanged.    More formally:    ======        RDF processors MAY represent values from production [6.34] as any  string of XML markup which when inserted into the input document in the  place of the right hand side of the production does not change the XML  Infoset of the document. RDF processors which do this are RECOMMENDED,  but not required, to use the actual string from the source document.      RDF processors MAY represent values from production [6.34] as any  string of XML markup which when inserted into the input document in the  place of the right hand side of the production does not change the XPath  nodeset of the document, and which can be inserted between the two tags  <a> and </a> to form an XML document. RDF processors which do this are  RECOMMENDED, but not required, to use the canonical form of the document  subset according to [XML Canonicalization].      RDF processors MUST represent values from production [6.34] according  to one of the two methods above. RDF processors MUST indicate which of  the two is performed.       RDF document writers are cautioned that the first of these two methods  can lead to XML fragments that are incomplete through missing namespaces  or unexpandable references {sorry words need editing}, and hence if  maximum portability is required for an RDF document all namespace  bindings needed within an XML literal should be included within it, and  no entity or character references other than the predefined character  references should be made.     RDF document writers are cautioned that RDF processors are not required to  map identical xml literals to the same string but may use a  non-deterministic algorithm considering issues such as attribute order and  whether to reperesent an empty element as one tag or two. Hence, equality  between literals, and between models, may not work in the way expected. If  it is known that one of the RECOMMENDED representations is used then  equality will work.    ===    I think there are still a load of issues with such an approach; but hope  that it is a starting point.  It will be interesting to see what the  fragments group have to say.      Jeremy        

        Uschold, Michael F wrote:  > Alan is now suggesting that to this we add another task, which naturally  > follows: what things CANNOT be done easily or conveniently or AT ALL  > using OWL. This can then be fed back to [?WHO?] at the W3C as  > requirements for extensions/updates to OWL.  >     Alan:  > I'd like to come in just to say that in a recent set of travels and  > discussions with potential users of OWL, the inability to express  > numeric constraints involving inequalities for things such as "Big  > Wheel" etc. is a big problem.  Virtual all my biomedical examples  > require normal values, value ranges, etc. which need this kind of  > expressiveness .  >       It is in scope for the XML Schema Datatypes TF to address the specific   issue of how to (slightly) increase the expressivity of RDF and OWL to   permit user-defined datatypes (and hence at least a minimal solution to   the big wheel problem).    Quite how to deploy that solution (in terms of the standards) is yet to   be determined ... since there was support for issuing a first datatypes   note that raised the questions, I think this is a plausible question to   ask the community at that point.    Personally, if the necessary changes to any recs were small, I would   favour errata against the current recs. That might not fly ... another   option might be to have a rec track doc ourselves; or simply to record   the consensus and await the next revision of RDF, OWL and/or XML Schema   to deploy this consensus within the Rec track.    Without having thought about it much, I think small errata is the   simplest path, but might meet opposition, and having a rec track doc   ourselves would be a mistake. This might leave us with simply   documenting the current position and suggested changes (which seems to   be Mike's position)    I would be nervous about generalizing this - e.g. QCC were considered by   webont and rejected, I would be very uncomfortable with this group   revisiting that - whereas the user-defined datatypes issue was desired   by both RDF Core and WebOnt, but we did not have the effort to put into   resolving the problems (i.e. to coordinate adequately with XML Schema   WG, and to make sure that any solution for these problems in RDF and OWL   does not interfere poorly with work they are doing)    Jeremy        

      Primarily intended for DaveB, Art, Jan.    I attach the beginnings of a declarative approach to triple generation,  and I am interested in what anybody thinks.    It is based on top of the Lexical-Functional Grammar formalism (used by  computational linguists). I hence work from the EBNF form of the grammar  rather than the Infoset form.    I am really interested in responses like, "hmm interesting but here's a  better way :-)"        Jeremy        text/html attachment: lfg-rdf.htm          

      If we get to  >  > 18: Issue: rdf-charmod-resources  >  > See:  >   http://www.w3.org/2000/03/rdf-tracking/#rdf-charmod-uris  >  >    the following message was my last attempt at proposing a resolution:  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Apr/0113.html  (the examples screwed up and can be found in:    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Apr/0116.html    i.e.    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Apr/att-0116/01-charm  od-uri.htm  )    There was some discussion with I18N folks in that thread, which I read as  consent to the proposal.    Jeremy        

        I wrote:  > + Does the WG agree that the new specs should descibe a specific Unicode  > string to be delivered by rdf:parseType="Literal"?    e.g. which ntriples doc corresponds to      <rdf:RDF xmlns:rdf="..."           xmlns:ns="http://example.org/">    <rdf:Description>     <rdf:value rdf:parseType="Literal">        <!-- A comment to add to the confusion. -->        <ns:tag attr1="v1"  attr2="ns:v2"/>     </rdf:value>  </rdf:RDF>      In our discussions we noted:    - M&S is deliberately vague about quite what unicode string corresponds to  the "well-formed" XML [fragment].  - Particular problems are exhibited by XML fragments with non-local effects  (e.g. namespaces, character or entity references)  - In practive the user community is not crying out for a fix. This vagueness  is a theoretical defect with the specs.  - We expect current conforming implementations to represent  rdf:parseType="Literal" values with different strings (different from one  implementation to the next).  - Mandating any specific string value will probably break all  implementations.  - It is desirable to not prohibit old implementations but allow them as a  "lower" quality implementation.  - One way of having two quality-of-service for literals would be to have a  new parseType e.g.  rdf:parseType="Canonical" that forces the use of XML Canonicalization. This  would then be optional.  - rdf:parseType="Canonical" is feature creep and hence out-of-scope.    So maybe, we need to express some words that capture a minimum level of  conformance that is intended to make almost all implementations legal; and  then in the primer we note to document creators that lots of XML Fragments  are likely to be problematic and non-portable.      Jeremy        

      Jos wrote:  > and then there is a match found with  >   {_:x <b> <c>} log:forSome _:x.  > (i have to think about that, and try...)    Jeremy wrote:  > > I didn't quite see how the interpolation lemma worked when the LHS has  > > anonymous nodes.    I was more meaning within the model theory document, rather than within an  abstraction from it. The heart of my question was that there appeared to be  an implicit renaming going on that, IMHO, needed to be made explicit. Your  fix to your logical representation seems to do that. I am not sure what the  corresponding fix to the document should be, or even if there needs to be  one.    Jeremy        

          Scribe note: my first scribblings in IRC were incorrect.  I will try and get the minutes out today, but:      > [[[  > ....  > [14:48:03] jjcscribe Vote: untidy 7, tidy 5.  > [14:48:11] jjcscribe DECIDED: untidy semantics.  > [14:48:22] jjcscribe DanC has outstanding dissent.  > ]]]  >     The vote was closer:    [14:48:38] jjcscribe   (mistake) Vote: 6 to 5     Jeremy        

        [[  The working group particularly seeks feedback on:       o RDF's use of fragment identifiers     o the introduction of internationalized URI's     o the datatyping support proposed     o whether to change the URIREF's for the RDF and RDFS namespaces    The difficulty with this, is that I expect the WG as a whole would agree to  the last two of these, but I'm not sure whether there would be sufficient  support for the first two as you may be the only WG member that has an  issue with those.    Brian  ]]    On internationalized URI's I would not oppose specifically inviting feedback  on this point, but note that www-tag seems to be the better place to discuss  this issue, which is not RDF specific.    Jeremy        

        This action might have timed out ....      Proposed boiler plate. The first two lines should be modified to fit  whatever document. The last sentence also is pretty optional. The crucial  sentence is "Within ...", which is in your face about the non-ASCII  characters    [[  RDF uses absolute URI references extensively.  These are defined in RFC 2396 [*Cite*].  Within RDF, non-ASCII characters may be used as part of  URI references as described in  <a href="http://www.w3.org/TR/rdf-concepts/#section-Graph-URIref">  RDF Concepts</a> [*Cite*].  RDF only uses relative URI references within  the RDF/XML serialization.  ]]    I think the model theory text is fine as is (just a straight import of the  term renaming it on the way).  I personally like the syntax doc too ... uses the term from concepts ...    So partly this text is to put earlier in concepts!    (This is intended to help the other editors, if it is not helpful, ignore  it).    Jeremy        

        > Jeremy, do you have a up-to-date version of our paper, which you  > could send  > me?    The latest version with sources is the version for review on www-archive.    I am waiting for Pat's review comments which I hope to be able integrate  next week, along with Patrick's and my own point about graph equivalence.    I believe all the outstanding changes are hence in the archive somewhere,  but ...      Jeremy        

        I have been fixing a bug in ARP concerning rdf:parseType="Literal".    It was reported by Brian and was triggered by conflicts between the ARP  treatment and that of the Jena version of RDFFilter (Brian did the  rdf:parseType="Literal" code).    Looking in detail, neither parser conforms to the text that I posted  yesterday, despite the liberal intent of that text.    Also, I think that what Brian reported really was a defect, and we might  consider prohibiting it. (Qu: how liberal do we want to be?).    The defect was that ARP does not escape any text in element content in a  literal.  e.g.  <rdf:value rdf:parseType="Literal"><foo><</foo></rdf:value>  is returned as "<foo><</foo>"    I certainly intended when writing the text to permit that. (Although it is a  bad implementation).  However ARP does escape attribute value content so that:  <rdf:value rdf:parseType="Literal"><foo a="<"/></rdf:value>  is returned as "<foo a='<'></foo>"    Para 48 is intended to require that implementations are at least consistent.  And ARP is not, and so should be non-conformant.  [I am, of course, fixing ARP!]    ===  [48]     NOTE: The meaning of 'all' in the above paragraphs is that     an RDF processing environment that makes such a change     in one instance in one literal MUST make the corresponding     change in every instance in every literal.  ===    More, Brian's code does replace the character references more or less as  described in paras [43] and [44].    ====  [43]    - all attribute values can be normalized as in XML      canonicalization viz, replacing :-      . all ampersands (&) with &      . all open angle brackets (<) with <      . all quotation mark characters with "      . all whitespace characters #x9, #xA, and #xD, with character        references.    [44]    - all text nodes can be normalized as in XML      canonicalization viz., replacing :-      . all ampersands are replaced by &      . all open angle brackets (<) are replaced by <      . all closing angle brackets (>) are replaced by >      . all #xD characters are replaced by .  ====    However, he doesn't follow the XML Canonicalization specs, and really why  should he (in the spirit of RECOMMENDING canonicalization but MAYing any  coherent behaviour).    So, I am suggesting weaking [43] and [44] to allow more arbitrary charcter  reference replacements. The final sentence on each, links the two (XML  canonicalization has similar but not identical processing ...).    ====  [43']   - all expanded attribute values can be further processed by replacing any  character with an appropriate numeric characeter reference or an XML  predefined entity reference (i.e. <, >, &, ' or "). All  identical characters MUST be processed identically. If such processing  applies, similar processing MUST be applied to text nodes.    [44']    - all expanded text nodes can be further processed by replacing any  character with an appropriate numeric characeter reference or an XML  predefined entity reference. All identical characters MUST be processed  identically. If such processing applies, similar processing MUST be applied  to attribute values.    ====    Jeremy        

        I have been reading charmod to try and understand what the RDF core  working   group should do vis-a-vis internationalization.    I am multiply posting this to uri@w3.org and www-i18n-comments@w3.org  (It is unclear to me which is the more appropriate forum).    I had some comments on the URI encoding.    These are specifically motivated by the problem of international URIs in  XML Namespace declarations, and I think, give a workable proposal for  how  to resolve the need to escape the forbidden US-ASCII characters in some  contexts but not in others, as well as providing a backwardly compatible  migration path from URI to IRI.    I first give my sense of the problem domain, than my proposal along with   two algorithms, then some comment.    All refs to [RFC 2396] include the extension given by [RFC 2732]     The CHARMOD ref is the last call working draft from early this year.  http://www.w3.org/TR/2001/WD-charmod-20010126    ==============    Problem statement.    (A) When internationalizing URIs, in some contexts it is preferred to       continue to exclude the excluded charcaters of RFC 2396 section  2.4.3,      in other contexts (e.g. XML attributes), other escaping mechanism      make this unnecessary.    (B) In many contexts there is a significant legacy problem, e.g. XML      Namespace declarations. Here the defining specifications require the      use of URIs from RFC 2396. In practice, applications copy strings      without processing them, and hence work just as well with any other      (internationalized) URI specification. But if a document contains      an arbitrary string how should it be encoded. Should a URI-escaping       algorithm be applied or not.    Insight:     Actually URI escaping is not problematic if we never escape '%'.     In this case we can apply URI-escaping to an already escaped, or     to a partially escaped, URI and get the right answer. Thus the      only requirement on URI authors is that they escape literal '%'      as "%25"; they may escape any other characters (although it is     unwise to escape the US-ASCII unreserved characters).    ==================    Proposal:     An IRI is any string in any encoding such that:     + every '%' is followed by two hexadecimal characters '0' - '9'        and 'a' - 'f' and 'A' - 'F'     + applying the IRI encoding algorithm below creates an RFC 2396        URI.             NOTE: representing a literal '%' character in an IRI is         usually done using the string '%25'. All other characters        can usually be represented as themselves.       IRI encoding algorithm (slightly modified from   draft-masinter-url-i18n-05.txt)     1) Represent the IURI characters as a sequence of ISO 10646     characters.  2) If the original encoding was not UCS-based, normalize the character      sequence according to Normalization Form C as defined in [UNI15]      and [IETFNorm].  3) For each character that is syntactically not allowed by the     generic URI syntax (all non-ASCII characters, plus the excluded     characters in [RFC 2396, Section 2.4.3] except "#" and "%"     (and "[" and "]"), apply the following:     3.1) Convert the character to a sequence of one or more bytes          using UTF-8 [RFC 2279].     3.2) Escape each of the bytes in the sequence with the URI          escaping mechanism [RFC 2396, Section 2.4.1] (i.e. convert          each byte to %HH, where HH is the hexadecimal notation of          the byte value using upper case 'A' - 'F' and not lower case          'a' - 'f').     3.3) Replace the original non-allowed character by the resulting          character sequence.  4) For each '%':     - if it is followed by two characters from the set:       { '0' - '9', 'a' - 'f', 'A' - 'F' }       replace by the upper case variants of the two characters.     - otherwise flag an error.      IRI decoding algorithm (for use for human display - not machine   processing)    1) Leave each sequence "%25" unchanged.  2) For every other '%' replace by the byte value indicated by     the following two hexadecimal digits.  3) Leave every other character unchanged.    The output MAY be a UTF-8 encoded string.    =============================    Observations  ------------    By clarifying the special role of '%' it is clear that the escaping  algorithm (which I believe is the usual one) is idempotent. That is,  we do not need to know that it has not been applied before, because  escaping an already escaped IRI has no effect.    It is useful (but not necessary) to be able to reverse such an encoding,  the IRI decoding algorithm does this. Notice the special treatment of  "%31" the encoding of '%'.    A server that needs to fetch a URL (for example) needs to use the normal  RFC2396 decoding algorithm in which '%31' is decoded as '% and the  character  encoding is defined by the server and is not in general UTF-8.    The 2nd step in the encoding algorithm clarifies the *early*  normalization  of UCS-based strings, in accordance with CHARMOD.    URIs that are encoded in a non-UTF-8 encoding can be used as IRI's under  this proposal; however the IRI decoding algorithm will work incorrectly.    Partially encoded IRIs (e.g. such as those encoding the unwise  characters of  RFC 2396) are IRIs under this proposal. Encoding the partially encoded  IRI  has the desired effect of creating a fully encoded IRI, that is  identical  to that reached by fully encoding the completed unencoded IRI.    Any URI (potentially with '%HH' sequences) is an IRI under this  proposal,   and IRI-encoding it leaves it unchanged (except capitilizing any "%hh"   pairs).    The clarification of step 3.2 in the algorithm to use upper case hex  digits  is intended to help in contexts such as RDF in which the binary  comparison  of (encoded) URIs is intended as the test for URI equality.    For URIs intended for servers using non-UTF8 encoding, the IRIs may  encode  % in a way other than %25, and may require encoding of many more  characters.  All such encodings will be compatible with RFC2396, and can then be   IRI-encoded as in this proposal without changing them.        Jeremy Carroll  HP Labs  RDF Core Working Group (this message has NOT been discussed by this WG).        

          Trying to incorporate comments from Pat, Frank and Martin ...      [[  For text that may contain markup, the use of   typed literals   with type rdf:XMLLiteral is suitable.     In such cases, if a language tag is required it must be  explicitly included within the markup, usually   as the value   of an xml:lang attribute.    [XHTML] may be included within RDF in this way.  For mixed content XHTML requiring a language tag  an xml:lang   or lang attribute can be included on an additional span or div element.   ]]        

          > www-rdf-comments  >   o is for process - not general discussion  >   o please let editors or the chairs handle comments process  >   o please keep threads together - i.e. reply to messagage  >  > Any other process issues?  >  >    I am hoping for still greater clarity at the telecon.    In the example of danc-01, danc-02 - I think there is a discussion to be  had, and I want WG involvement in that discussion - should I be having this  discussion:  - on w3c-rdfcore-wg  - on www-rdf-comments  - at the telecon    or all three or what?    Such discussion might result in substantive textual changes.    Jeremy        

            > -----Original Message-----  > From: Dave Beckett [mailto:dave.beckett@bristol.ac.uk]  > Subject: Re: Regrets - 1st Nov  >  > Are you going to have any comments on the syntax WD?  >  > If so, I'd prefer to have anything you've got ASAP so I can edit  > anything in before Friday.  >    So far I have read up to but excluding the grammar (section 7 is it now).    I have a few minor fixes and one substantive change:-    Section 2 must have one of the following changes:  - clearly marked as informative  - moved to being an informative appendix  - deleted (if we were to follow the puritanical minimalist model - which  would be my pref. but I would freely admit that the other docs including  RDF-C&ADM don't follow this)    The minor fixes I have are corrections to section 2 which is occasionally  incorrect. We are unlikely to have found all the bugs, which is why the  change to explicit informative status is imperative.    As a taster:  [[  2.8 "beginning a:Collection"    The example should be change to delete the whitespace between the end of the  ex:prop start tag and the beginning of the a:Collection start tag, so that  the comment cannot be misinterpreted as indicating that the whitespace is  insignificant.  ]]  I think my other corrections are at a similar level of pedantry.    An editorial issue in section 2 is the use of the word value for the object  of a triple. I think this is probably misguided and confusing. I suggest  that we should not use 'value' for anything syntactic - often I believe the  phrases would be better with the word "object".    I hope to send my full comments first thing tomorrow morning.    Jeremy        

          Patrick:  > Are we making it clear somewhere that 'datatype' (unless  > otherwise specified) refers to an instance of rdfs:Datatype?    this looks to me like a model theoretic closure rule, possibly at the RDFS  level (before any specific datatypes are assumed)    i.e.    aaa ppp <datatype>lll .    rdfs-entails    <datatype> rdf:type rdfs:Datatype .      Comments, (Pat?)      Jeremy        

          FYI HP is intending to give a testimonial and probably issue a press release    Jeremy        

            Brian McBride wrote:    > At 20:05 21/11/2002 +0100, Jeremy Carroll wrote:  >   >   >   >> Over early uniform normalization, I am opposed to doing anything other   >> than  >> deletion.  >   >   > Err, might you share with us why?  >     I had tried ... I'll try again:  (previous explanation)       >(Rationale for opposition to non-deletion)   >RDF M&S has these future references on character normalization, and the   >future is still not arrived. I think DaveB tells me that future promises   >shouldn't be in specs; I have come round to that point of view.    Retry.  I support early uniform normalization.  It is about processing and constrains a processing model.  The RDF specs do not have a processing model.  If we wish to have EUN then we either need to invoke some other spec (e.g.   charmod) or define a processing model in order to constrain it (too much   like hard work, tail wagging dog).    Another option is to leave a paragraph like the 5.1 text in, and half   delete it - e.g. make it a note about the future.  This is what happened in M&S and it was, with hindsight, a mistake.    The option of invoking charmod is now dead, so, as far as I am concerned   the best path is a clean deletion of something that I think I would have   really preferred to be in.    Jeremy        

          Sorry I did not give regrets for Friday,  I will also be away this Friday 29th.    I note in the minutes:  [[  The chairs indicated they "are minded" that the next step should be a  second last call.  The late agenda and the absence of jjc prevented a  formal decision.  ]]    I hence give the chairs an HP proxy.  My understanding of discussions I have had with Martin Merry, and others,   is that:    - our concerns our primarily about resourcing  - we fear that a 2nd last call will potentially open up more issues and   hence prevent the WG from completing.    Provisionally, I suggest that the HP vote should be "abstain" I will start   an HP internal discussion where I will argue for my preference which is   "against but not formally objecting".    I am concerned about the level of W3C team influence on this decision.    Jeremy        

        Concepts is now ready for LC2      I have changed a number of the links:    updated Mime type registration link  changed undated W3C links to dated ones (e.g. to rdf-mt and syntax WD)  changed a link to XML schema datatypes to be more conventional in form.    changed a    http://www.w3.org/TR/2002/REC-xml-exc-c14n-20020718.  to  http://www.w3.org/TR/2002/REC-xml-exc-c14n-20020718/    Jeremy        

          FYI I am not available for review of semantics in the next couple of weeks.    Jeremy      > -----Original Message-----  > From: w3c-rdfcore-wg-request@w3.org  > [mailto:w3c-rdfcore-wg-request@w3.org]On Behalf Of Brian McBride  > Sent: 10 October 2003 13:13  > To: pat hayes  > Cc: w3c-rdfcore-wg@w3.org  > Subject: Assessment of semantics bug: [was: Re: proof bug in semantics]  >  >  >  > Hi Pat,  >  > pat hayes wrote:  > >  > > Guys, I have to report a slight disaster.  >  > You did the right thing in bringing this to light immediately.  >  >   Trying to respond to Peter's  > > suggestion that we should provide a clear rule-based criterion for RDFS  > > inconsistency, and to prove the resulting lemma, I found a serious flaw  > > in the proofs of the RDF and RDFS entailment lemmas.  There just wasnt  > > time to get nice versions of the corrected proofs written out by the  > > publishing deadline, so the 10/10 semantics document has some  > ugly stuff  > > in its proof appendix, written in a hurry and with parts of it rather  > > sketchy.  > >  > > I apologize to the WG for this.  >  > It is not your fault.  I had doubts about going to 2nd last call without  > a complete review of the semantics doc.  I suppressed them, which in  > hindsight was a mistake.  >  > That is life.  The world is not a perfect place, and one of the things  > I'm learning is just how hard it is, even for very clever people, to get  > things like proofs right.  I forget what it was like programming in  > languages that didn't do a lot of checking of the program at compile  > time.  This seems like writing in machine code without even a machine to  > test the code on - all one has is testing by inspection.  >  >   I hope to have really nice proofs done  > > by early next week, and they can be editorial tweaks to the final  > > publication version.  > >  > > None of this affects the normative parts of the document.  >  > I think we have to assess how to react to this little problemette.  >  > I think we make life more difficult for ourselves, not easier, if we try  > to rush things through before we are really ready.  We should ask  > ourselves whether we still believe we are ready for lc2.  >  > On the one hand:  >  >    - the proofs are informative - they are there to convince ourselves,  > and others, that the claims we make are justified, e.g. with respect to  > the relationship between the entailment rules and the MT.  >  >    - thus W3C process allows for them to be corrected during last call  > without forcing another last call, provided its just the proof thats  > wrong, not the conclusions.  >  > On the other hand:  >  >    - there are bugs in the proofs - we are not done on the semantics  > document and we have not yet addressed all our issues with it.  The  > latest message from Peter suggests we are not done discussing this yet.  >   By that critereon, semantics is not ready for 2nd last call.  >  > Options:  >  > - go ahead with the second last call announcement  >  > - hold off the second last call announcement till we have sorted the  > problems with semantics (how?).  >  > - go ahead with all except semantics?  >  > Brian  >  >  >        

        What we've actually used is N-triples + (informal) namespaces.    I think an introduction to such an informal notation in the primer, in which  we identify all the namespaces used anywhere in any of the documents would  be OK. ANd then all the documents that want to use the notation. MT is  special because it needs mathematical variables but that's cool, I think the  current text is aimed at a mathematical audience (e.g. starting from section  0) and is clear for such an audience.    e.g.    [[[  In the RDF recommendations examples are often written down in an informal  triples notation. This is related to the N-triples notation used in the test  cases but uses abbreviated namespaces, as in XML qnames, rather than full  URIrefs.  For example, the n-triple:    <http://example.org/#foo> <http://www.w3.org/-the-rdf-url#type>  <http:the-rdfs-url#Property> .    is informally written as:    <eg:foo> <rdf:type> <rdfs:Property> .    Other namespace abbreviations used in the examples are:    rdfd    dc    ...  ]]]    and similarly in the MT Pat could extend this informal notation with  variables.    Informal != unclear.    Jeremy        > -----Original Message-----  > From: w3c-rdfcore-wg-request@w3.org  > [mailto:w3c-rdfcore-wg-request@w3.org]On Behalf Of Frank Manola  > Sent: 19 April 2002 12:04  > To: RDF Core  > Subject: Re: Agenda for RDFCore WG Telecon 2002-04-19  >  >  > I'd like something clarified about this.  First, isn't Test Cases  > normative?  If it is, excluding N-triples creates a bit of a problem  > doesn't it?  Second, isn't what's normative in RDF the graph in the  > mathematical sense?  Both N-triples and the drawings are legitimate  > representations of (mathematical) graphs aren't they?  Finally, it seems  > to me the WG has been fairly consistent in acting as if using N-triples  > actually clarified things.  If that's true, they ought to be great in  > examples!  >  > --Frank  >  > Patrick Stickler wrote:  >  > > On 2002-04-18 22:38, "ext bwm@hplb.hpl.hp.com"  > <bwm@hplb.hpl.hp.com> wrote:  > >  > >  > >  > >>11: How to represent triples in documents.  > >>Propose that triples should be represented using correct n-triples.  > >>  > >>  > >>See:  > >>http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Apr/0251.html  > >>  > >  > > I wouldn't want to see n-triples in the general examples. In the MT  > > section(s) they are more concise than XML, but I've been thinking that,  > > if n-triples are not normative, then we shouldn't have them in any  > > normative sections.  > >  > > Thus, we should use only RDF/XML and graphic representations in the  > > normative sections of all specifications.  > >  > > Patrick  > >  > > --  > >  > > Patrick Stickler              Phone: +358 50 483 9453  > > Senior Research Scientist     Fax:   +358 7180 35409  > > Nokia Research Center         Email: patrick.stickler@nokia.com  > >  > >  > >  >  >  > --  > Frank Manola                   The MITRE Corporation  > 202 Burlington Road, MS A345   Bedford, MA 01730-1420  > mailto:fmanola@mitre.org       voice: 781-271-8147   FAX: 781-271-875  >  >  >        

          [I am having a lot of e-mail trouble today :(  this is a resend, sorry for duplicates]      > describe anything about which one wants to reason using OWL, then I think    > there's potentially a serious architectural disconnect.    As I understand it,      An OWL DL or OWL Lite reasoner reads both the ontology data and the  instance data and interprets them with the OWL abstract syntax (which has  the the section called facts for such instance data:  http://www.w3.org/TR/owl-semantics/syntax.html#2.2  [[  There are two kinds of facts in the OWL abstract syntax.      The first kind of fact states information about a particular individual, in  the form of classes that the individual belongs to plus properties and values  of that individual.  ]]  )    All of these are subject to the bnode restrictions - although there are  subtle differences between those on the unnamed individuals and those on  the description and restriction nodes. I believe the WG endorsed my  comments on the unnamed individuals and not the description nodes - which  is fair enough.    Graham, if you think you have an issue here that is not covered by the  comments Brian has sent, I would suggest you send a personal comment.    Jeremy        

        I am persuaded by Graham's arguments.    Jeremy    > -----Original Message-----  > From: Graham Klyne [mailto:Graham.Klyne@Baltimore.com]  >   [...snip...]  > And finally, I have an implemented code example:  last year, we were   > implementing a mail message archive product, and I persuaded the   > developers   [...snip...]  > at that time).  (BTW, the general idea can be seen in   > <http://public.research.mimesweeper.com/IETF/Messaging/draft-klyne  > -message-rfc822-xml-01c.txt>   > -- this was issued as an Internet draft but has expired.  I do plan to   > re-issue it.)        

      Graham:  > But there's another group here, too:  I'll call them "information  > designers".  This is the category I'd apply to Dublin Core.  And more  > generally, to any group that get's together to define how to describe some  > information in RDF, so I guess that would include the CC/PP and photo  > metadata software I mentioned.  >  > Of course, the really important progress is going to come from a fruitful  > cooperation of software-developers and information-designers.  In the  > scheme of things, I think it's going to be easier for the software  > developers to adapt to the needs of the information designers.  >      DanC:  > If this goes on our issues list, please call it  > "things versus their names".    I guess I see it as about RDF's attitude to (something like) metonymy.  [[[    substituting the name of an attribute or feature for the name of the thing itself (as in `they  counted heads')  ]]]    It is clear that    <eg:doc1.html> <dc:creator> "John Smith" .    is  a less precise model than    <eg:doc1.html> <dc:creator> _:x .  _:x <eg:name> "John Smith" .    What is not clear is that the more precise model is a *better* model.    It would be strange if I had written    [[[  The person who goes by a name with given name which is shortened to "Dan" and with family name which  starts with "C" wrote:  > If this goes on our issues list, please call it  > "things versus their names".  ]]]    But it would have been more precise.    Modelling is about choosing what not to include as much as about choosing what to include.  Usually models should be as simple as possible given the purpose.    The two triple model makes the lack of unique naming explicit. In the one triple model it is  implicit. Since this is a general well known problem with author names it does seem to be often  *better* modelling to not keep repeating this well-known problem.    Clearly supplying a URI for the author then addresses the lack of unique names problem, so that:  <eg:doc1.html> <dc:creator> <urn:John_Smith> .  <urn:John_Smith>  <eg:name> "John Smith" .    will be a more detailed model as long as we have adequate control over the uri space.  For many purposes I think this latter two triple model is better. I am pleased that  the primer starts off with such a case.    (But even so there is a temptation to fall into metonymy by using the URL of someone's web page or  their mailbox to substitute for a URI of the person themselves).    There is also a sense in which there is some overloading going on here.    The current model theory would be fine with dc if the dc folks had chosen to have two properties  dc:creator and dc:creatorName. These could then be related by a rule    aaa <dc:creator> bbb .  bbb <rdf:value> "string" .    iff    aaa <dc:creatorName> "string" .    I see simpledatatype2 as given a formal and precise account of how the overloading in DC works  (using dc:creator with both a literal node and a resource node with related but slightly different  meanings). Overloading is a technique I use everyday when programming and it doesn't worry me.    The current MT by not making sense of overloading and discouraging metonymy makes life easier for  software developers and more difficult for information designers.  Not having a MT, (or equivalently having a MT that no one respects) is unacceptable because the  information designers will continue to use overloading and metonymy and the software developers will  not be able to make sense of it.  Having a MT that accounts for overloading and metonymy allows the software developers to build stuff  that works with the techniques that the information designers use.      <this:msg> <dc:creator> _:aPerson .  _:aPerson employed by              (a company with home page "http://www.hp.com")           with name              (with given name)                     (written in UTF-8 as)                              "Jeremy"              (with family name)                     (written in UTF-8 as)                              "Carroll"        

          > I've explained to Peter this our strategy offlist.    Successfully?    It doesn't seem so.    Jeremy        

          Summary:    - the current model theory      misarticulates the meaning of the triple:   <eg:doc1> <dc:creator> "John Smith" .    - many such triples occur both in the primer      and on the web.    - the model theory should be overhauled along the       lines of Pat's simpledatatype2            I have been looking through the primer, particularly looking  at the Dublin Core examples (throughout the primer).    These seem like perfectly fair examples of how Dublin Core  is used. Unfortunately, there are many instances where  strings are used to represent people and things rather than  themselves. This is not in agreement with the model theory  in which strings denote themselves.    See the end of this message for a list of such strings.    Thus I conclude that either the primer is in need of an   overhaul, or the model theory.    Since the examples follow standard usage, and the model theory   is meant to be merely a rearticulation of what RDF means, I   believe that it is the model theory that is at fault. (Not   Pat's fault, he was merely following the WG's lead).    Within its own terms, the model theory talks about   entailments.  Thus every model theory we have looked at uses an  entailment like:    Premise:   <eg:doc1> <dc:creator> <urn:id:1> .   <eg:doc2> <dc:creator> <urn:id:1> .  Conclusion:   <eg:doc1> <dc:creator> _:blank .   <eg:doc2> <dc:creator> _:blank .    to show that the two documents have the same author.    The current model theory also mandates the following   entailment:    Premise:   <eg:doc1> <dc:creator> "John Smith" .   <eg:doc2> <dc:creator> "John Smith" .  Conclusion:   <eg:doc1> <dc:creator> _:blank .   <eg:doc2> <dc:creator> _:blank .    All Dublin Core users would recognise that it is not  always true that the premise entail that the two documents  have the same author i.e. they would recognise that there   might be two Johns.    The model theory describes necessary truth (not optional   or probable truth), which all uses of all RDF documents  must follow. Given a reading of the conclusion  as the two documents have the same author then,   according to the april model theory  the Dublin Core users are simply wrong in this case.    So, in practice, we have decided to deprecate the single most   common RDF triple    <uri>  <dc:creator> "string" .      This seems a very peculiar decision of any standardization   committee, to deprecate its single greatest use case. If that   is indeed our decision it needs to be both highlighted and   respected in the primer.      Moreover the examples in the primer seem to be very much in  accord with the datatyping proposal that we have not discussed  (simpledatatype2 [1]).  In that proposal a triple like:    <eg:doc1.html> <dc:creator> "Eric J. Miller" .  is read as 'the dc:creator of eg:doc1.html can be written as   "Eric J. Miller"'. The current model theory in contrast  says    'the dc:creator of eg:doc1.html is the string   "Eric J. Miller"'    In essence, the model theoretic problem is that we chose  a strictly typed system, in which strings always represents  strings, instead of a context sensitive typing in which  the type of thing being represented by each string is  determined by the context in which it is used. (This is the  tidy versus untidy debate at a semantic level rather than   a syntactic level).    Context sensitive typing is much more robust against  simplifications in the data modelling used by the RDF author.   Since all data modelling involves simplifications this feels   like a good feature.    I believe that the sheer quantity of these examples in the  primer indicates that this a substantial issue: that RDF, as  deployed, particularly in Dublin Core, does not conform with  the model theoretic changes agreed on the 22nd of February [2].    I believe that we will have great difficulty persuading the   Dublin Core community to stop using string literals to   represent real world entities.     Thus we have a legacy problem, in terms of both legacy data   and RDF expertise of the people writing the data. We can   resolve this either by deprecating the data and persuading   dublin core experts of the error of their ways or by maintaining   backward compatibility along the lines of simpledatatytpes2.     I believe that if deprecation does not cause substantial   problems at last call it will reflect that   + we have failed to communicate the impact of the    model theory on DC usage.  + much of that community is not intending to respect the     model theory.    I suggest that this is an important problem with our current   position on datatyping and that we should reopen the topic   of tidy semantics, with a view to seeing whether  simpledatatype2 can act as a basis to resolve this problem   while retaining as much of the current datatyping work   as possible.    Jeremy    References  ==========  [1] Pat Hayes,   Simple-datatypes-2,  http://www.coginst.uwf.edu/users/phayes/simpledatatype2.html   [2] Aaron Swartz, Minutes of 22nd February  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Feb/0656.html    Appendix  ========    The strings in question are:    strings as people, entities, complex values  ...........................................    "English"  "1501 Grant Avenue, Bedford, Massachusetts 01730"  "Richard Roe"  "Corporation For National Research Initiatives"  "Research; statistical methods"  "Education, research, related topics"  "Library use Studies"  "World Wide Web Home Page"  "Amy Friedlander"  "electronic journal"  "library use studies"  "magazines and newspapers"  "Eric J. Miller"  "John Peterson"  "Sally Smith, lighting"  "Greece"  "Greece"-en  "Grece"-fr  "Garret Wilson"      strings as datatype values  ..........................  [without clarifying that RDF global idiom  only delivers strings.  If the application can interpret these as  values then why wasn't Patrick allowed to   say so?]    "urn:issn:1082-9873"  "August 16, 1999"  "27"  "2"  "2.4"  "127"  "1998-01-05"      Strings where the property name was such as   to suggest a real world entity and a renaming  of the property name might be appropriate.  "tent"  "Overnighter"    "Bedford"  "Massachusetts"  "01730"  "1501 Grant Avenue"    I have worked through some of these examples in  more detail; I might post that if there is interest.   ("English", "Bedford", "Eric J. Miller",    "Amy Friedlander", "1501 Grant Avenue"    "1501 Grant Avenue, Bedford, Massachusetts 01730"    "Corporation For National Research Initiatives"    "Research; statistical methods"    "World Wide Web Home Page")                

      I first raised this here:    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Oct/0013.html      Jeremy        

      >  > On Monday 04 March 2002 09:45, Jeremy Carroll wrote:  > > Under exclusive C14N the literal value is:  > > "\n    <foo xmlns=""  > > xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  > > xsi:type="xsd:decimal">10.09</foo>\n  "  > >  > > because only the xsi and default namespaces are visibly used.  > >  > > I note that in some sense the exclusive C14N has got this example wrong,  > > since we need to preserve the binding of the xsd prefix to preserve the  > > semantics of this example.  Joseph Reagle:  > Hrmm... this is interesting. This is the second of two issues (potential  > bugs) that have been raised this week that we need to give  > serious thought  > to.  > 1. In your email: should we emit a namespace for prefixes found in an  > attribute value (or even element content?!).  >    I note that I was silent through last call on XC14N, so I don't much want to  call it an issue.    What I find counter-intuitive is that foobar is invisible in     xmlns:foobar="http://example.org/foo/bar/"    I understand this. The namespace decl is not in the XPath nodeset, and not  accessible from XSLT. It does not appear to be a requirement of XML  namespaces.    From the document writers point of view, IMO, the obvious response to being  told that xsd is invisible is to reiterate such a namespace decl in my  example:      <eg:bar rdf:parseType="Literal">      <foo xsi:type="xsd:decimal">10.09</foo>    </eg:bar>    map it to      <eg:bar rdf:parseType="Literal">      <foo xsi:type="xsd:decimal"   xmlns:xsd="http://www.w3.org/2001/XMLSchema">10.09</foo>    </eg:bar>    and this doesn't work.    Of course, the RDF group could say that namespace declarations on the  propertyElt (the one with rdf:parseType="Literal") are put on the  InclusiveNamespace PrefixList. That would then be a bit more natural and  less of a change than modifying the "Literal" word as I suggested in:    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Mar/0041.html    This example would then become:      <eg:bar rdf:parseType="Literal"  xmlns:xsd="http://www.w3.org/2001/XMLSchema">      <foo xsi:type="xsd:decimal">10.09</foo>    </eg:bar>    where the RDF parser treats the namespace decl as asserting that   InclusiveNamespace PrefixList = { xsd }  and then canonicalizes the xml literal on that basis.    Doesn't work well with putting the C14N into xml literal equality though.    Jeremy        

            Dominique Haza??l-Massieux wrote:    > Le mer 17/12/2003 09:08, Jeremy Carroll a rit :  >   >>Looking at the QA matrix  >>http://www.w3.org/QA/TheMatrix.html  >>  >>I note the following aspects concerning the RDF PR documents  >>1) RDF Schema does not have conformance clauses  >>  >   > The QA Matrix doesn't claim that it does. Or did I misunderstand what  > you meant?   >       Sorry I was misreading the validator link ...  the link seems to be broken, and as far as I am aware VRP has not been   updated to conform to the latest RDF Schema PR. (i.e. afaik it still harks   back to the old CR from 2000).      >   >>2) The test suite covers aspects of RDF Syntax, RDF Semantics, RDF Schema and   >>RDF Concepts (although it is not a conformance test suite for any of these)  >>  >   > OK, I've added Test Suites entries for these various specs.  >   >   >>3) there is an RDF validator hosted at www.w3.org/RDF/Validator that checks   >>syntax against RDF Syntax, and also some constraints from the abstract   >>syntax, in RDF Concepts  >>  >   > The RDF Validator is now bound to both of these specs.  >   >   >>PS for OWL there is more than one validator, none of which are hosted at the   >>W3C - typically they validate the syntax only  >>  >   > Could you send us the URLs of these services, so that we can link to  > them from the matrix?      Looking at  http://www.w3.org/2001/sw/WebOnt/impls#Implementations    I would suggest  http://phoebus.cs.man.ac.uk:9999/OWL/Validator    as a good online service.    >   > Thanks for the updates,  >   > Dom  >     Jeremy        

      > RDF C14N InclusiveNamespaces  > ============================  > Discussion of this aspect of C14N exclusive.      Under exclusive canonicalization it is possible to specify an  InclusiveNamespace-PrefixList.  http://www.w3.org/TR/xml-exc-c14n#def-InclusiveNamespaces-PrefixList    This lists namespaces that are treated like under inclusive c14n.    If we choose to use exclusive c14n, we can either:  - set this parameter always to null.  or  - provide a syntax for modifying this parameter (e.g. modifying the  attribute value "Literal" of rdf:parseType).  or  - permit applications to set this parameter outside our specs      Of these, I discuss the first two here. The last one is discussed in the  "RDF C14N XML Literal Equality"  message that I will write next.    M&S allows for future groups (e.g. us) to extend the rdf:parseType syntax.  A possible extension is that we could allow the word "Literal" to be  followed by a space separated list of namespace prefixes, e.g. "Literal  xsd".    Hence the example from the earlier message:    <rdf:Description    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"    xmlns:xsd="http://www.w3.org/2001/XMLSchema"    xml:lang="en"    xmlns:eg="http://example.org/">    <eg:bar rdf:parseType="Literal">      <foo xsi:type="xsd:decimal">10.09</foo>    </eg:bar>  </rdf:Description>    Under exclusive C14N with empty InclusiveNamespace-PrefixList the literal  value is:  '\n    <foo xmlns="" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  xsi:type="xsd:decimal">10.09</foo>\n  '    If the author modified the document to:      <rdf:Description    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"    xmlns:xsd="http://www.w3.org/2001/XMLSchema"    xml:lang="en"    xmlns:eg="http://example.org/">    <eg:bar rdf:parseType="Literal xsd">      <foo xsi:type="xsd:decimal">10.09</foo>    </eg:bar>  </rdf:Description>      then the literal value would be (still not getting attribute order right).    '\n    <foo xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema"  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  xsi:type="xsd:decimal">10.09</foo>\n  '      which does not leave the xsd namespace unbound.    Note, that under exclusive C14N there is no other way of forcing the  namespace declaration in the canonical value, other than significant  modification to the XML (e.g. adding a spurious xsd:foo attribute to visibly  use the namespace). In particular, the addition of an explicit namespace  declaration 'xmlns:xsd="http://www.w3.org/2001/XMLSchema"' on the node where  we want it to appear does not impact the XPath nodeset, and does not impact  the canonical value.      Jeremy        

            PatH:    >>Well, if y'all are happy to phrase things this way, then OK; but  >>there is no such thing as a false graph, actually.  >>    D-false surely:    _:a eg:p "foo"^^xsd:string .  eg:p rdfs:range xsd:integer .    Jeremy        

      Syntactic comments only ....    > We   > could encode this in N-triples by having two ways to terminate a   > triple, so that  >   > ex:judy ex:age ex:whatever .  >   > is an asserted triple but  >   > ex:judy ex:age ex:whatever ;  >   > is an unasserted triple.     I would prefer    - <subj> <pred> <obj> .    as an unasserted triple.      > I confess to having no idea how to represent   > something analogous to this in RDF/XML, however.      Liar, (or should that be "balls" :) )  You came up with a number of proposals that all seem fine.    My early preference is ...    >   > Another possibility is to allow certain namespaces to be declared to   > be dark, so that any triple using a property from a dark namespace is   > considered to be unasserted. Again, this does not require any change   > to the syntax, but only some extra conventions to be added to the   > language.   >     This could be a namespace prefix rather than the namespace e.g.      <rdf:RDF xmlns:eg="http://example.org/" xmlns:egdark="http://example.org/"           rdf:darkPrefixes="egdark">       <rdf:Description eg:aserted="foo" egd:unasserted="bar" />    </rdf:RDF>    Jeremy        

          A possible shorter communication to XML Schema WG, indicating two of the  three comments I had on their charter would be:    [[  The Semantic Web Best Practices and Deployement WG is considering creating a  task force [ref to tf description] to address issues relating to the use of  XML Schema datatypes in RDF and OWL.  This is one specific aspect of  encouraging greater interoperability between the Semantic Web  Recommendations and XML Schema Recommendations.    We would appreciate support from the XML Schema WG in addressing these  issues.  Consequently we request that the XML Schema WG charter include a  commitment to work with the SWBPD WG task force addressing them.    Also, since the RDFCore WG is now winding down, we suggest replacing  references to RDFCore with references to the SWBPD WG.  ]]    The third comment, concerning the Cambridge Communique, met opposition in  the CG meeting - I do not intend to press the point. (Although I remained  confused by the opposition, and still believe the paragraph could do with  attention).      Jeremy    > -----Original Message-----  > From: public-swbp-wg-request@w3.org  > [mailto:public-swbp-wg-request@w3.org]On Behalf Of Jeremy Carroll  > Sent: 19 April 2004 18:02  > To: Jeremy Carroll; Guus Schreiber; SWBPD list  > Subject: [XSCH] draft comment on XML Schema WG draft charter  >  >  >  >  > My message quotes from a member confidential document and can be found at:  > http://lists.w3.org/Archives/Member/w3c-archive/2004Apr/0058  >  > maybe Ralph will suggest how we discuss it, without violating  > confidentiality rules.  >  > I would be happy to repost it here with the member confidential quotes  > deleted.  >  > Jeremy  >  >        

        >  > > -  I18N recommend that the RDF graph use Internationalized Resource  > >    Identifiers [IRI] to identify nodes.  >    that then perhaps conflicts with the quoted text from IRI draft and Martin's  comments.    IRI draft:  >   b) Interpretational: URIs identify resources in various ways. IRIs  >      also indentify resources. The resource that an IRI identifies is  >      the same as the one identified by the URI obtained after  >      converting the IRI according to the procedure defined here.  >      This means that there is no need to define the association  >      between identifier and resource again on the IRI level.      Martin:  > For RDF, it would just mean that when you compare,  > you may want to apply it, but you wouldn't convert and stay there;  > you would keep the original.      Unless I hear otherwise, I will interpret Martin's comments in light of the  minuted recommendation above. (i.e. also "we may *not* want to apply it").    Jeremy        

        I sometimes miss my own messages in the following case:    - I am using a non-HP account to send the message  - I fake the from address or set the reply to address as my HP address  - the W3C software accepts the message as legit  - HP firewall software drops the message as a fake    This seems to be an unfortunate interaction between features rather than a  bug!    Jeremy        

        Patrick Stickler wrote:  >>> Section 8.1: "We require [the value of the swp:signatureMethod property]  >>> to be a literal URI, which can be dereferenced on the Web..."  >>> Question, what is the difference between a URI and a literal URI? Do  >>> you mean rdfs:range xsd:AnyURI?  >>  >>  >> xsd:anyURI I think - a literal URI denotes itself in the RDF Model   >> Theory and hence can then be used for dereference operation, whereas a   >> URIref node denotes a resource, presumbably the same resource as that   >> for which you get a representation when you dereference it, but that   >> takes us well into the social meaning issue, that we are trying to   >> skirt around.  >   >   > But wouldn't you be *wanting* to denote the resource, the method itself?  > Otherwise, anything said about that method would not be stated in terms  > of that URI.  >   > I don't think the range/value should be a literal. I think it should  > be the method itself, denoted by a particular URI, which might be  > dereferencable (or might not).    In theory I agree, in practice I don't - let's hear what Pat has to say on   this one. In theory, whenever you use a web dereferencable URI the resource   denoted has a representation that is got by the URI-GET, however that is   not a part of RDF Semantics and I don't think it is for this paper to add it.        >   >>  >>> Also, while requiring the signature method to be denoted by a URI,  >>> I don't think we need to go so far as to require that the URI be  >>> web-dereferencable. It's *convenient* if it is dereferencable, and  >>> it's probably a "best practice" for it to be dereferencable, but  >>> I don't see it as an actual requirement. As long as the publisher  >>> and consumer understand the URI in the same way, that's all that  >>> counts.  >>  >>  >> That's technically correct, however in practice there will only be a   >> handful. For the paper I am inclined to leave it as required, it   >> simplifies the explanation without any real great loss of generality.   >> Without the document it is much harder to write the semantics of   >> signature which does actually depend on the method indicated (and if   >> that method is by private agreement then it is slightly awkward!)  >>  >   > OK. I won't press the issue. Though I think there's as much potential  > for questions/feedback by stating the requirement than by not stating it.  > But I'll accept it as is.  >   Let's hear from Pat.      >     Jeremy        

          This message consists of some examples about untidiness; only the first is  datatyping specific.    1: The book title "1984"  2: M&S first two examples  3: Sergey's example from his "can't live with" message    In general I see a literal node in an RDF graph as denoting something.  Typically, if a greater level of precision is required, that literal node  can be replaced with a resource (URIref node or bnode) and a more complex  description given. The very same string may appear in the more complex  description. In this case the string stands for something else (a part of  its original denotation).    Every data model is an approximation. Different people approximate at  different points.  In the semantic web there are no modelling police preventing different  levels of approximation. We wish to allow free merging of graphs from  different sources. Hence the very same string will denote one thing in one  place, and another thing in another place.    At this stage I am unbothered about whether these differing denotations  occur in the RDF layer or the application layer.      So here goes:    1:    urn:isbn:0451524934 my:title "1984" .  http://giant-redwoods.org/aTree my:age "1984"      in S-B    my:title rdfs:range xsd:string.lex .  my:age rdfs:range xsd:integer.lex .    in TDL    my:title rdfs:range xsd:string .  my:age rdfs:range xsd:integer .    In S-B and TDL an application will want a book title as a string, and an age  as a number. Thus the denotation of "1984" at the application level diverges  in the two triples.  As I understand S-B, the string "1984" can only denote one thing, and so the  reading of my:age "1984" as an integer is incorrect, and the application is  faulty.  This is unacceptable. Sergey please can you clarify how tidiness matches  with divergent application level semantics.    2:    M&S    Very first example      http://www.w3.org/Home/Lassila == Creator ==> "Ora Lassila"    and    Second example      http://www.w3.org/Home/Lassila == Creator ==> _:a    _:a == Name ==> "Ora Lassila"    _:a == Email ==> lassila@w3.org      M&S does *not* indicate that the second is a better modelling idiom than the  first, it addresses "the case that we want to say something more about the  characteristics of the creator"    Suppose we take descriptions of the first kind and mix with descriptions of  the  second kind. In any sort of web we will need to do this sort of thing, since  we  cannot control the modelling techniques of everybody.    In a tidy graph, the sort of interpretation that Sergey appears to want is  that a Creator of one thing is the same as the Name of the Creator of  another.  This is clearly a type error (in the most general sense of the word type).    Of course, a modeller concerned with peoples names is probably dissatisfied  with a Name being a string. Of course a name is in fact a complex object  with parts like firstName, familyName, preferredName, fullName, and (at  least on British driving licenses) commonAliases. I fear that Ora's  preferredName may be "Ora Lassila" as well.    3: Sergey's example    _1 --dc:Title--> "The Origin of Species"  _2 --my:book-->  "The Origin of Species"    Many modellers may use a predicate like my:book to show a relationship  between a subject (a person) and an object they possess (generally a book  they possess).    In which case the following is also plausible:    _2 --my:book-->  _3 --dc:Title--> "The Origin of Species"    This seems to suggest that "The Origin of Species" is both a title of  something and a book. I generally believe that titles are parts of book.      Jeremy        

          Of the issues this afternoon only pfps-09 seems related; the fix for   pfps-09 seems to have introduced this new problem.    I suspect changes like the following might work:    define a datatype interpretation with any partial function from the URIs in   the vocabulary to the set of all L2V mappings;  a datatype interpretation that supports a URI uu as datatype dd is one that   always maps uu to dd;  (essentially have an existential quantifcation over the datatypes)  this would then be monotonic.    Jeremy        Graham Klyne wrote:    > Hmm, yes, it seems problematic.  In particular, it seems to violate:  >   > [[  > General monotonicity lemma. Suppose that S, S' are sets of RDF graphs   > with every member of S a subset of some member of S'. Suppose that Y   > indicates a semantic extension of  X, S X-entails E, and S and E satisfy   > any syntactic restrictions of Y. Then S' Y-entails E.  >   > In particular, if D' is a datatype map and D a subset of D' then if S   > D-entails E it also S D'-entails E, provided that S and E both recognize   > all the datatype urirefs in the domain of D'.  > ]]  > -- http://www.w3.org/2001/sw/RDFCore/TR/WD-rdf-mt-20030117/#dtype_interp  >   > There is also some wording nearby about entailments of inconsistent  >   > Imposing a syntactic constraint on a D-interpretation allowing  >   x rdf:type rdfs:Datatype .  > only if I(x) in D might help, since that would render the antcedent of   > Peter's  first entailment syntactically invalid.  >   > [[  > 1/      xsd:int rdf:type rdfs:Datatype .  >                 {<rdf:XMLLiteral,XMLLiteral>}-entails  >         rdf:XMLLiteral xsd:string rdf:type .  >   > 2/      xsd:int rdf:type rdfs:Datatype .  >                 DOES NOT {<rdf:XMLLiteral,XMLLiteral>,  >                 <rdf:int,int>}-entail  >         xsd:string rdf:XMLLiteral rdf:type .  > ]]  > -- http://lists.w3.org/Archives/Public/www-webont-wg/2003May/0276.html  >   >   > But there's still a question of such statements in non datatyped   > interpretations.  I think that's not a problem because there's no   > constraint there that:  >   x rdf:type rdfs:Datatype .  > is false in all such interpretations, so the first entailment would not   > hold.  >   > #g  > --   >   > At 11:19 16/05/03 +0300, Jeremy Carroll wrote:  >   >   >> On another list, it has been claimed that the current RDF MT editors   >> draft has  >> non-monotonic datatyping.  >> If this is the case then it should be fixed.  >>  >> I will try and review this claim before the telecon today, I suggest   >> others  >> might like to as well.  >>  >> The claim is that when foo is not a supported datatype then  >>  >> foo rdf:type rdfs:Datatype .  >>  >> is inconsistent, and hence entails everything.  >>  >> Thus, supporting an additional datatype foo, negates previously valid  >> entailments, and hence causes a datatyped system to layer   >> non-monotonically  >> on top of a datatyped system.  >>  >> I personally find this a credible critique that should be taken   >> seriously.  >> We may need to leave open any semantics issues affected :(  >>  >> The (cryptic) examples given in  >> http://lists.w3.org/Archives/Public/www-webont-wg/2003May/0276.html  >>  >> concern the minimal datatype system consisting of only rdf:XMLLiteral,   >> and so  >> xsd:int plays the role of foo above.  >>  >> I note that this comment is based on the shadow space draft rather   >> than Pat's  >> master copy - we may hope that magic has happened.  >>  >> Jeremy  >   >   > -------------------  > Graham Klyne  > <GK@NineByNine.org>  > PGP: 0FAA 69FF C083 000B A2E9  A131 01B9 1C7A DBCA CB5E  >         

      Pat:  > The RDF model theory as it stands simply does not support the notion  > of an URI meaning 'the current weather report'. There is no notion of  > 'current'  or 'now' or 'at the time of accessing' in the semantics.    I have tried to keep out of a discussion that seems to me to be a red  herring.    All human communication suffers from the problems being discussed here.    In a more mathematical setting, such as the model theory, we tend to gloss  over some of those problems, by making, generally false, assumptions, such  as time-invariance.    Saussaure and others have made the well-known division of the sign into the  signifier and the signified, and we seem to be struggling over well worn  paths.    For me this boils down to:    RDF makes statements using URI refs as its words, Resources are the things  referred to by these words. All languages that try to refer to a wide range  of things there are philosophical problems with how such reference happens.  In practice, these problems should be ignored (except by professional  philosophers). As in all languages, more or less anything can be referred to  using a URI ref. RDF does not restrict the act of reference in any way. As  in all languages, words that are intended to refer to inappropriate concepts  will be found to be less than useful, but are not illegal.  A concept that is practically useful is appropriate one that isn't useful is  not appropriate.    Pragmatically    Jeremy        

        Uschold, Michael F wrote:  > I'm not talking about mapping the abstract syntax to any triple, just to those triples that are part of OWL [expressed in RDF].   >   > I thought the abstract syntax was just an syntactic variant, therefore the mapping (I would expect) should be, at least for semantic purposes, one to one.  Any differences should not interfere with human understanding, nor machine-processing.   >   > Am I mistaken?      Yes.    (It's very tempting to stop there ...)  Ideally if a1 and a2 are abstract syntax trees and g1 and g2 are RDF graphs   and a1 maps to g1 and g2, and also a2 maps to g1 then at a first   approximation they all have the same OWL DL semantics  (a1 and a2 with the   direct semantics, g1 and g2 with the RDFS compat semantics). So that   "should not interfere" is correct.  However, if what you want to do is to use some OWL Full feature, it is not   clear at all whether or not the (weak and unproven) semantic guarantees   involved in the mapping are appropriate. e.g. foaf uses Inverse Functional   Property on DatatypeProperties.    Basically if what you want to talk about is soemthing to do with OWL Lite   or OWL DL, then the abstract syntax is appropriate, but using it to talk   about dc:creator say does not work because it forces you into making   decisions that are not appropriate for dc:creator.    Jeremy      >   > MIke  >    >   >  -----Original Message-----  > From: Jeremy Carroll [mailto:jjc@hplb.hpl.hp.com]   > Sent:Tuesday, March 30, 2004 11:04 PM  > To:Jim Hendler  > Cc:Uschold, Michael F; public-swbp-wg@w3.org  > Subject:Re: [ALL]  Human-friendly syntax for communicating OWL fragments  >   > As always I share both Jim's and Mike's concerns - despite them disagreeing.  >   > It really doesn't help that the abstract syntax to triples mapping is   > many-to-many ...  >   > Jeremy  >   >   >   > Jim Hendler wrote:  >   >   >>At 20:09 -0800 3/30/04, Uschold, Michael F wrote:  >>  >>  >>>I propose that by convention all OWL fragments are given using the   >>>reader-friendly abstract syntax, rather than the parser-friendly XML   >>>syntax.  Personaly, I cannot read OWL fragments well enough to be   >>>motivated to ever understand the details, so I tend to skip over   >>>them.  Even when I can get motivated, it takes way too much time.  >>  >>  >>I object to this strongly -- that syntax is neither reader friendly nor   >>actually a part of the recommendation.  Much more importantly, we should   >>be creating fragments that people can cut and paste into their documents   >>(and edit) -- forcing them to figure out the mapping from the so-called   >>human readable syntax into actually RDF or OWL (XML or N3) makes no sense.  >>  >>  >>>I would argue very strongly that any public documents published by   >>>this WG  do use the more readable syntax. Why not get used to it when   >>>we communicate with each other? It will also make it easier to grab   >>>things from discussions in the archive and plunk them into documents,   >>>instead of having to translate into the abstract syntax suitable for   >>>the public.  >>  >>  >>I advocate use of "turtle" - which should be the first document this WG   >>approves as a working note (if Dave is willing)  >>  >>  >>>Of course, if the discussion is about parsing, or about the syntax of   >>>the language, then it is better to use the parser-friendly syntax,   >>>both for internal discussions and for publised documents.  >>>  >>  >>what is parser friendly?  >>  >>  >>>What do people think about this suggestion?  >>>  >>>If the overwhelming majority of this WG actually PREFER to read the   >>>parser-friendly syntax, then perhaps I'd best get used to it, but it   >>>there are many like me, it makes sense to use a more reader-friendly   >>>syntax.  >>>  >>  >>well, we could get into whether this is a voting issue for a WG (be   >>careful when you use words like "majority" in a W3C group) but my vote   >>is for N3 (Turtle) which is a nice compromise - or else to stick w/the   >>RDF/XML for cut and paste reasons  >> -JH  >>p.s. Mike - have you noticed our world view doesn't always seem to align   >>:->  >   >         

        Pat Hayes wrote:    >> Jeremy Carroll wrote:  >>  >>>  >>> This is now the submitted version (the PDF is one I have downloaded   >>> from the site, after having uploaded it)  >>  >>  >> Another one.  >>  >> Changes are mainly trivial; the most significant changes are 1   >> substantive change to Pat's text in section 2, and wording alignments   >> between sections 2 and 6.2 (also Pat's text).  >>  >> Acknowledgements now fit.  >>  >> The substantive change is that the old text talked about   >> interpretations of named graphs, and said that if I satisfies g then   >> I(name(g)) = g; I don't believe we interpret named graphs at all,   >> merely the graphs (or a merge thereof) within the named graphs.  >  >  > I don't understand this at all.  (Named graphs are graphs with names,   > right?)  But....  >  A simple example was in 6.2 where you had an interpretation I of a   (named) graph g, I now have an interpretation I of rdfgraph(ng),   conforming with the naming, [where ng is a Named Graph], it is slightly   more precise (and hence uglier). A similar point in section 2 seemed to   me to be more of a change than a clarification.    >>  Hence I have changed this to say that an interpretation conforms   >> with a set of named graphs N if for every ng in N then I(name(ng)) = ng.  >  >  > .... as far as I can see this amounts to the same thing, so I have no   > problem with that change.      OK - we can discuss this later, but the modifications stands in the   submitted text.    >  >> I have followed Chris's suggestion and capitalized Named Graph   >> throughout, but personally I find it ugly.  >  >  > Me too.  Maybe it looks better in German than in English.  >    Again we can postpone discussion of this.    > Pat  >  I am now not expecting to make any further mods.    Jeremy        

          Hi    I've not yet looked at your integration, will do tomorrow.      Latest version of MT, basically complete but I need to do a review.    I think I should move the explanation of idiom P and idiom D from the terse  appendix to the slightly friendlier format of the main text.    The Union appendix needs total rewrite.    Jeremy          text/html attachment: TDL_Model_Theory.html          

              Over early uniform normalization, I am opposed to doing anything other than  deletion.    But ...    Maybe I should look over Dave's text and put the anchor back in somewhere  else. Since even without Early Uniform Normalization (which is a processing  model) we still require that literals and URI refs are normalized (which is  a declarative fact).    (Rationale for opposition to non-deletion)  RDF M&S has these future references on character normalization, and the  future is still not arrived. I think DaveB tells me that future promises  shouldn't be in specs; I have come round to that point of view.    Jeremy      > -----Original Message-----  > From: Brian McBride [mailto:bwm@hplb.hpl.hp.com]  > Sent: 21 November 2002 18:30  > To: Jeremy Carroll; Dave Beckett; Jeremy Carroll; Graham Klyne  > Cc: RDFCore Working Group  > Subject: RE: concept anchors - RE: Minutes: telecon 2002-11-15  >  >  > Is there anything one can usefully say about char normalization,  > e.g. There  > is an issue that should be considered when ... solidifies - and I don't  > mean freezes over :)  >  > Brian  >  > At 17:57 21/11/2002 +0100, Jeremy Carroll wrote:  >  >  > > >     5.1 Character normalization  > > >     http://www.w3.org/TR/rdf-concepts/#xtocid48034  > >  > >character normalization has gone as promised.  > >  > >hence this link is conceptually broken.  > >  > >Any suggestions?  > >  > >Jeremy  >  >        

      >    - parseType=Literal: I think I saw consensus emerging - do we have a  > proposal?      (At least between Dave and me) and I think it is:    [[[  Propose that:  - the exact form of the string value corresponding to any given XML Literal  within RDF/XML is implementation dependent.  - the string value is well-balanced XML that can be inserted as the elment  content between two tags:    <foo></foo>    to form an XML document, satisfying both XML and XML Namespaces.    - taking the exclusive canonicalization of both the original XML Literal in  its containing document, and the string value within the dummy "<foo></foo>"  document produce the same character string. Equality between xml literals is  defined on this basis, but only for the purpose of exercising the test  cases. [Such equality may be used for other purposes but there are  other notions of equality (such as via Inclusive Canonicalization) that  may also be useful.]  - that the canonicalization above is without comments  - that this closes the xml literal and xml literal namespaces issues  ]]]    You raised the subissue of DAML and WebOnt's needs (also MT needs) for  equality.    I added the [Such ... useful.] sentence. IMO we should be leaving wiggle  room for the unusual namespaces to be handled netter next time.    This proposal could be combined with:    Propose that:  - the subissue of interoperable handling of namespaces whose prefixes appear  in attribute values within xml literals without being visibly utilized is  postponed until RDF2.  - we prefer a solution in which a namespace declaration (or redeclaration)  constitutes a visible use  - we prefer a solution which is not reliant on schema processing  - and we action ??? to draw the attention of the appropriate XML WG to this  issue, which we believe is currently not adequately addressable under the  XQuery/XPath 2.0 data model draft. http://www.w3.org/TR/query-datamodel/        

          As we move towards publishing last call (i.e. after approval on 13th Dec), I  propose the following:    0) Ignore link errors between our docs prior to this process.    1) designate an editor of each document who has CVS access to W3C as the  "publishing editor".    2) create a subtree on W3C CVS somewhat like the TR/2002 subtree (but empty)    3) "prepublish" the editors drafts into that mirror tree.    4) for each of the documents update all the links into other RDF Core WD to  be links to that subtree.    5) Run the link checker at this point.     - there should be no links to any of our docs in the real TR space, but  only to our copy of the TR space.    6) Once everything is pubrules happy    7) Take a copy (not CVS) and global substitute the root of our subtree with  the root of the real TR tree.  (a small Unix script can do this)    8) This copy is then given to the publication team.    ===    Requirements:  all docs must be ready on time  all docs must have a publishing editor  unix somewhere    Jeremy        

          Hello    the RDF Core WG made a decision as part of its last call process that we  decided to formally communicate to the I18N WG.    Note, we are still looking forward to your review comments on our Last Call  documents.    The decision made on Friday [1] is to modify the definition of a literal to  exclude the possibility of typed literals having an associated language tag:    [[  > Option 4:  > Language tag is simply dropped from all typed literals including  > rdf:XMLLiteral  >  >    PROPOSE    Concepts is changed to say that a literal can have either a datatype or a  language tag and not both.    rdf:XMLLiteral datatype is changed to have the identity as its lexical  value mapping (no wrapping), with consequential change to the value space of  rdf:XMLLiteral.    Other editors to make consequential changes.  ]]  from [2]    We specifically draw your attention to this being at variance with the  decisions made at the inter-WG meeting at the Cannes Plenary in 2002  concerning the scope of language tags (xml:lang) and embedded XML within RDF  (the rdf:parseType="Literal" construct).    As an example:    <rdf:Description xml:lang="en">     <eg:prop rdf:parseType="Literal"><b>chat</b></eg:prop>  </rdf:Description>    and    <rdf:Description xml:lang="fr">     <eg:prop rdf:parseType="Literal"><b>chat</b></eg:prop>  </rdf:Description>    are given exactly the same representation as an RDF graph and exactly the  same meaning. (Which differs from the Last Call documents in which the  language tag is significant).    The intention in these examples is now expressed as:    <rdf:Description>     <eg:prop rdf:parseType="Literal"><span   xml:lang="en"><b>chat</b></span></eg:prop>  </rdf:Description>    and    <rdf:Description>     <eg:prop rdf:parseType="Literal"><span   xml:lang="fr"><b>chat</b></span></eg:prop>  </rdf:Description>    I have produced a rationale [3] (not endorsed by the WG).    Jeremy, on behalf of RDF Core      [1] minutes (not yet approved)  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2003May/0138.html  RESOLVED: Typed literals option 4 from msg 0086  [2] proposal (#4)  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2003May/0086.html  [3] rationale (personal not WG)  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2003May/0145.html        

        Two minor corrections only.    Brian McBride wrote:    > 2. RDFCore agrees with last call feedback that it received, that      That was actually first call feedback on the abstract syntax.    > building an XML specific mechanism into its core model is architecturaly  > inappropriate - it mixes things that should be independent.  Accepting  > this implies that parseType="Literal" values must use one of the  > existing mechanisms - i.e. either plain literals or typed literals, or a  > new more general mechanism must be invented, e.g. a new triple  > structure.  An XML specific mechanism is undesirable.        >   > 4. Taking the datatype approach creates the opportunity to subclass the  > datatype XMLLiteral, so that the value of a property may be restricted  > to a specific form of XML Literal, possibly specified using XML Schema.      This would be a future extension ... could I suggest adding the word   'future' into this point, on its next iteration.        

      > rdfms-xmllang: Why isn't xml:lang information represented within the RDF  data model?    > This was put on hold whilst we looked at datatypes.  > Model and Syntax says that lang is part of the literal; that no triples  are  > generated for an xml:lang.  We can choose to stick with that or change it.  > Does anyone have a compelling reason to change it?        My proposal before we put it on hold was in the overly long:    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Sep/0378.html    [[[  [1]  An RDF Literal is a Unicode string, optionally paired with a  language tag (as defined in RFC3066).  ]]]    in that thread we identified equally rules as follows:    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Oct/0375.html    suggesting that such pairs are equal    if and only if    the unicode strings are equal  and     the lang tags are either both absent, or both present and equal (as lang  tags, i.e. case insensitive).          This then works orthogonally with:  - the graph syntax  - model theory  - datatyping  - any treatment of Unicode string normalization      Jeremy        

          Ho, hum,    this relates to a number of messages over the weekend (from DanC, Graham   and Pat).    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Dec/0238.html  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Dec/0243.html  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Dec/0253.html  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Dec/0255.html  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Dec/0256.html  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Dec/0262.html    The WG has *not* decided whether or not plain literals without language   tags are or are not xsd:string's.    I believe that the plan is to resolve all problematic datatyping   equivalences after last call, working with XML Schema WG. It would be   stupid if xsd:anyURI was the same as an RDF plain literal, an xsd:string   was the same as an RDF plain literal but that they were not the same.    I don't believe the WG should be pushed into a premature decision on this   topic.    As the exchange between Graham and Dan has shown, the statement in the LCC   concepts:  [[  This set of blank nodes, the set of all RDF URI references and the set of   all literals are pairwise disjoint.  ]]  is crucial, and currently there is no other text in concepts that   contradicts that.  Dan is proposing text that would contradict that, and hence his proposals   on changing the literal definition must be rejected.  Without this, it is impossible to tell the difference between triples    I see this as completely orthogonal to whether or not the literal value   denoted by a plain literal with no language component is or is not a   string, and whether such a string is or is not an xsd:string which seems to   be the heart of the issue.    The quoted sentence is crucial because given a triple we need to known   whether the subject is a bnode or a URIref, and whether the object is a   literal, a bnode or a URIref. Hence concepts distinuishes syntactically   between a plain literal with no language tag and a URI reference by being   clear that the former is not just a string, but is a structure with named   components. Without this, there would also be potential confusion between a   typed literal with no language tag, and a plain literal with a language tag.    Jeremy        

        >  > I propose that:  >  > - The Unicode strings within RDF literals are required to be in NFC.  > - We note that literals whose unicode strings start with a combining  > character may not be serializable in an XML document that conforms with  > forthcoming Character Model Recommendations.  > - We include a test case of such a literal as legal, to be reviewed if  > Charmod reaches rec before we do.  >  >  And that in the definition of the RDF graph we use MUST language, whereas in  the discussion of RDF/XML we indicate that parsers SHOULD use normalizing  transcoders, (with a reference to a CHARMOD WD).    Issue: do we want a note saying that non normalized unicode input MUST NOT  be normalized. (This is one of the safe guards in charmod, but it assumes  that specs are defining a processing model, and we are not).        

            Brian McBride wrote:    > At 13:39 08/05/2003 +0100, Jeremy Carroll wrote:  >   >   >   >> These are for the Option 1 and Option 3, I will keep those names.  >>  >> Both options:  >>  >> PROPOSE reopen  >>   pfps-08 reagle-01 reagle-02  >   >   > This looks like a larger change than I had realised.  >       The reopen these issues is essentially a formal device for indicating that   in my opinion we should notify pfps, reagle, and the others of any changes   to rdf:XMLLiteral that we make.  Option 2, which had no support on the list, makes no changes to XMLLiteral   and hence would not require this.      > Can someone clearly state what advantage is gained from this.  >   > Brian  >       If we were to go with option 3 in particular, (but to a lesser extent   option 1), we have made a change that allows us to be more positive about   pfps-08 - that seems like an advantage.    Having the language tags on the xsd typed literals is decidedly odd - so   option 2 seems like a no-brainer (that really is the small change of just   syntactically omitting semantically irrelevant language tags for the types   other than rdf:XMLLiteral) - we then have to decide whether we are happy to   have rdf:XMLLiteral as both a syntactic and semantic anomolous datatype or   fix it - either option 1 by not having it as a datatype or option 3  by not   having anomolous.    I think either of those are advantageous. Maybe not sufficiently so.    Jeremy        

          At the f2f we identified that there is a one node or two node test case.      Here is the test:      <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"           xmlns:eg="http://example.org/"           xml:base="http://example.org/italiano">      <rdf:Description rdf:about="http://example.org/italiano#%C3%A8">      <eg:first/>    </rdf:Description>    <rdf:Description rdf:ID="?">      <eg:second/>    </rdf:Description>  </rdf:RDF>      This results in a graph with two edges.  The first edge is labelled <eg:first>, the second <eg:second>    Is the subject of the first edge the same node as the subject of the second  edge.    Equivalently, is the above RDF/XML the same RDF graph as:    <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"           xmlns:eg="http://example.org/"           xml:base="http://example.org/italiano">      <rdf:Description rdf:about="http://example.org/italiano#%C3%A8">      <eg:first/>      <eg:second/>    </rdf:Description>  </rdf:RDF>      ===    I suggest the following message:    [[[  The RDF Core WG would like feedback from both the RDF IG and I18N IG about  internationalised URIs.    Within RDF/XML it is possible to create character sequences that are treated  as original character sequences of URIs that involve characters outside  US-ASCII.    RFC 2396, (with the assumption that the character encoding is UTF-8)  provides for a mapping of such character sequences to US-ASCII using the %  encoding algorithm.    Should/do RDF processors perform the %-encoding while reading the file?  Or should the RDF processor use the original character sequence?    This choice impacts the RDF graph corresponding to RDF/XML files in which  both the original character sequence and the % encoded form of the same URI  are used.    Two implementators in the WG report that their implementations do %  encoding, and forget the orginal character sequence.  Early feedback has pointed out that this is inconsistent with treatment in  some other specs (which only do % encoding when getting a resource and test  for URI equality on the original character seqeunce). The same feedback  pointed out that this is inconsistent with the universal practice of not  doing any other URI normalization (e.g. http://www.w3.org ,  http://www.W3.org and http://www.w3.org:80 are all treated as distinct URIs  by all? RDF processors despite being provably functionally equivalent).    For clarity we ask for a yes/no response to the following test case.    We particularly seek feedback from anyone actually using internationalized  URIs in RDF.    An analysis of what M&S says is found at:    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Mar/0012.html    Consider the RDF/XML    ]]]    Then the test case with its associated text.        My message with non-NFC examples may also be relevant, and we may wish to  indicate that somehow.  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Mar/0027.html    Jeremy        

          A very minor point:    Pat Hayes wrote:  > It seems to identify 'access' with 'identify', for example where it says  >   > "A URI must be assigned to a resource in order for agents to be able to   > refer to the resource. It follows that a resource should be assigned a   > URI if a third party might reasonably want to link to it, make or refute   > assertions about it, retrieve or cache a representation of it, include   > all or part of it by reference into another representation, annotate it,   > or perform other operations on it."  >     The quoted paragraph is untrue (the word "must").  OWL permits reference to uniquely identified resources without them   having a URI. (through the use of functional and inverse functional   properties)  Suggest a minimal rewording of insert "easily"  i.e.  "A URI must be assigned to a resource in order for agents to be able to    easily refer to the resource. It follows that a resource should be   assigned a  URI if a third party might reasonably want to link to it,   make or refute assertions about it, retrieve or cache a representation   of it, include  all or part of it by reference into another   representation, annotate it, or perform other operations on it."    Although my preference would be to take Pat's comments seriously which   may require greater rewording.        >> Where does it say that all resources have a unique identifier?  >   >   > Sorry about that last one, I phrased it badly. I know the document does   > not say that resources have a unique URI, ie that URIs cannot converge   > in identification; in fact it explicitly denies it. What I should have   > said is that the idea that resources must be identified by an   > unambiguous URI has no rational basis, etc.. As I have explained in   > earlier emails, with examples, it is not necessary to have an identifier   > for something in order to refer to it.    OWL's use of Functional and InverseFunctional Properties is a simple   example of this, I can flesh this out if it is helpful.    Jeremy        

        I think this is a significant improvement.    Jeremy    (I also hope that resolving DT vis-a-vis webont will clarify whether this  text is a desireable hook or not; and if not I tend to agree with Dan about  not putting it).    > -----Original Message-----  > From: w3c-rdfcore-wg-request@w3.org  > [mailto:w3c-rdfcore-wg-request@w3.org]On Behalf Of Pat Hayes  > Sent: 22 April 2002 22:59  > To: w3c-rdfcore-wg@w3.org  > Subject: suggested wording for removing weasels from MT  >  >  > While re-doing the MT it occurred to me that several scattered  > remarks in various places might usefully be put in one place, and the  > result would have the desirable side-effect of removing the  > 'weasel-wording' stuff about unasserted triples (and all reference to  > unasserted triples from the formal MT tables, appendices, etc.). The  > resulting paragraph would read approximately as follows.  Comments  > solicited, particularly from anyone who has any strong objections to  > the document saying something like this:  >  > -----  > "The model theory assumes that the assertion made by an RDF graph  > consists of the claim that the triples in the graph are true. In  > practice, this assumption may need be modified somewhat. For example,  > the use of a uriref in an RDF graph may be taken as assuming that  > some other RDF  document which is assumed to be the 'definition' of  > the meaning of that term is also assented to by the first graph. In  > this case, the MT should be understood as applying to all the triples  > in both graphs, ie to the merge of the graph with the defining graph  > (or graphs).  Other applications may wish to consider some of the  > triples in a graph, eg those associated with a certain reserved  > namespace, as not being asserted (a status sometimes called a 'dark'  > triple), in which case the MT should be understood as defining the  > intended meaning only of the triples which are intended to be  > asserted.  In other words, the MT should be applied as a meaning  > specification to the triples that are considered to be asserted by  > the graph. In the absence of some external criterion for adding or  > removing triples from consideration, the basic RDF assumption is that  > publishing an RDF document amounts to asserting precisely the triples  > that occur in the graph defined by the document."  > -----  >  > This would be the only mention of 'unasserted' triples in the  > document, and the whole issue of what counts as an unasserted or dark  > triple would be relegated to some other domain of consideration,  > which might be called the operational deployment of RDF in some  > larger context. Anyway it would not be in the MT itself.  >  > OK ??  >  > Pat  > --  > ---------------------------------------------------------------------  > IHMC(850)434 8903   home  > 40 South Alcaniz St.(850)202 4416   office  > Pensacola,  FL 32501(850)202 4440   fax  > phayes@ai.uwf.edu  > http://www.coginst.uwf.edu/~phayes  >  >        

        I wrote:  >+ Does the WG agree that the new specs should descibe a specific Unicode  >string to be delivered by rdf:parseType="Literal"?    Graham wrote:  > I must confess I'm not very clear what this means.    I should clarify (or at least try to :) ).    The old spec M&S seems to be deliberately vague about precisely which  triple is generated by say:    <rdf:Description>    <rdf:value rdf:parseType="Literal"><foo/></rdf:value>  </rdf:Description>    My reading is that it permits    _:anon <rdf:value> "<foo/>" .    and    :anon <rdf:value> "<foo></foo>" .    and    _:anon <rdf:value> "<foo />" .    and    _:anon <rdf:value> "<foo  />" .    etc.    In general, for each feature identify as not in the infoset in XML  Infoset, I think it is plausible to make examples where the old spec is  deliberately ambiguous as to what the triple should be.    Another example, (less silly)    <rdf:Description>    <rdf:value rdf:parseType="Literal"><foo a="a" b="b"/></rdf:value>  </rdf:Description>    My reading is that it permits    _:anon <rdf:value> "<foo a='a' b='b'/>" .    and    _:anon <rdf:value> "<foo b='b' a='a'/>" .        Either we decide to continue this deliberate ambiguity, or we decide to  resolve it.  This is the question I was raising.    The old spec is also quiet about XML comments, XML processing  instructions, XML namespaces, and references.    Maybe that was wise, maybe it was foolish.    Jeremy        

          Reading the minutes, and listening to the Series Editor I will roll back   changes made to concepts in response to our previous consideration of Dave   Reynold's comment.    I think this means that we should be regarding Dave's comment as currently   unaddressed, since there has been no formal resolution to decline the comment.        Jeremy        

            >  > * Jeremy Carroll <jjc@hplb.hpl.hp.com> [2004-05-11 15:01+0200]  > >  > >  > > Is there a group photo somewhere? e.g. from a F2F meeting?  >  > Somewhere near http://www.w3.org/2001/sw/RDFCore/ the  > 1st f2f meeting record has photos, also a group photo from  > hawaii conf has a lot of wg members. My net connection too bad to  > track down details now, sorry...  >  >    Thanks    I think  http://www.w3.org/2001/sw/RDFCore/20010801-f2f/mike-jos-martyn-pat-frank-gra  ham.jpg    was the sort of thing I was after:  title: "The RDF Core WG at work."    (Pity that I am not in it ...)    Anyone know who took it?      Jeremy        

        Thanks, you're right that should have been:    [[ (TDL global#TDL global)    _:n <age> _:a .  <age> <rdfs:range> <xsd:integer> .  <age> <rdfs:range> <xsd:string> .  ]]        The corresponding S-P case is also incorrect (I did copy-paste between S-P  and TDL).    The following    [[ (S-P global#S-P global)    _:n <age> _:a .  <age> <rdfs:range> <xsd:integer.map> .  <age> <rdf:type> <xsd:string.map> .  ]]    should be    [[ (S-P global#S-P global)    _:n <age> _:a .  <age> <rdfs:range> <xsd:integer.map> .  <age> <rdfs:range> <xsd:string.map> .  ]]    > -----Original Message-----  > From: Patrick Stickler [mailto:patrick.stickler@nokia.com]  > Sent: 30 January 2002 13:33  > To: Jeremy Carroll; RDF Core  > Subject: Re: Datatyping Summary - test suite, 2nd attempt  >  >  > On 2002-01-30 14:00, "ext Jeremy Carroll" <jjc@hplb.hpl.hp.com> wrote:  >  > > [[ (TDL global#TDL global)  > >  > > _:n <age> _:a .  > > <age> <rdfs:range> <xsd:integer> .  > > <age> <rdf:type> <xsd:string> .  > > ]]  >  > Looks like a copy-paste error here.  >  > Should this be  >  > <age> <rdfs:range> <xsd:string> .  >  > ??  >  > Patrick  >  >  > --  >  > Patrick Stickler              Phone: +358 50 483 9453  > Senior Research Scientist     Fax:   +358 7180 35409  > Nokia Research Center         Email: patrick.stickler@nokia.com  >  >  >        

          > It occured to me that one likely (and I think accurate) reason why  > rdfs:StringLiteral and xsd:string are different is because the former  > only defines equality of values, not ordered comparisons as does   > the latter. Just a thought...    order over natural lang strings is awkward cf Charmod.    Jeremy        

        > 2.  What are the "standard prefixes" you want in there?    rdf  rdfs    ?  rdfd  eg         http://www.example.org/  dc  daml      Jeremy        

          seeing Jan and Brian's exchange today I note I've messed up the process  here.    So I have already replied to Herman with possible editorial changes, and I  was meant to pass them through this list first ... (so Herman please hold  off replying to my msg on the comments list ...)    So here is my draft (well actual) reply to Herman with two editorial changes  to concepts.    His msg was:    http://lists.w3.org/Archives/Public/www-rdf-comments/2003OctDec/0118.html    Does this look OK?    Jeremy    -----Original Message-----  From: Jeremy Carroll [mailto:jjc@hpl.hp.com]  Sent: 07 November 2003 14:13  Subject: Re: RDF Concepts and Abstract Syntax: two comments        Hi Herman,    treating both comments as editorial ...    "globally"  in section 3.2  http://www.w3.org/TR/2003/WD-rdf-concepts-20031010/#section-URI-Vocabulary    I am uninclined to make too much of this comment, since this section of the  document is intended as less formal introductory text, preceding the more  formal treatment in section 6.    Would the following minor wording change avoid the worst of the problem you  highlight:    Old:  [[, and has no globally distinguishing identity.]]    Suggested replacement:  [[, but has no intrinsic name.]]    the next para talks about blank node identifiers making it clear that such  identifiers are not intrinsic to the node.        On 6.3 Graph Equivalence  http://www.w3.org/TR/2003/WD-rdf-concepts-20031010/#section-graph-equality    I am happy to accept your text as an editorial improvement.    The whole section will read  [[  Two RDF graphs G and G' are equivalent if there is  a bijection M between the sets of nodes of the two  graphs, such that:  1. M maps blank nodes to blank nodes  2. M(lit)=lit for all RDF literals lit which are nodes of G  3. M(uri)=uri for all RDF URI references uri which are which are nodes of G  4. The triple (s,p,o) is in G if and only if the triple (M(s),p,M(o))     is in G'.  With this definition, M shows how each blank node in G can be replaced with  a new blank node to give G'.  ]]    (Omitting the observation about the number of blank nodes, which is obvious)      Please can you reply cc www-rdf-comments@w3.org as to whether these changes  are acceptable.    thanks    Jeremy        

          I will try to stay; but don't want to promise the extra 30 minutes.    Jeremy    > -----Original Message-----  > From: w3c-rdfcore-wg-request@w3.org  > [mailto:w3c-rdfcore-wg-request@w3.org]On Behalf Of Brian McBride  > Sent: 07 November 2002 15:16  > To: RDF Core  > Subject: 60+30 minute telecon  >  >  >  > Hi Folks,  >  > We are clearly very busy at the moment and we have extended the last two  > telecon's.  >  > How would folks feel about scheduling telecons for 90 minutes (we don't  > have to use it all if we are finished) until we are past this busy spell.  >  > This is how I will shape this weeks agenda, but given the short  > notice and  > lack of discussion, folks are free to object and we'll limit ourselves to  > 60 mins.  >  > Brian  >  >        

      I've converted one of the earlier RDF/XML examples with your name in it (as  content).    If the rest of the WG accept these test cases then they will become part of  the RDF specs.    Are you happy with this, or would you prefer me to use a fictional  character?  (Note particularly the first two Black cases about "Dürst" who  clearly isn't you!)    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Apr/0016.html    (Also do you think putting the literals starting with a combining character  into a grey area is satisfactory for the RDF specs? Assuming we get to rec  before you do!)    Jeremy        

          I think the message below (which only explicitly asked about C024 - a   personal comment) might also mark that the RDF Core comments have now been   fully processed. (I suspect they will formally notify us soon - the   comments are marked as "closed" which seems to be the stage before   "notified").    See    http://www.w3.org/International/Group/2002/charmod-lc/SortByOriginator.html#C028    and on a bit.    The ones where we had comments that have not been wholly accepted are:    C029 - we suggested charmod was overly broad in scope, while this comment   was not accepted, comment C035 was reluctantly accepted, which at least   partially addresses our comment (IMO), by not making charmod mandatory for   all W3C recs.    One thing that our initial comment reflects was concern about N-triple   being a ASCII only language. We perhaps ought to review whether we would   like I18N to make any more effort on that subissue.    C030 - we explicitly made an informative comment that we would not object   about. They decided it was not helpful.    C031 - dependency on IRI. They accept the spirit of the comment, but not   our suggestion. They say:  [[         Rationale: Our plan is that the IRI ID, referenced in this section,   will have been submitted for Proposed Standard by the time CharMod moves to   the next stage. IRI equality is fully addressed in the latest IRI ID version.  ]]    ===    I suggest a response along the lines of:  [[  RDF Core has reviewed the current status of the comments C029, C030, C031.  We believe that our concerns under C029 are adequately addressed by the   changes you have made in response to C035. We are disappointed but   unsurprised that our comment C030 was not helpful. We are happy with your   decision on C031 and look forward to both the IRI Proposed Standard and he   Charmod Proposed Recommendation.  ]]    although we might need to check the N-triple issue before saying this.        Jeremy      -------- Original Message --------  From: "Richard Ishida" <ishida@w3.org>    Dear Jeremy,    Many thanks for your comments on the 2nd Last Call version of the Character  Model for the World Wide Web v1.0 [1].  We appreciate the interest you have  taken in this specification.    You can see the comments you submitted on your own account, grouped  together, at  http://www.w3.org/International/Group/2002/charmod-lc/SortByOriginator.html#  C023  (You can jump to a specific comment in the table by adding its ID to the end  of the URI.)    PLEASE REVIEW the decision for the following comment and reply to us within  the next two weeks at mailto:www-i18n-comments@w3.org (copying  w3c-i18n-ig@w3.org) to say whether you are satisfied with the decision  taken.           C024    Information relating to this comment is included below. Note that we will  reply to other comments you sent on behalf of the RDF Core WG at a later  date.    You can find the latest version of the Character Model at  http://www.w3.org/International/Group/charmod-edit/ .    Best regards,  Richard Ishida, for the I18N WG    USEFUL LINKS  ==============  [1] The version of CharMod you commented on:  http://www.w3.org/TR/2002/WD-charmod-20020430/  [2] Latest editor's version (still being edited):  http://www.w3.org/International/Group/charmod-edit/  [3] Last Call comments table, sorted by ID:  http://www.w3.org/International/Group/2002/charmod-lc/        

      Here is a heads-up on where Bill and I have got to.  ACTION: 2001-09-07#5: Jeremy Caroll     Collaborate with Bill dehOra to produce analysis of the literal     problem, options, pros/cons for WG consideration.    We are expecting to continue this action into next week.        The issues we are addressing are:    1: The Representation of Literals        e.g. a pair of a Unicode String and an RFC 3066 language tag.    2: Equality        a complete equality rule for literals, correcting para 217-219 and  para 220, which currently leave parts of equality as undefined.    3: Preferred Mappings under rdf:parseType="Literal"    (of xml document fragments into the representation of [1]).      - Currently para 203 and para 220 are explicitly vague about this mapping.    - We wish to specify one or more preferred mappings.    - We may wish to specify more than one conformance level        + motivation           there are two significantly different use cases              + quoting simply xhtml              + quoting arbitrary XML fragments    4: Cases in which applications may expect problems.    - Older RDF parsers will not be using the preferred mappings,    we should indicate to document writers which XML fragments are likely to  be problematic.      A less ambitious approach would be to not specify a preferred mapping and  simply specify a minimal requirement about some markup that should work  (e.g. embedded xhtml without namespaces and without references). This would  be consistent with M&S and put off the work M&S defers until RDF 2.0.      Questions for WG for tomorrow:  + Does the WG agree that a Literal is a <Unicode String,RFC 3066> pair?  + Does the WG agree that Literal equality should be defined?  + Does the WG agree that the new specs should descibe a specific Unicode  string to be delivered by rdf:parseType="Literal"?    Our current working text for the literal representation is:    ==========    An RDF Literal is* a Unicode string, optionally** paired with a  language tag (as defined in RFC3066).    When comparing two RDF Literals, their Unicode strings must be  equal for the RDF Literals to compare as equal. If both Literals  have language tags, these tags must be equal for the Literals to  be considered equal. If two Literals are found equal but only  one has a language tag, the Literals should not*** be considered  equal.    The equality of Unicode strings is specified by W3C I18N WG;  see [fixme:url]. Language tag equality is defined by RFC3066  and is case insensitive.    ===========  * is represented as, or is a? Do we pass by reference or value :)    ** equivalently we could delete 'optionally' and allow the language tag to  be null, or default to "und" the ISO-639-2 undetermined language. Note, the  following from RFC 3066, suggests 'Omitting'.       5. You SHOULD NOT use the UND (Undetermined) code unless the protocol        in use forces you to give a value for the language tag, even if        the language is unknown.  Omitting the tag is preferred.    ***the purpose of 'should not' is to allow applications some flexibility  on dealing with language tags. That is, when a literal is equal to  another but only one has a lag tag, they can be considered equivalent,  which might be sufficient for some applications to make a match.      The truth table corresponding to that notion of equality is:    Truth table for equality (s1,t1) == string1, tag1; f* means should not  be true; assume s1!=s t1!=t according to the specs in question.            (s,_)  (s,t)  (s1,_)  (s1,t1)  --------------------------------------  (s,_)     t      f*      f       f  (s,t)     f*     t       f       f  (s1,_)    f      f       t       f*  (s1,t1)   f      f       f*      t   (s,t1)  (s1,t)                                       ---------------  (s,t1)    f*     f       f       f      t      f  (s1,t)    f      f       f*      f      f      t            I am about to summarise some discussion between Bill and I on the  rdf:parseType="Literal" question.        Feedback welcome      Jeremy        

          We seem to have consensus on weakening MUST to SHOULD.    Maybe we can remain silent about the areas we still disagree on. In   general, the RDF specs do not specify behaviour on ill-formed input.    I note that the only explanatory text offered anywhere is a pointer to   charmod, so that implementors chosing to permit non-NFC, can only honour   the RFC 2119 requrement to understand the full implications of not   implementing SHOULDs by first reading CHARMOD.        Possible edits:    Syntax:  (latest editors draft  http://www.w3.org/2001/sw/RDFCore/TR/WD-rdf-syntax-grammar-20030117/  )    (IN order searching for "NFC" through the document - all these changes   might benefit from further polish).    change  [[  MUST be a Unicode[UNICODE] string in Normal Form C[NFC]  ]]  to  [[  MUST be a Unicode[UNICODE] string and SHOULD be in Normal Form C[NFC]  ]]    change  [[  MUST be in Normal Form C[NFC].  ]]  to  [[  SHOULD be in Normal Form C[NFC].  ]]    change  [[  This string x MUST be in Unicode[UNICODE] NFC Normal Form C[NFC]  ]]  to  [[  This Unicode[UNICODE] string x SHOULD be in NFC Normal Form C[NFC]  ]]    change  [[  a.string-value MUST be a Unicode[UNICODE] string in Normal Form C[NFC],  ]]  to  [[  a.string-value MUST be a Unicode[UNICODE] string and SHOULD be in Normal   Form C[NFC],  ]]      In concepts  (editors' draft)  http://www.w3.org/2001/sw/RDFCore/TR/WD-rdf-concepts-20030117/  change  [[  The string in both plain and typed literals is required to be in Unicode   Normal Form C [NFC]. This requirement is motivated by [CHARMOD]   particularly section 4 Early Uniform Normalization.  ]]  to  [[  The string in both plain and typed literals is recommended to be in Unicode   Normal Form C [NFC]. This is motivated by [CHARMOD] particularly section 4   Early Uniform Normalization.  ]]    Section 5 datatypes    change  [[  The lexical space of a datatype is a set of Unicode [UNICODE] strings in   Normal Form C [NFC].  ]]  to  [[  The lexical space of a datatype is a set of Unicode [UNICODE] strings.  ]]    Section 5.1 XML Content within an RDF Graph    change  [[  The lexical space  is the set of all strings:  - in Normal Form C [NFC];  - which are well-balanced, self-contained XML content [XML];  ]]  to  [[  The lexical space  is the set of all strings:  - which are well-balanced, self-contained XML content [XML];  ]]      6.5 RDF Literals    change:  [[  All literals have a lexical form being a Unicode [UNICODE] string in Normal   Form C [NFC].  ]]  to  [[  All literals have a lexical form being a Unicode [UNICODE] string, which   SHOULD be in Normal Form C [NFC].  ]]        

          I will not review this today. I hope to have time tomorrow morning.    Jeremy      Brian McBride wrote:    >   >   >   > pat hayes wrote:  >   > [...]  >   >>  >> There are two versions of it. This one  >>  >> http://www.ihmc.us/users/phayes/RDF_Semantics_2004bb.html#defDinterp  >   >   > Diff from PR version @   > http://lists.w3.org/Archives/Public/www-archive/2004Jan/0052.html  >   >>  >> is in my view the clearest exposition.  On the other hand  >>  >> http://www.ihmc.us/users/phayes/RDF_Semantics_2004bc.html#defDinterp  >   >   > Diff from PR version @   > http://lists.w3.org/Archives/Public/www-archive/2004Jan/0053.html  >   >>  >> makes the fewest changes to the PR text so may be preferable for   >> logistical reasons. This only adds the extra vocabulary condition,   >> nothing else.  >>  >> Apart from typo corrections,  >   >   > A quick scan revealed changes in sections 1.4, 2.1, 5.1, Appendix A,   > RDFS entailment lemma, Appendix B and the change log in both versions.  >   > Brian  >         

      There was a TDL one that I missed out last time ...  I probably still have an error or two.    Summary:    A test suite that systematically includes one example of a type error for  each idiom would have 19 files for S, and 6 files for TDL.      Dan wrote:  > Perhaps I don't know what you mean by an implementation.  > Is it different from an RDF 1.0 parser implementation?  > If so, would you please give me a test that a datatypes-capable  > implementation is expected to pass that an RDF 1.0  > parser isn't required to pass?    While parser/processor tests do not exhaust my idea of an implementation it  is a starting point. I try to sketch a test suite for S and a test suite for  TDL, where the test suites are about RDF errors rather more than XML Schema  Datatype errors. e.g. applying two inconsistent type declarations to a  value. Such errors result in an RDF graph that has no models, what a  logician would call an inconsistent graph.    Having said that, it is also clear that there are many possible tests that  are parser oriented, although some will require schema processing.    I will try to list graphs with type errors fairly systematically for both S  and TDL.    (I will use pseudo-ntriple, the ntriple-like language that gets used in our  examples).    I hope these help you understand what I mean by an implementation of S or  TDL.    So an RDF processor, implementing S or TDL as appropriate, with a  pseudo-ntriple parser, and XSD support, and schema support (for those tests  with an rdfs:range) , should reject the following documents:    S error test cases  ==================    [[ (S-A)  _:n <xsd:integer.map> "twenty" .  ]]    [[ (S-B)  _:n <age> "ten" .  <age> <rdfs:range> <xsd:integer.lex> .  ]]    [[ (S-P local)  _:n <age> _:a .  _:a <rdf:type> <xsd:integer.map> .  _:a <rdf:value> "ten" .  ]]    [[ (S-P global)    _:n <age> _:a .  <age> <rdfs:range> <xsd:integer.map> .  _:a <rdf:value> "ten" .  ]]    For each idiom we may have contradictory type information:  [[ (S-A#S-A 1)  _:n <xsd:integer.map> "20" .  _:n <xsd:string.map> "20" .  ]]  [[ (S-A#S-A 2)  _:a <age> _:n .  _:n <xsd:string.map> "20" .  <age> <rdfs:range> <xsd:integer.val> .  ]]  Perhaps this? (Not included in total)  [[ (S-B#S-B)  _:n <age> _:a .  <age> <rdfs:range> <xsd:integer.lex> .  <age> <rdfs:range> <boolean.lex>.  ]]    [[ (S-P local#S-P local)  _:n <age> _:a .  _:a <rdf:type> <xsd:integer.map> .  _:a <rdf:type> <xsd:string.map> .  _:a <rdf:value> "10" .  ]]    [[ (S-P global#S-P local)    _:n <age> _:a .  <age> <rdfs:range> <xsd:integer.map> .  _:a <rdf:type> <xsd:string.map> .  _:a <rdf:value> "10" .  ]]  [[ (S-P global#S-P global)    _:n <age> _:a .  <age> <rdfs:range> <xsd:integer.map> .  <age> <rdf:type> <xsd:string.map> .  ]]      S also has a range of error conditions when two idioms are intermixed.    [[ (S-A#S-B 1)  _:a <age> _:n .  _:n <xsd:integer.map> "20" .  <age> <rdfs:range> <xsd:integer.lex> .  ]]  [[ (S-A#S-B 2)  _:a <age> _:n .  <age> <rdfs:range> <xsd:integer.val> .  <age> <rdfs:range> <xsd:integer.lex> .  ]]  [[ (S-A#S-P global 1)  _:a <age> _:n .  _:n <xsd:integer.map> "20" .  <age> <rdfs:range> <xsd:integer.map> .  ]]  [[ (S-A#S-P global 2)  _:a <age> _:n .  <age> <rdfs:range> <xsd:integer.val> .  <age> <rdfs:range> <xsd:integer.map> .  ]]  [[ (S-A#S-P local1)  _:a <age> _:n .  _:n <xsd:integer.map> "20" .  _:n <rdf:value> _:foo.  ]]  [I find this next one really counterintuitive].  [[ (S-A#S-P local2!!!)  _:a <age> _:n .  _:n <xsd:integer.map> "20" .  _:n <rdf:type> <xsd:integer.map>.  ]]  [[ (S-A#S-P local 3)  _:a <age> _:n .  <age> <rdfs:range> <xsd:integer.val> .  _:n <rdf:type> <xsd:integer.map>.  ]]  [[ (S-B#S-P global 1)  _:n <age> "10" .  <age> <rdfs:range> <xsd:integer.map> .  ]]  [[ (S-B#S-P global 2)  <age> <rdfs:range> <xsd:integer.lex> .  <age> <rdfs:range> <xsd:integer.map> .  _:n <age> _:a.  ]]  [[ (S-B#S-P local1)  _:a <age> _:n .  <age> <rdfs:range> <xsd:integer.lex> .  _:n <rdf:value> _:foo.  ]]  [[ (S-B#S-P local 2 - not included in total)  _:a <age> _:n .  <age> <rdfs:range> <xsd:integer.lex> .  _:n <rdf:type> <xsd:integer.map>.  ]]      TDL error test cases  ====================      [[ (TDL global 1)  _:n <age> "ten".  <age> <rdfs:range> <xsd:integer> .  ]]  [[ (TDL global 2)  _:n <age> _:a .  <age> <rdfs:range> <xsd:integer> .  _:a <rdf:value> "ten" .  ]]  [[ (TDL local)  _:n <age> _:a .  _:a <rdf:type> <xsd:integer> .  _:a <rdf:value> "ten" .  ]]  [[ (TDL local#TDL local)  _:n <age> _:a .  _:a <rdf:type> <xsd:integer> .  _:a <rdf:type> <xsd:string> .  _:a <rdf:value> "10" .  ]]    [[ (TDL global#TDL local)    _:n <age> _:a .  <age> <rdfs:range> <xsd:integer> .  _:a <rdf:type> <xsd:string> .  _:a <rdf:value> "10" .  ]]  [[ (TDL global#TDL global)    _:n <age> _:a .  <age> <rdfs:range> <xsd:integer> .  <age> <rdf:type> <xsd:string> .  ]]    Both TDL and S-P may have some ill-formed triples with rdf:value and URIref  nodes. Unfortunately neither document is clear enough to say which. The  problems are identical and so plague both proposals equally.    The test cases were generated by:    take each idiom      generate a single instance type error      generate a type error from multiple incompatible type information      take each idiom pair      generate a model theoretic error by making poor combinations of them      (For all the idioms in both proposals, it would be worth having OK test  cases with multiple compatible types. They all permit it).    Jeremy        

          It does seem reasonable to suggest that anyURI in XML Schema datatypes is  the current "standard web identifier".    This points to    http://www.w3.org/TR/xlink/#link-locators    which basically is the position I would like us to endorse (+ binary  compare).    [[[  The value [..snip..] must be a URI reference as defined in [IETF RFC 2396],  or must result in a URI reference after the escaping procedure described  below is applied. The procedure is applied when passing the URI reference to  a URI resolver.    Some characters are disallowed in URI references, even if they are allowed  in XML; the disallowed characters include all non-ASCII characters, plus the  excluded characters listed in Section 2.4 of [IETF RFC 2396], except for the  number sign (#) and percent sign (%) and the square bracket characters  re-allowed in [IETF RFC 2732]. Disallowed characters must be escaped as  follows:    + Each disallowed character is converted to UTF-8 [IETF RFC 2279] as one or  more bytes.    + Any bytes corresponding to a disallowed character are escaped with the URI  escaping mechanism (that is, converted to %HH, where HH is the hexadecimal  notation of the byte value).    + The original character is replaced by the resulting character sequence.    Because it is impractical for any application to check that a value is a URI  reference, this specification follows the lead of [IETF RFC 2396] in this  matter and imposes no such conformance testing requirement on XLink  applications.    If the URI reference is relative, its absolute version must be computed by  the method of [XML Base] before use.  ]]]      Sorry Dan I am not going to reply to your counter-counter proposal - it  seems surprisingly out of scope!    Jeremy    > -----Original Message-----  > From: Dan Brickley [mailto:danbri@w3.org]  > Sent: 22 March 2002 11:03  > To: Jeremy Carroll  > Cc: bwm@hplb.hpl.hp.com; w3c-rdfcore-wg@w3.org  > Subject: IRIs as node labels (proposals and counterproposals)  >  >  >  > (changed subject line)  >  > On Fri, 22 Mar 2002, Jeremy Carroll wrote:  >  > > > 14: IRI's  > > > Wheras nodes in an RDF graph are labelled with URI's and the  > > > standards for internationalization of URI's are not yet stable  > > >  > > > Propose the WG:  > > >  > > >   1) resolves that nodes in RDF graphs are labelled with standard  > > > web identifiers  > > >  > > >   2) resolves that the current standard web identifier is a URI  > > > as defined by RFC 2396  > > >  > > >   3) resolves that resolution 2 above may be updated by an errata  > > > to the specifications as new standards evolve.  > > >  > >  > > This is unclear. First my counterproposal, second a critique of  > the chair's  > > proposal.  > >  > > Counterproposal.  > >  > >  Propose the WG:  > >  > >    1) resolves that nodes in RDF graphs are labelled with standard  > >       web identifiers  > >  > >    2) resolves that the current standard web identifier is a URI  > >       as defined by RFC 2396, in its original character sequence  > >       (in UTF-8)  > >  > >    3) notes that the use of identifiers of resolution 2 that are  > >       not in normal form C presents internationalisation  > >       difficulties and security risks  > >  > >    4) resolves that resolution 2 above may be updated by an errata  > >       to the specifications as new standards evolve.  > >  > >    5) that equality between the identifiers of resolution 2 is  > >       binary identity.  >  > I have a counter-counter proposal:  >  >  > (this goes beyond the IRI issue, and is motivated in part by my  > exploration of the SOAP 1.2 Encoding Data Model, which uses XSD datatypes  > but doesn't label nodes with URIs)  >  > Propose the WG:  >  > 1) resolves that Web identifiers, like other characteristics of a  >    resource, can be considered properties of the the resource  > that they name  >  > 2) notes that RDF now provides datatyping facilities which can use  >    XML Schema datatypes (such as xsd:anyURI)  >  > 3) notes that RDF currently provides a privileged role for URI referring  >    expressions. Nodes in an RDF graph may be labeled using RFC2396 URI  >    references to indicate the resource that they represent.  >  > 4) further notes that this same information can be represented in a number  >    of ways using RDF properties, and that at this time RDF Core provide  >    no specific guidance on the representation of URI node labels as RDF  >    properties, or on equivalencies between these two strategies for  >    representing web identifiers in RDF.  >  > 5)  >    resolves that future revisions to RDF could accomodate IRI referring  >    expressions using a named property or datatyping convention.  >  > 6)  >    notes that labeling RDF graph nodes with new kinds of referring  >    expression (for eg. RDF definite descriptions) might be proposed as a  >    design feature for any hypothetical RDF 2.0 effort. The simpler case  >    of URI resource identifiers can be addressed using RDF's existing  >    property and datatyping machinery.  >  >  >  >  > Hmm, if this is true I ought to my moneyHH^Htestcases where my  > mouth is.  >  > I also have another argument (related to reification) in favour of our  > doing URIs as properties, but it'd be a distraction to include here  > (and probably a distraction from shipping Core in a timely fashion).  >  > Dan  >  >  >  > --  > mailto:danbri@w3.org  > http://www.w3.org/People/DanBri/  >  >        

      Patrick:  > Ahhh... here's where it gets really interesting...  >  > Do we mirror this derived type definition in the RDFS defined  > class hierarchy? I.e., do we need to define xsd:integer and  > xsd:string as a subClassOf xxx:size, so that folks can  > define values such as [ rdf:value "1"; rdf:type xsd:integer ]  > for properties with a range of xxx:size?  >  > Or should an RDF/RDFS engine testing range constraints also  > be an XML Schema data type engine able to parse and understand  > native XML Schema derived type defintions?  >    My proposed XML Schema/RDF Schema/RDF integration is showing in the examples  I sent an hour ago:    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Nov/0198.html    Basically the XML Schema sits in one file, and the RDF or RDFS refers to it  in some way (e.g. using its URL or using xsi:schemaLocation).    In this framework RDFS *does not* duplicate any of the mechanisms of XML  Schema but merely uses them (in external XML Schema files).    This is me trying to play by the charter; we might want to conclude that  this is sufficiently messy that the charter should be interpreted more  liberally.    Jeremy        

          I agree - this is the correct practical algorithm, I'll see if I can get   some text in there.    i.e. the URI is the base URI in scope on the outermost RDF element of the   document (typically the rdf:RDF of an RDF/XML or OWL document). This may be   the xml:base or the retrieval URI of the document.    Jeremy            Patrick Stickler wrote:    >   > On Apr 07, 2004, at 17:10, ext Chris Bizer wrote:  >   >> Hi,  >>  >> I updated the draft for the Named Graph homepage and included the   >> comments  >> from Patrick and Jeremy. I also added RDF/XML as a third possible   >> syntax for  >> Named Graphs to section 3:  >>  >> 3.3 RDF/XML  >>  >> A collection of RDF documents can be seen as a set of Named Graphs. This  >> gives Named Graphs upward compatibility with RDF/XML, but has the  >> disadvantage that retrieval URL, document name and graph name are   >> mixed up.  >   >   > I've been chewing on this a bit more recently, and I still think that it  > makes alot more sense to derive the name of an RDF/XML encoded graph based  > on the xml:base value *of the root <rdf:RDF> element*.  >   > Yes, it is true that any element in the RDF/XML can have its own xml:base  > attribute defined, but there can be at most one such attribute defined  > for the <rdf:RDF> element, so there's no ambiguity there.  >   > And since the xml:base value need have no correlation to the URI via which  > the RDF/XML instance was obtained, we avoid the URI denotation ambiguity  > otherwise introduced by taking the access URI as denoting the graph.  >   > Otherwise, I'd prefer to simply state that there is no obviously correct  > and reliable means to associate a graph name URI with an RDF/XML instance  > in the instance itself, and avoid (being misunderstood) proposing that  > the access URI be used (which I think is a mistake/hack/etc.).  >   > Thus,  >   > <rdf:RDF xml:base="http://example.org/foo" ...>  >    ...  >    <rdf:Description xml:base="http://example.org/bar" ...>  >    ...  > </rdf:RDF>  >   > equates to  >   > <http://example.org/foo> {  >    ...  > }  >   > Note that the second xml:base on the description element has  > no affect on the name of the graph.  >   > Also, this works even when mulitiple RDF/XML fragments are  > embedded in the same e.g. XHTML document, since each root  > <rdf:RDF> element can have its own xml:base value and hence  > a distinct name.  >   > We'd restrict the interpretation of xml:base to explicit  > attributes occurring on the root <rdf:RDF> element, not  > inherited from a higher XML scope.  >   > Eh?  >   > Patrick  >   >   >   >>  >> Chris  >> <NamedGraphsPage.zip>  >   >   > --   >   > Patrick Stickler  > Nokia, Finland  > patrick.stickler@nokia.com  >         

            > FWIW, I'm having a separate discussion with Martin Duerst about this issue  > with respect to CC/PP (an application of RDF);  Martin seems to think the  > XML system identifier rules should apply to URI values in RDF -- I'm  > pressing for clarity about why this is so, given that URIs per se cannot  > contain non-US-ASCII characters.  >     I think this is a no-brainer from an internationalization point of view.    When a non-English speaker wishes to write a meaningful rdf:about or  rdf:ID value then they will use non-US ASCII characters.    Since URIs are US ASCII somewhere someone has to do the conversion, and  the %HH encoding of UTF-8 is the correct conversion to do.    It is necessary for a spec to say who does the conversion, and given  that RDF/XML is meant to be (barely) end user readable, it should be in  their language. Hence the RDF/XML processor needs to do the conversion.    Jeremy        

            Hi,    the relatively new Semantic Web Best Practices and Deployment Working Group,  has started a task force with the remit of looking at:  - the relationship between the value spaces of the primitive simple types,  when used in the Semantic Web  - in RDF and OWL, what URIs can be used for user-defined XS simple types.    The current draft task force description is found at:  http://lists.w3.org/Archives/Public/public-swbp-wg/2004Apr/0199    (pending edits are: add Evan Wallace and Pat Hayes as TF members, add test  cases to the deliverables - note the '2 additional from XML Schema WG' is  indicative not intended as a limitation)    We agreed to formally invite you to participate, but I believe that  invitation has no yet been made ... :(    However, given that some of the TF participants and potential participants  will be at WWW2004 in New York next week, it seems like a good opportunity  to get the ball rolling.    I think it would be good for participants and potential participants in such  a task force to get together informally to discuss what we might do, and to  try and understand where we are all coming from. I am imagining a discussion  over a beer one evening, or a BoF table one lunch time ...    (I see that many of you are already in the area for your F2F, I will be  getting in Monday evening, which would hence be the earliest I can do)    Jeremy        

            Sandro Hawke wrote:    Frank wrote:    >>Concepts Rec CVS 1.70  >>---------------------  >>  >>SOTD:  This SOTD is the same as that in the Primer;  there is nothing   >>here that indicates the normative status of the Concepts spec.  All the   >>links and other material seem OK.  >>  >>References:  seem OK  >>  >>In the Change Log, under "References", there's a "TODO" at the end.  To   >>reduce confusion, this should probably either be done or removed.  >>  >   > I like this change.      Thanks for catching that - I can't remember what was todo, but either it ot   done or it didn't!    Jeremy        

      > RDF C14N Comments  (A)  > =================  > Discussion of XML comments in C14N, and xml-literals in RDF.      An easy binary choice is whether the C14N for xml-literals should preserve  comments or strip them.    e.g. given the following RDF/XML    <rdf:Description    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"    xmlns:dc="http://purl.org/metadata/dublin_core#"    xmlns="http://www.w3.org/1999/xhtml"    rdf:about="http://example.org/papers/paper1">    <dc:Title rdf:parseType="Literal"><!-- Relevant text start. -->      Foo<em>bar</em>    <!-- Relevant text end. --></dc:Title>  </rdf:Description>    Is the generated graph:    <http://example.org/papers/paper1> <dc:title> "<!-- Relevant text  start. -->\n    Foo<em xmlns="http://www.w3.org/1999/xhtml">bar</em>\n  <!--  Relevant text end. -->" .    or    <http://example.org/papers/paper1> <dc:title> "\n    Foo<em  xmlns="http://www.w3.org/1999/xhtml">bar</em>\n  " .    C14N allows both forms, and the RDF Core WG should decide which (or decide  that RDF applications decide which).  (Note I have used exclusive C14N with an empty InclusiveNamespaces Prefix  List).    Jeremy        

          If we are short of things to discuss, the I18N comment that is still brewing  surfaced here    http://lists.w3.org/Archives/Member/w3c-i18n-ig/2003Nov/0008.html    (member only link)    I find the Alt argument the most interesting of the things we haven't seen  before; it would be interesting to know if the WG would be happy to make the  change Martin suggests (no default, all items have equal weight)    I understand that they have asked for an extension, so this looks critical  path given the good status of the rest of the comments ....    The other comments either are editorial or the expected substantive comments  on XMLLiteral.    If we have a full agenda we should hold off discussing this comment until it  is made.    >  > This is the usual weekly call for agenda items.  >  > Suggestions to the list please.  >    Jeremy        

        This looks correct to me.  Jeremy    Dave Beckett wrote:    >>>>Jeremy Carroll said:  >>>>  >>See:  >>  >>http://lists.w3.org/Archives/Public/www-archive/2002Dec/att-0029/00-rc  >>  >>Note - I have not yet agreed the following change with Graham.  >>new section 3.7, old section 2.5  >>3.7 RDF Core URI Vocabulary and Namespaces (Normative)  >>  >>(In the agreed change it was unclear where it went).  >>  >>Note2 - indentation in ToC is incorrect.  >>  >   > [ I note TOC 4 has a 2.4.2 under it ]  >   > So in summary the renumbering was  >   1.2 deleted  >   2.3 => 3  >     2.3.5 deleted, 2.3.6=>3.5, 2.3.7=>3.6  >   2.4 => 4 [reordered subsections]  >   2.5 now 3.7  >   3 onwards => 5 onwards  >   > can you confirm, check this; maybe add in a changes note/email.  >   > So all the structuring and renumbering is done now?   >   > Can I update my references now?  >   > Dave  >   >         

          I am happy with my name on that ... if it adds no value having the WG   endorse it then let's leave it at that.    Jeremy      Graham Klyne wrote:    >   > At 15:53 18/02/04 -0600, Pat Hayes wrote:  >   >>> However, I would not object to being a co-signatory on your suggested  >>> textual change.  >>  >>  >> I agree with Graham that this is a potentially serious problem that we   >> should nip in the bud. I also would like to be a co-signatory on the   >> proposed textual changes; Graham, please include me. I particularly   >> like the inclusion of the phrase " for purposes of retrieval" as it   >> acknowledges that URIs have other purposes.  >   >   > OK, here's what I propose:  >   > [[[[  > Further to my earlier message [1], I've discussed the issue of URI   > normalization with some colleagues and we'd like to propose the   > following small change of wording with respect to [2] (announcement [3]):  >   > ...  >   > Section 6.1, para 2, final sentence:  >   > The suggested change is to this sentence:  > [[  > Therefore, comparison methods are designed to minimize false negatives   > while strictly avoiding false positives.  > ]]  >   > To be:  > [[  > Therefore, comparison methods are designed to minimize false negatives   > while strictly avoiding false positives when used for purposes of   > retrieval.  > ]]  >   > Rationale:  >   > This reinforces the earlier comment that "URI comparison is performed in   > respect to some particular purpose" [section 6 intro], and I think   > provides the necessary get-out for those purposes other than retrieval   > for which the normalization processes described can result in false   > URI-equivalence (i.e. in circumstances where existing applications may   > legitimately deliver differing results).  >   > Graham Klyne  > Jeremy Carroll  > Pat Hayes  >   > [1] http://lists.w3.org/Archives/Public/uri/2004Feb/0094.html  >   > [2]   > http://www.ietf.org/internet-drafts/draft-fielding-uri-rfc2396bis-04.txt  >   > [3] http://www.ietf.org/mail-archive/ietf-announce/Current/msg28902.html  >   > ]]]]  >   > The IETF debating culture is slightly different, so the multiple   > signatories count for less than the quality of the argument, but I don't   > think it harms.  >   > #g  >   >   > ------------  > Graham Klyne  > For email:  > http://www.ninebynine.org/#Contact  >         

        DaveB  > Whoa! #2 - this is far too much to take in.  > It is too early to approve it.    OK.        > After a quick scan:  >  >  * What Issues do all these points address?  Please re-order by  >    issue.  If they address none, why are they there?    I won't do the re-ordering immediately, although that's a good idea.    I will try and enumerate the issues.    From the charter:  > clarifications and improvements to the specification of   > RDF's abstract model and XML syntax.    and    > the RDF Core WG must provide an account of the relationships between   > the basic components of RDF (Model, Syntax, Schema) and the larger   > XML family of recommendations.    From the issue list:    rdfms-literal-is-xml-structure    rdfms-xmllang    rdfms-xml-literal-namespaces        I interpret the "clarifications and improvements" part to include  looking at semi-finished parts of M&S and clarifying them, particularly  in the light of charmod which is a useful document, which the M&S  writers appear to have been expecting and wanting to conform to.    Literal equality is a key issue overtly labelled as unfinished in M&S.  M&S fudges equality on both xml literals (where it is explicity silent)  and Unicode strings (where it refers to an unwritten document from I18N  WG - charmod)  Since M&S was written there have been important advances in XML  technology like infoset and canonicalization, and Unicode normalization.    All the normalization stuff is there to support literal equality in  accordance with charmod, in a way that is appropriate for a world-wide  standard.    The stuff to do with URI pairing is there to leave a door open if that  is a good way to go for XML Schema datatypes         >  * It seems to require changing existing software in unclear ways.    Yes, it seems so, but no, no change is necessary for most software.  Areas where change may appear to be necessary:    xml:lang       - no longer optional for RDF/XML processors       - xml:lang comparison is case insensitive         It always was, just not highlighted as such.       - RFC3066 support; yes that is a change which does break some          software.         However that change has been made by XML 1.0 second edition.      normalization form C  http://www.unicode.org/unicode/reports/tr15/       " Implementations of Unicode which restrict themselves to a          repertoire containing no combining marks (such as those that          declare themselves to be implementations at Level 1 as defined          in ISO/IEC 10646-1) are already typically using Normalization          Form C "    I think all RDF implementations hence are already using NFC ;-)      early normalization         This does put a burden on document writers who wish to use a          "repertoire containing combining marks".         Since the current specs mean that such authors can't reliably          use RDF, this burden is an improvement.         Implementators of anything other than systems that create         RDF documents in "repertoires containing combining marks"         are not burdened. In particular RDF/XML processors are only          restricted by MUST NOT-ing further normalization, which         actutally prohibits implementators from working harder!       XML Canonicalization of literals         This is deliberately not a MUST.      >  >  * No implementations (I want more than one)         At some level there is only XML Canonicalization to implement.         (Well, OK, hardly 'only').                >  >  * Hypothetical future work (stuff like "RDF Core WG  >    may in future ...  One example is ").  Delete these.      Hmmm ...    I am trying hard to leave the xml schema datatypes issue as unresolved.  Paras [2] and [3], which you appear to be referring to are to make that  explicit.    This document is intended for the WG rather than outside consumption;  although I would hope that large chunks of it could be appropriately  copied verbatim into working drafts; I would agree that paras [2] and  [3] are not such text.      >  >  * Repeats things from other documents e.g.  "the usual XML  >    processing rules" then includes some rules - should cite them    I would value feedback as to where I can do that, I take it you refer to  the rather laborious treatment of the range of freedom that an  implementation has in representing an XML Literal. I had a lot of  difficulty with finding documents to cite, because the XML specs  actually specify what you can do, whereas M&S didn't and hence anything  goes.    With early uniform normalization I have tried to articulate what charmod  means in an RDF context.  I don't really think it would suffice to simply say that we follow early  uniform normalization as given by charmod, without thinking it through,  and articulating that process.      --------------    I also remind everyone that xml:lang is a bit of an afterthought,  because the first WG did not consider internationalization issues until  they rushed it under pressure from the I18N WG. I have tried to give a  coherent account of how charmod applies to RDF Literals; I suspect it is  better to do it now, when we can take our leisure (despite my earlier  suggestions!).      Thanks for your feedback, if you can give it a more thorough attack I  would appreciate it.    Jeremy        

          My understanding of the relationship between xsd:string and untyped literals  is as follows:    1: we don't know, and we are intending to work with XML Schema WG after last  call to find out.    2: if there is any relationship then the test case  > > > but  > > > :Jenny :age "11"  > > > does not entail  > > > :Jenny :age "11"^^xsd:string  would be incorrect (entailment both ways would hold).    3: the semantics document should say clearly (I don't know if it does) that  the denotation of an untyped literal without a language identifier is the  unicode string.  (Dan felt strongly about this, and no one else objected)    4: that concepts document does not equate untyped literals without a  language identifier with unicode strings.    We have also not assigned a datatype or an rdfs class for the class of all  untyped literals. I believe this to be a minor error that we may wish to  consider fixing at some point. (It makes it difficult to state certain range  constraints.)    Jeremy        > -----Original Message-----  > From: w3c-rdfcore-wg-request@w3.org  > [mailto:w3c-rdfcore-wg-request@w3.org]On Behalf Of Jos De_Roo  > Sent: 17 January 2003 00:41  > To: pfps@research.bell-labs.com  > Cc: Jos De_Roo; w3c-rdfcore-wg@w3.org  > Subject: Re: Type of (the denotation of) a plain literal  >  >  >  >  > > > but  > > > :Jenny :age "11"  > > > does not entail  > > > :Jenny :age "11"^^xsd:string  > > > nor does the latter entail the former  > > >  > > > -- ,  > > > Jos De Roo, AGFA http://www.agfa.com/w3c/jdroo/  > >  > > My view is that in XSD datatype entailment it does!  At least modulo a  > > cleanup of the RDF MT with respect to untyped literals.  > >  > > This is because I believe, based on a close examination of the  > XML Schema  > > Datatyping document, that the L2V mapping for xsd:string takes Unicode  > > strings to themselves.  >  > I'm maybe abstracting too much from the APPROVED testcase  >  >  > <test:NegativeEntailmentTest rdf:about  > ="http://www.w3.org/2000/10/rdf-tests/rdfcore/datatypes/Manifest.r  > df#test009">  >  >    <test:status>APPROVED</test:status>  >    <test:approval rdf:resource  > ="http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Oct/0131.html" />  >    <test:description>  >      From decisions listed in  > http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Oct/0098.html  >    </test:description>  >  >    <test:premiseDocument>  >       <test:NT-Document rdf:about  > ="http://www.w3.org/2000/10/rdf-tests/rdfcore/datatypes/test009a.nt" />  >    </test:premiseDocument>  >  >    <test:conclusionDocument>  >       <test:NT-Document rdf:about  > ="http://www.w3.org/2000/10/rdf-tests/rdfcore/datatypes/test009b.nt" />  >    </test:conclusionDocument>  >  > </test:NegativeEntailmentTest>  >  >  > rewriting the special case of "abc"^^xsd:string as "abc"  > could work I think, but I see a lot of trouble when  > "abc" would be interpreted as a typed literal  > (especially for legacy cases)  >  >  > -- ,  > Jos De Roo, AGFA http://www.agfa.com/w3c/jdroo/  >  >        

        > Jeremy Carroll wrote:  > > There was agreement with the treatment of equality proposed.    Brian McBride wrote:  >   > Jeremy, please can you explain why we need f*.  Why not just f?    Out of context that could be misinterpreted :-).      The argument, which is not bullet-proof, goes like this.    For general purpose applications our analysis suggests f, this is hence  our recommendation.    However, we do not wish to tie the hands of application developers who  have specific linguistic needs. Thus the f* can be read as true by an  application developer who may have a strong default to some given  language.    e.g. a small company developing tools specifically for the US Hispanic  market may have a default language tag value of "es-US" (I think that's  the right one). Then any RDF input which doesn't say it isn't is then  interpreted as "es-US".     e.g. in the same scenario, the software tool might need to have a small  footprint database and when an RDF file is loaded irrelevant triples are  immediately discarded. These are distinguished by not having language  tag "es-US". This does seem to give real advantage for f* in this  scenario.    I don't find this argument convincing; but conversely I am not  sufficiently persuaded that it is the wrong way to go to want to  prohibit it.   In many ways my argument that we are talking about the syntactic  equivalence of terms rather than a language processing model rather goes  against this; & the use of xml:lang="es-US" on the rdf:RDF tag addresses  the default language issue.      A further point, is that in M&S xml:lang processing is optional. f* is  hence justified by backward compatibility. The * in f* is the difference  between SHOULD and MUST.    Bill, do you have anything to add here?    Jeremy        

        [[  Discussed in RDF Concepts and Abstract Syntax [RDF-CONCEPTS] Section 3 XML  Literals and Section 5.1 Character normalization  ]]  ==>  [[  Discussed in RDF Concepts and Abstract Syntax [RDF-CONCEPTS] Section 3 XML  Literals  ]]    [[  Discussed in RDF Concepts and Abstract Syntax [RDF-CONCEPTS] Section 4.1  Character normalization  ]]  ==>  [[  Discussed in RDF Concepts and Abstract Syntax [RDF-CONCEPTS] Section 4.5  Literals  ]]    Personally, I think it would be tidier to delete the appendices that are  going to go; minimally you should strengthen the warning to indicate that it  will go.    Jeremy    > -----Original Message-----  > From: Dave Beckett [mailto:dave.beckett@bristol.ac.uk]  > Sent: 22 November 2002 13:08  > To: Jeremy Carroll  > Cc: Graham Klyne; RDFCore Working Group  > Subject: Re: concept anchors - RE: Minutes: telecon 2002-11-15  >  >  > >>>Jeremy Carroll said:  > >  > > >     5.1 Character normalization  > > >     http://www.w3.org/TR/rdf-concepts/#xtocid48034  > >  > > character normalization has gone as promised.  > >  > > hence this link is conceptually broken.  >  > Move the anchor to a changes section.  >  > I see you don't have one, so I'd suggest adding that.  >  > The link is in my description of the rdfms-xml-literal-namespaces and  > rdf-charmod-literals issues at  >   http://www.w3.org/TR/rdf-syntax-grammar/#rdfms-xml-literal-namespaces  >   http://www.w3.org/TR/rdf-syntax-grammar/#rdf-charmod-literals  >  > so that would have to be updated.  Please suggest what the updated  > words should be.  >  > However, that entire section will go at first REC stage.  Or maybe  > last call?  I've already added a warning at the start of  >   http://www.w3.org/TR/rdf-syntax-grammar/#section-Updated-Grammar-changes  >  > so I can certainly choose to remove it.  >  > Dave  >        

          Predicates vs Properties      On another list, Graham said ...  > I think you need to be careful to distinguish between things in the  > syntactic domain (including the RDF abstract syntax) and things in the  > semantic domain:  >  > Syntax:  >    Graph  >    RDF Triples  >    Subjects  >    Predicates  >    Objects  >    Literals - plain and typed  > -- [1] http://www.w3.org/TR/rdf-concepts/#section-Graph-syntax  >  > Semantic:  >    Interpretation (I)  >    Resources of I (IR)  >    Properties of I (IP)  >    Literal values of I (LV)  > -- [2] http://www.w3.org/2001/sw/RDFCore/TR/WD-rdf-mt-20030117/#interp  >  > There was some discussion that "Statement" should refer to (roughly) the  > semantic interpretation of a triple.  I can find no specific  > reference for  > this.    is the predicate vs properties distinction one that we are making in our  documents? It looks plausible to me, but I've not seen it articulated  before.    Jeremy        

          Dear Brian,    concerning the comments of RDF Core in  http://lists.w3.org/Archives/Public/public-webont-comments/2003May/0052.html    > owlsas-rdfcore-np-complete    We have accepted this comment and made appropriate changes to eliminate the  embedding of the Hamiltonian Path problem.    See  http://lists.w3.org/Archives/Public/www-webont-wg/2003May/0402.html  for decision.    > owlsas-rdfcore-bnodes-restrictions    We agree that there may be cause for concern, but note that the changes  requested would minimally require a major rework of the direct semantics of  OWL DL. (Section 3 of S&AS).    We have created a new issue and postponed it, so that a future group may,  with  the benefit of deployment experience, assess whether these concerns were  legitimate, and whether the quantity of work required to attempt to address  this issue is motivated.    We are still considering relaxing some of the constraints on bnodes  corresponding to class expressions; however, this does not seem to be your  main concern. We will notify you of any change.    Please reply to public-webont-comments to indicate if these responses are  acceptable.    Jeremy Carroll on behalf of WebOnt WG        

          ACTION 2002-04-12#7, jjc: post message to rdfcore with motivating example  (for dark triples?)    The basic problem can be expressed in DAML+OIL as:    <rdf:Description rdf:about="#John">     <rdf:type>      <daml:class>        <daml:intersectionOf rdf:parseType="daml:collection">           <daml:class rdf:ID="Student"/>           <daml:class rdf:ID="Employee"/>       <daml:intersectionOf>      </daml:class>     </rdf:type>  </rdf:Description>    entailing    <rdf:Description rdf:about="#John">     <rdf:type>      <daml:class>        <daml:intersectionOf rdf:parseType="daml:collection">           <daml:class rdf:ID="Employee"/>           <daml:class rdf:ID="Student"/>       <daml:intersectionOf>      </daml:class>     </rdf:type>  </rdf:Description>    ====    In English, the premise reads John is in the intersection of Student and  Employee.  The conclusion reads John is in the intersection of Employee and Student.    WOWG believes that this entailment is appropriate (although that has not  been formally decided).  However, in RDF the structure of the first collection and the structure of  the second collection is fairly different and so it is difficult/impossible  to account for the relationship. (I think the exact level of difficulty is  disputed). One aspect of this difficulty is that the meaning of the triples  according to the RDF Model theory is order preserving.    WOWG considers that this issue can be addressed by using dark triples.  I have not understood the exact mechanism of the solution.    In the discussion WOWG appeared to like this entailment so much, that it was  worth paying the cost of having two separate RDF documents to express the  light and dark triples. This was the mechanism discussed at greatest length  in the webont f2f. (I took it that the motive for discussing that mechanism  is that this was the smallest possible change required of RDFCore: simply  permission to have an RDF/XML document that is interpreted as a "dark  document").    In terms of RDF collections, we could imagine trying to make the same  construct with a closed bag. We would then end up with the problem that    <rdf:Bag>    <rdf:_1 rdf:resource="#Student"/>    <rdf:_2 rdf:resource="#Employee"/>  </rdf:Bag>    and    <rdf:Bag>    <rdf:_2 rdf:resource="#Student"/>    <rdf:_1 rdf:resource="#Employee"/>  </rdf:Bag>    are fundamentally different.    This may be addressable using a fuller solution for containers (such as I  have suggested).    However that will probably not address the dark triples problem.  For example, another desirable (from WOWG's point of view) entailment is:      <rdf:Description rdf:about="#John">     <rdf:type rdf:resource="#Student">     <rdf:type rdf:resource="#Employee">  </rdf:Description>    entails    <rdf:Description rdf:about="#John">     <rdf:type>      <daml:class>        <daml:intersectionOf rdf:parseType="daml:collection">           <daml:class rdf:ID="Employee"/>           <daml:class rdf:ID="Student"/>       <daml:intersectionOf>      </daml:class>     </rdf:type>  </rdf:Description>    and we see that maybe the whole of the intersection class is "dark" and only  the type triple is "light".      My understanding of the two documents approach is that some believe that the  two documents would be roughly split along the containers being dark, and  everything else being light:    e.g.    Light (asserted)    <rdf:RDF>   <rdf:Description rdf:about="#John">     <rdf:type>      <daml:class>        <daml:intersectionOf rdf:resource="#List">       <daml:intersectionOf>      </daml:class>     </rdf:type>   </rdf:Description>   <daml:class rdf:about="#Student"/>   <daml:class rdf:about="#Employee"/>  </rdf:RDF>      Dark (unasserted)    <rdf:RDF xml:base="same as light document">     <daml:List rdf:ID="List">        <daml:first rdf:resource="#Student"/>        <daml:rest>            <daml:List>              <daml:first rdf:resource="#Employee"/>              <daml:rest rdf:resource="&daml;nil"/>            </daml:List>        </daml:rest>     </daml:List>  </rdf:RDF>      [I note this is likely to be made less ugly by permitting the naming of  closed containers in the syntax].    An alternative is that all the ontology stuff is dark vis:      Light (asserted)    <rdf:RDF>   <rdf:Description rdf:about="#John" rdf:type="#GenSym"/>  </rdf:RDF>      Dark (unasserted)    <rdf:RDF xml:base="same as light document">      <daml:class rdf:ID="GenSym">        <daml:intersectionOf rdf:parseType="daml:collection">           <daml:class rdf:ID="Employee"/>           <daml:class rdf:ID="Student"/>       <daml:intersectionOf>      </daml:class>  </rdf:RDF>    Jeremy        

        Graham:  > >Issue B3: the self entailment issue  > >===================================  > >  > >Withdrawn in favour of B4:    > I'm uncomfortable about withdrawing this.    Graham, I think the earlier B3 was only the redhead example, not the a  document entails itself example.    I would certainly support the addition of a new open issue with TDL in the  "can't live with" class.    Something like:  [[[    Issue B?: TDL self-entailment    In TDL a document does not entail itself.    Cannot live with: Graham, Jeremy, DanC    ]]]    Without extra work on the TDL MT, this is a "cannot live with" against TDL.  I was intending to work from the exisitential quantification of literals  along the lines you sent me, but frankly if Pat can be persuaded to start  with a clean sheet (or the P++ model theory) and come up with a better TDL  model theory meeting his objections then we will all be happier (me  especially).    Jeremy        

          Pat,    I found both your messages on test case A confusing.    I'll try and explain why, and suggest you may like to reconsider them.    At the f2f the suggestion we were looking at is that the denotation of a literal  in a triple is a function of the predicate and the literal.    Thus test case A holds since in it both the predicate and the literal are the  same.    However this suggestion is untidy in our previous terminology.    Brian's questions about test case A were asked in this framing, and you seem (to  me at least) to have missed the point.    e.g.    > There are two cases to consider, right? We can have (semantically)  > tidy literals, where each literal node labelled with the same literal  > denotes the same thing; or we can not. Call these the ST and NST  > cases. Test A is 'yes' for ST, 'no' for NST.      ???? not what we had at the face to face. We favoured an untidy possibility in  which test case A, and hence Brian's container example held.      Jeremy        

          I disagree strongly with Pat's proposal here.    pat hayes wrote:    > design slightly, by reverting to an older design. The trouble seems to   > arise from our insisting that XML literals are treated uniformly with   > typed literals: so let us abandon that idea, in spite of its being very   > neat, and revert to the state where the XML literals as treated as a   > special syntactic case in the RDF graph, so that there would be five   > kinds of literal: plain and XML with and without lang tags, plus   > datatyped literals.  >   > In detail, the proposal is as follows.  >   > 1. There are five kinds of literal in an RDF graph, indicated in   > Ntriples as follows:  > "string"                  plain  > "string"@tag              plain plus lang tag  > "string"^^rdf:XMLLIteral          XML  > "string"@tag^^rdf:XMLLiteral      XML plus lang tag  > "string"^^foo:baz              typed, where foo:baz is any URI other   > than 'rdf:XMLLiteral'  >   > Notice that the Ntriples way of indicating the XML case is just as it is   > now, but thats just a syntactic decision to save work; rdf:XMLLiteral   > isn't a datatype and XML literals are not typed literals in this design,   > so the possibility of having lang tags in its lexical space isn't going   > to cause any headaches..  >   > 2. The semantic conditions on the first four are specified in the RDF   > interpretations and spelled out in detail - exactly how I leave to   > others to decide, but it seems to me that we could dispense with the   > wrapper (since we don't need to include the lang tag in a value space   > any more) and could just say that the XML case is treated semantically   > just like the plain case, ie the XML literal denotes itself (a piece of   > XML text, perhaps one conforming to Jeremy's elaborate conditions in   > http://www.w3.org/2001/sw/RDFCore/TR/WD-rdf-concepts-20030117/#section-XMLLiteral,   > or such a piece of text plus a lang tag); this would simplify the RDF   > MT, in fact.  >       The key question is what will this achieve in terms of actual deployment.  What I have seen in webont is that at least some of the target community   for RDF is resistant to XMLliterals at all.  Every obstacle to easy deployment of XMLLiteral will be a reason to not   deploy it.  Currently (based on the LC design) webont have declared that OWL tools   should minimally support xsd:string and xsd:integer, whereas rdf:XMLLiteral   is optional. This means that certain entailments are implementation dependent  (contrast  http://www.w3.org/TR/owl-test/proposed-misc-200-xmlliteral#miscellaneous-204  http://www.w3.org/TR/owl-test/proposed-misc-200-xmlliteral#miscellaneous-205  )  The same file is constistent or inconsistent depending on implementation   specific parameters (reasoning support for rdf:XMLLiteral, which is optional).     From my point of view this is a failure of *this* WG to have a design that   is sufficiently simple that implementors and others feel they can commit to   it. I believe that the simplifications we have made will be beneficial for   I18N, in that the only remaining difficulties for XMLLiteral are in the   parser, and many parser writers seem bought in to doing the work.    It is futile to have the perfect design on paper if there is not consensus   amongst the implementators to actually implement it. If this WG decides to   make XMLLiteral harder to implement in order to make life easier from an   I18N perspective, then the result will be that many RDF implementations   will not implement it, and hence the user who needs the I18N features   provided by XMLLiteral will need to take additional care to find a   conformant implementation.    It is undoubtedly correct that Pat's design works on paper (modulo a few   tweaks) and addresses Martin's issue about xml:lang.    It is not at all clear that this actually furthers the real usablity of   semantic web technologies in an I18N context. I think it probably sets it back.      >   > 4. Regarding Martin's other beef, that some XML without any markup in it   > is 'really' just plain text, this design also allows an RDF application   > to deal with this reasonably sensibly, since that identification amounts   > to just stripping off the ^^rdf:XMLLiteral flag when the literal string   > has no XML markup in it. I would vote against making that a valid RDF   > entailment in the semantics, but it would be relatively easy for a small   > app to do this using simple scripting on literals and still be a   > sensible semantic extension, without getting into all the datatyping   > complexity.  >       Minor point, such a small app could exist with our current design.    Jeremy        

          Frank:  > > I can't think of a better way to insure  > > that what people think RDF is (including both RDF/XML and Schema) is  > > what's described in the Primer than to make all the normative specs  > > "bare-bones normative" (and hence virtually unreadable).  The specs  > > people can read tend to become "normative" by usage.  Jeremy:  > Very well-argued.    I wrote that a couple of days ago, I guess it got held up on my PC.    On reflection, I feel this is a good argument to make the primer correct,  which I think we wanted to do anyway. It does not matter at all if people  don't have examples of how to use bagID because its useless. All the  rdf:parseType's are there for other specs to and implementations to build  on - apart from "Literal" which I hope the primer will treat a little. If  the primer doesn't mention property attributes, and then no one uses them,  that won't be a huge lose to humanity.    Jeremy        

            Graham Klyne wrote:    >   > At 08:48 29/06/03 -0400, Martin Duerst wrote:  >   >> Hello Graham,  >>  >> At 18:53 03/06/27 +0100, Graham Klyne wrote:  >>  >>> Speaking for myself, and my understanding of our discussion...  >>>  >>> What I found "distasteful" was the suggestion that one would have to   >>> look *inside* the content of a literal to figure out what type it is.  >>  >>  >> Obviously, to find out whether it is text with markup or text  >> without markup, one way is to look inside. Another way would be  >> to disallow rdf:parseType='Literal' on pure text strings.  >   >   > I think this possibility was mentioned in our discussion, but rejected   > on the grounds of invalidating some (much?) existing RDF, and also   > making life much harder for RDF writers.  >       An example application is one I have which has a form which permits the   user to include xhtml markup. The value of this form becomes embedded   within an RDF document inside an rdf:parseType="Literal" element.    >   >>> In discussion, I understood the request to be for:  >>>  >>> [[  >>> <dc:title rdf:parseType='Literal'>  >>>   A Midsummer Night's Dream  >>> </dc:title>  >>> ]]  >>>  >>> to denote a plain string literal, but  >>>  >>> [[  >>> <dc:title rdf:parseType='Literal'>  >>>   <em>A Midsummer Night's Dream</em>  >>> </dc:title>  >>> ]]  >>>  >>> to be a completely different kind of literal denoting an XML document   >>> in some way (because of the presence of markup).  >>>  >>> (I originally read Martin's note to suggest that an XML document is   >>> itself just a string of Unicode characters, not distinguished from   >>> non-XML strings.  That is a position I could support but with which   >>> others have expressed concerns.)  >>  >>      Martin:    >> Can we please make sure that we separate syntax and semantics?  >   >   > I wasn't aware of conflating the two.  This issue seems to be entirely   > syntactic:  is a sequence of Unicode characters used to represent an XML   > document (and conforming to XML syntax) syntactically distinguished from   > any other sequence of Unicode characters?  (Hmmm... maybe the conflation   > here is between concrete syntax and abstract syntax -- I'm thinking of   > abstract syntax here.)  >   > As for the rest of what you say, I really don't want to get into   > encoding tricks here -- to me that is just another layer of complexity   > we don't need, and as such should be left to implementers to deal with   > in their own way.   That is, if the string  >    "<a>Some text</a>"  > is to be distinct from the XML document encoded as:  >    "<a>Some text</a>"  > then we should just say so and deal with the consequences.      The WG has taken such a position for a quite a while now.  This has been motivated by the needs of applications which produce XML   output and have to escape the non-XML strings and to not escape the known   XML content.    >   > Personally, I don't think XML should have this distinguished status in   > RDF.  If it's really necessary to distinguish an XML document literal in   > RDF, when why not use RDF facilities to do so?  e.g.  >   >    <ex:XMLDocument>  >       <rdf:value rdf:parseType="Literal"><a>Some text</a></rdf:value>  >    </ex:XMLDocument>  >   > as distinct from, say:  >   >    <ex:StringData>  >       <rdf:value rdf:parseType="Literal"><a>Some text</a></rdf:value>  >    </ex:StringData>  >       Simply that this is not the design the WG took to last call. The design the   WG took to last call had been examined by the RDFCore WG in detail, and had     had, at least at an earlier stage, been reviewed by the I18N WG.    I also note that the RDF Core WG considered and rejected such models for   typed data literals (e.g. in which an integer might have been represented as    <ex:int>      <rdf:value>1</rdf:value>  </ex:int>    to distinguish it from the string    <ex:string>      <rdf:value>1</rdf:value>  </ex:string>    )      >> XML is defined as a syntax on a sequence of Unicode characters,  >> so treating it as such in a particular implementation,... is  >> possible. If you are a bit careful with escaping, you can store  >> text without markup in the same form. Other implementations are  >> easily possible (for example, one could observe that "<>" is illegal  >> in XML, and thus use "<>" to escape '<', and not escape &, and  >> use '""' to escape '"' in an attribute. This would no longer look  >> like XML, but would store the same information).  >>  >> For RDF to say that XML is *treated* as a string of Unicode characters  >> is perfectly okay. For RDF to say that XML *is* nothing but a string  >> of Unicode characters is a bad idea.  >       The current phrasing in the editors draft defers to the term exclusive   canonical XML:  http://www.w3.org/TR/2002/REC-xml-exc-c14n-20020718/#def-exclusive-canonical-XML      >   > I don't think the issue here is that RDF is or is not trying to say   > anything about what an XML document may be, but rather to decide whether   > or not RDF embodies special treatment of literals that happen to be XML   > documents.  My position being:  why shouldn't RDF adopt the same   > techniques for talking about XML documents that it uses for talking   > about any other kind of thing in the universe of discourse?  >       Which is what it does, it treats the embedded XML as a special sort of   literal value, i.e. a typed literal. This seems an entirely consistent and   coherent position.      >> What is important is that the same semantic things, i.e.:  >> - Text (without markup or language information)  >> - Text with language information (but no markup)  >> - Text with markup (but no language info)  >> - Text with markup and language information  >> are in each of the above cases recognized as being the same rather  >> than being split up in a number of different things based on some  >> representational details. On top of that, recognizing the continuity  >> between the four variants above and making it easy to deal with  >> this continuity would be a definite plus.  >       There is certainly more work that should be done in the area of language in   the semantic web, for instance RDF Core has considered Tex Texin's comment    http://lists.w3.org/Archives/Public/www-rdf-comments/2003JanMar/0460.html    concerning language ranges and realized that at present we offer no   solution - but that that problem was outside our current charter. So we   have created a new postponed issue as described in:    http://lists.w3.org/Archives/Public/www-rdf-comments/2003AprJun/0029.html    This wuld address the first two of Martin's list - but not the issue of   markup. To me this looks like application space, in which semantic web   application layers, that are currently not particularly subscribed in W3C   documents, get to call the shots.  The different between an XML document and related strings is complex, and   probably goes beyond the bounds of what can be systematically defined.    e.g.    If we are searching for instances of the word "pot" which of the following   bits of XML should count as a match:    "<em>pot</em>"  "<pot/>"  "<eg eg:pot='h' xmlns:eg='http://eg.org/'/>"    etc.      >   > Which all seems to be saying that there are different flavours of text   > for which consistent handling is required.  Which seems reasonable to   > me.  But what is confusing me is the suggestion that XML is, on one   > hand, just another flavour of text, yet is also something completely   > different.  I can't make coherent sense of this.      In the current WG solution XML is not just another flavour of text.      Jeremy        

          > >>  > >>   language ::= [a-z0-9]+ ('-' [a-z0-9]+ )?    Sorry I lost this thread today - the above production is slightly wrong it  should read:    language ::= [a-z0-9]+ ('-' [a-z0-9]+ )*    (i.e. any number of subtags are allowed .. e.g.    en-us-wisconsin    )  I expect this is too late, it won't matter.    Jeremy        

        I think the current behaviour of ARP is too complex for the current round of  RDF standard. ARP allows xml:base on any element, and then resolves all URIs  using the first enclosing xml:base. In strict mode ARP fails if there is an  xml:base that actually changes the document: i.e. ARP permits an xml:base  that is the same as the document URL or an xml:base on an element which does  not generate any URIs. I will change the strict mode behaviour to exactly  follow the eventual resolution of the WG.    (The rest of this message must be a rehash of the earlier discussion!)    However, given that RDF has to interoperate with the standards of any  enclosing document I think we should honour xml:base expressions outside the  rdf:RDF element.    Without xml:base it is necessary in some circumstances to use a private  channel to pass the base URL of a document. This is highly unsatisfactory,  and permitting an xml:base on the rdf:RDF element itself, also in  non-embedded RDF strikes me as a fair trade-off.    An issue is that honouring xml:base in the enclosing document is  sufficiently hard work that any implementator is likely to follow the ARP  decision and allow it arbitrarily (except in a strict mode).    Jeremy        

      Responses to simple questions only.    > For one thing, it seems ugly. But that's a matter of taste,  > not one I'd expect folks to find compelling.    Not the way I would implement it either.    > Another thing: when you say ?y != rdf:value do you mean  > the syntactic term isn't rdf:value?    Yes.    > Or perhaps you're just proving that TDL is implementable,  > and we shouldn't take the proof construction method too  > seriously?    Precisely.      >Maybe something like this?  >  > ex:age rdfs:range dt:decimal.  > ex:somebody ex:age "abc".  >  > ... where a datatypes implementation would be expected to complain  > because that entails  > "abc" rdf:type dt:decimal.  > but we know that "abc" isn't a decimal literal.    That's certainly one appropriate test.  Also we may find some entailment tests.    [ Query omitted from this response ]  >  > > Graham, does this adequately address your concern about self-entailment?  >  > It does address the self-entailment issue, I suppose.    Thank you for your enthusiasm!      > I don't understand that. I don't see any closed-world assumptions in S.  [[[ 4.9 // idiom P  Notice that for the above definition to be well-formed, we need to be able  to enumerate all datatype mappings.  ]]]    That is a closed world assumption.    Jeremy        

            >   > Ah.  Is this a problem.  Have I understood correctly they are going   > through last call again anyway.  >       Yes - I could change my draft informal response to indicate that if we have   any other formal response it will be included in our LC review comments on   their new documents.      >>  >> e.g.  >> I have informed the RDF Core WG of your decisions, and no one has   >> indicated  unhappiness - however we have not formally discussed these   >> issues; and are not likely to.  >   >   > When is the deadline?  I'm prepared to decide by email so we can   > formally respond by email.      Two weeks from when I received the message ....    i.e. during Cannes - I suspect that is also the real deadline, in that I   imagine they want to make their final decisions at Cannes    I am happy to draft a formal response that is pretty vacuous, for e-mail vote.      Jeremy        

          Art:  >  > Ron - thanks for providing these notes.  >  > I like the general approach that is outlined and would favor  > representing a Literal as a bNode.    Jan:  > I hate to say it, but I'd take the opposite view: this seems clunky and  > ugly.    Isn't the thing about RDF 2.0 that it is for later.    I see our job as:  - clarifying what is already out there  - not closing doors for RDF 2.0      So we have two different opinions about what RDF 2.0 might be like, this  helps in that we use this to inform us as what NOT to do, rather than  what to do.    We shouldn't solve any problems in ways that prevents RDF 2.0 from  either:  + imposing another level of indirection as the general literal  representaion  or  + moving to rich typed literals as the general literal representation      My view is that M&S is clear that Literals are just strings (with that  lang thing!) and that we can get a long way, (far enough), with sticking  to that.    I also think that RDF 2.0 does need to say something more.    Our charter says ...  > RDF Schema must be expressed in terms of the RDF model, and   > must use W3C RDF syntax. RDF Schema must use and build upon   > XML Schema datatypes to the fullest extent that is practical   > and appropriate. Specifically, the RDF Core Working Group is   > not chartered to develop a separate data typing language that   > duplicates facilities provided by XML Schema data types.    A major reworking of types into the Graph and Syntax is in my view out  of charter. I think we either can rubber stamp DAML use of XML schema  datatypes or finish off RDF 1.0 as untyped and ask for a new charter to  do types in RDF 2.0.        

        somewhat delayed. I found it difficult to write, which probably means it  will be difficult to read. Which probably in turn means that it isn't much  good. Well such is life.    =====      I think I've beaten Jos & Jan to claiming the J node.    J for junk or J for jewel. Or maybe J for joke.      Overview  --------    J is inspired by Peter Patel-Schneider's observation that XML Schema  (parts 0, 1 & 2) does datatyping, and that RDF datatyping should be  compatible with it.    Example use case is:    Currently when designing an XML schema/DTD/whatever it is possible  to do that with RDF in mind. This results in documents that while  conforming to the schema, and XML idiom, also conform to the RDF M&S  specs.    For datatyping, this suggests that an XML document, that has an  XML schema (for all or part of it), has already declared the datatypes.  If the document also conforms with RDF syntax, then we should apply  the datatyping from the XML schema.    At the level of the abstract RDF syntax, the graph; this means that  unlike other proposals the graph is labelled with labels from the value  space rather than labels from the lexical space. In fact, the lexical  space is only found in documents, and not in the abstract data model.    XML schema instance attributes are treated specially and RDF processors  are required to recognise them.      Examples  --------    1: Explicit use of xsi:type for simple value  ............................................      <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"           xmlns:xsd="http://www.w3.org/2001/XMLSchema"           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"           xmlns:eg="http://example.org/">      <rdf:Description>        <eg:shoeSize xsi:type="xsd:integer">10</eg:shoeSize>      </rdf:Description>    </rdf:RDF>      Graph  .....      _:a -------->--------  (10)      Note: the node on the right is labelled with the integer 10, not the  string "10".  Hence using a different but compatible XML Schema type that maps the  string "10" to the same value, e.g. xsd:positiveInteger, results in  an identical graph.    N-Triples**  ...........     _:a <http://example.org/shoeSize> {xsd:decimal,"10.0"} .    In the modified N-Triples we need to give a type that converts the lexical  form in the file into the value in the graph. Since N-Triple is canonical  we use the primitive type from which the derived type inherits, and we  use the canonical form of the lexicalization.      2: Implicit/Explicit use of XML Schema for whole document  .........................................................    Haven't got this to work.      3: Explicit use of xsi:type for complex value  .............................................  e.g. complex numbers    We have a schema like    <xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"          targetNamespace="http://www.example.org/complexNumber"          elementFormDefault="qualified"          >     <xsd:complexType name="ComplexNumber">    <xsd:sequence>     <xsd:element name="real"   type="xsd:decimal"/>     <xsd:element name="imaginary" type="xsd:decimal"/>    </xsd:sequence>   </xsd:complexType>    </xsd:schema>    then we could have        <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"           xmlns:xsd="http://www.w3.org/2001/XMLSchema"           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"           xmlns:cplx="http://www.example.org/complexNumber#"           xmlns:eg="http://example.org/">      <rdf:Description>        <eg:shoeSize >            <rdf:Description xsi:type="cplx:complexNumber">               <cplx:real>10</cplx:real>               <cplx:imaginary>3</cplx:imaginary>            </rdf:Description>        </eg:shoeSize>      </rdf:Description>    </rdf:RDF>      This has corresponding graph            showSize     real    _:a --->---- [] --->----- (10)                  |                  | imaginary                  ----->----- (3)    where the labels on the right are real numbers not strings.        3: Implicit use of XML schema for complex value  ...............................................    Lets suppose that exmaple.org defines both an RDF and an XML schema for  shoesize.    So the file retrieved from http://example.org/ is as follows  [[[[[    <!-- arbitrary container for both XML and RDF schema -->    <foo xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">    <!-- XML Schema part -->  <xsd:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"          targetNamespace="http://example.org/"          elementFormDefault="qualified"          attributeFormDefault="qualified"          xmlns:cplx="http://www.example.org/complexNumber#"          >     <xs:complexType name="shoeSize">    <xs:complexContent>     <xs:extension base="cpx:complexNumber">  <!-- This is trying to say that:           a shoeSize has the XML form of a complex number           except that it has an additional attribute            rdf:parseType that must be present with value "Resource"  -->      <xs:attribute ref="rdf:parseType" fixed="Resource" use="required"/>     </xs:extension>    </xs:complexContent>   </xs:complexType>      </xsd:schema>    <rdf:RDF xmlns:rdfs="usual uri">     <rdfs:Property rdf:ID="shoeSize" />     <!-- We could have a range constraint to say that          shoeSize's are complex numbers,          but I am not sure how.     -->  </rdf:RDF>  </foo>      ]]]]]]]]    Given these schemata then:  [[[[    <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"           xmlns:eg="http://example.org/#">      <rdf:Description>        <eg:shoeSize rdf:parseType="Resource">               <cplx:real>10</cplx:real>               <cplx:imaginary>3</cplx:imaginary>        </eg:shoeSize>      </rdf:Description>    </rdf:RDF>  ]]]]    corresponds to the same graph as before.  It XML Schema validates because the XML representation of eg:shoeSize  matches,  and eg:shoeSize is also linked in with the rdfs schema.    There is a bit of an issue with the trailing "#"-es.    I am not sure I find this convincing ....      Jeremy        

        >   > >>>Jeremy Carroll said:  > >   > >   > > From RFC 2396 section 5  > >   > > [[  > >    Some URI schemes do not allow a hierarchical syntax matching the  > >    <hier_part> syntax, and thus cannot use relative references.  > > ]]  > >   > > I think that that justifies xmlbase/error001.rdf as an error.  > > Perhaps the above quote need to be added to the file.  >   >    DaveB:   > Isn't this implying (since it is an error case) that RDF applications  > have to validate URI-refs or at least know some non-hierarchical uri  > schemes.  I understand RDF apps need to do relative URI resolution  > but until the xmlbase test cases, we never checked that they worked  > right.      Yes your right. I am convinced. I will switch error1 to positive.  >   > We seem to be sort-of generating test cases for other specifications  > (RFC 2396, xml base) which we generally shouldn't be doing :)  >       Hmmm...     that's food for thought.    Jeremy        

        Sorry the examples all screwed up, at least on the web page.  I am using a different OS than my previous I18N postings; I've also got an  Italian keyboard!    This time I attach the examples in a separate HTML file.    The two questions for I18N are in the examples file.    Jeremy                text/html attachment: charmod-uri.htm          

          FYI    I am currently expecting to vote against these changes if the question is put:    cf.    http://lists.w3.org/Archives/Public/www-rdf-comments/2004JanMar/0030    Also, as far as I understand, the following test case changes:    (from an entailment to a non-entailment. Peter suggests there are approved   test cases that would change)    <eg:p1> rdfs:range xsd:boolean .  <eg:a> <eg:p2> "true"^^xsd:boolean .  <eg:a> <eg:p2> "false"^^xsd:boolean .  _:a <eg:p1> <eg:bl> .    entails    <eg:a> <eg:p2> <eg:bl> .    The magnitude of this change is one that requires a longer review period   than we have available. I also suspect that I disagree with the content.  I am not convinced that there is any big enough problem with the PR   document that is actually being fixed.    To vote for this, *I* would need to be convinced, I would need to be   convinced that WebOnt were on-board, I would need to have had sufficient   time to discuss it in-depth with the HP implementors. This is not feasible   in the time we have.    Jeremy      pat hayes wrote:    > The suggested change can be seen at  >   >   > http://www.ihmc.us/users/phayes/RDF_Semantics_2004.html  >   >   > particularly at  >   >   > http://www.ihmc.us/users/phayes/RDF_Semantics_2004.html#defDinterp  >   > See also  >   > http://www.ihmc.us/users/phayes/RDF_Semantics_2004.html#change  >   >   > Pat  >   >   > PS Ive  corrected some other typos and (deliberately) @@@@-trashed the   > 'this version' link.  >   > --   >   > ---------------------------------------------------------------------  > IHMC       (850)434 8903 or (650)494 3973   home  > 40 South Alcaniz St.       (850)202 4416   office  > Pensacola                 (850)202 4440   fax  > FL 32501                     (850)291 0667    cell  >   > phayes@ihmc.us       http://www.ihmc.us/users/phayes  >         

            Sorry this is so late, only back from hols today.    I tend to read the implementor feedback as suggesting a change to xmlsch-02.    I think it is hard to change any of:  - the value space  - the lexical space  - or the l2v mapping    so I prefer to hack the spec with something very implementation oriented.    e.g.  [[  Implementations MAY apply XML Schema whitespace processing during  the lexical-to-value mapping, but SHOULD issue a warning message  for input which is modified by such whitespace processing.    Note: Formally such whitespace processing is not part of the RDF datatype.  ]]      (this needs more work, but it's time to phone)    Jeremy        

          Fwd from www-archive    -------- Original Message --------  From: Morten Frederiksen <morten@wasab.dk>  Organization: MFD Consult  Subject: Re: WordNet Task Force - work outline  Date: Tue, 30 Mar 2004 19:57:16 +0200  Hi Jeremy,    [This is in reply to a post on swbp-wg, I'm not a member, so...]    On Tuesday 30 March 2004 17:35, Jeremy Carroll wrote:  > This use of WordNet is fairly naive (in the sense that non-experts can do  > it) and does not depend on any of the relationships between words.  You are of course right, that the standalone usage that Norm is doing doesn't  depend on any relationships, but it is quite possible to do so.    Matt Biddulph has been doing this for a while, for his picture annotations  (unfortunately the search thingy is down atm, pending a wordnet upgrade):    http://www.hackdiary.com/archives/000009.html  http://www.hackdiary.com/cats.html#wordnet    This approach does use the subclass relationships of the wordnet RDF mapping  - it may not be perfect from a linguistic or semantic standpoint, but I think  it's a good start.      Regards,  Morten  http://purl.org/net/morten/        

        I note that Dave switched my attempt at US spelling    "serialization" to "serialisation"  http://cvs.ilrt.org/cvsweb/redland/rdfcore/syntax/index.html.diff?r1=1.137&r  2=1.133    two questions:  1: what is the correct US spelling of this word?  2: should W3C recs be in en-US or is en-GB acceptable?      Anyone else remember the Unix man page for "spell" I think it was - with the  comment in the BUGS section that the British spelling was done by an  American!    Jeremy        

          WebOnt asked me to ensure that RDF Core was sufficiently aware of the   importance webont attach to the issue raised by the OWL Semantics' editor   concerning the semantics of literals in RDF.    The details can be found at:  http://lists.w3.org/Archives/Public/www-rdf-comments/2003JanMar/0014.html    further discussion, including how this impacts OWL semantics is at:    http://lists.w3.org/Archives/Public/www-webont-wg/2003Jan/0093.html  http://lists.w3.org/Archives/Public/www-webont-wg/2003Jan/0171.html    My understanding is that this is a critical issue that should be fixed   before we move semantics to last call.    The best outcome for webont would be that Pat and Peter discuss the   problem, agree a resolution, and this is reflected in the RDF Semantics   Last Call (and also the OWL Semantics Last Call).    A minimal outcome is that RDF Core replies to Peter's comments soon to   indicate what will, or will not, be done in the RDF Semantics Last Call, so   that Peter can take whatever action is necessary in the OWL Semantics Last   Call.    While my personal understanding of this issue is limited, it does seem to   me to be in the showstopper category that merits attention despite the   near-freeze on our documents.    Jeremy        

        >  > a) a character string  > b) a word in a natural language  > c) an XML tree  > d) an abstract structure that consists of a string,  >             a tag, and a bit.  >  > Choice d) seems ugly if we think of RDF as a foundation for the SW. If  > we go for a)-c), then the literals become polymorphic...    My understanding was we went for (d) as best reflecting the past (M&S) not as the best basis for the  future (SW).    I think there are many issues for which we might want to say that the past is not the ideal basis  for the future. But the past is non-optional.      > (2) Extensibility      > The language tags keep evolving. How do we accommodate new language  > encoding schemes gracefully?    The language tags are a dynamic set. There are mailing lists that tell you of the changes. There are  well-defined update procedures. We can have a generic dependency on xml:lang, which in turn has a  generic dependency on RFC 3066 which in turn has a generic dependency on ISO639 and ISO3166. IMO  this will have a long enough shelf life. It makes it hard to write software that "knows" all the  langauge tags, but it is only a warning message (at least in my software).    I don't find Sergey's argument compelling.    > In short, I think that we might be doing a bad job on literals.    I think we have created a clear rearticulation of M&S. That is the job we are chartered to do.    Jeremy        

        DanC:  > Please see my 11 Oct suggestion to replace it wholesale, which  > was greeted with at least two voices of support:                                            ^^^^^^^  >  > http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Oct/0186.html      You use the word 'support' rather more liberally than I would.  The only two other posters in that thread were Pat and Graham, both of whom  expressed reservations about the wholesale replacement but were supportive  about other aspects of your message.    e.g.    Graham in:  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Oct/0428.html  wrote:  [[[  When I agreed to your proposal     http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Oct/0186.html  I was mainly agreeing with the bit that the model theory should not be  constrained by the current RDF syntax in what it describes:     http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Oct/0193.html  rather then specifically agreeing to your abstract syntax proposal.  ]]]    Pat in:  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Oct/0190.html  wrote:  [[[  But this abstract syntax is really just N-triples, and I prefer to  keep the graph as a separate entity.  ]]]    Now, obviously the messages can be quoted to indicate where they supported  you, but it wasn't about the thing you highlight.    If it helps clarify I will give a "-1" for N-triples rather than the graph  as the abstract syntax. I find both levels helpful, and would prefer to  retain them both.    Jeremy        

          Putting OWL test case editor's hat on.    OWL Test Cases WD has recently been published.  I would quite like at least one comment, while the other drafts get the  glory!    Maybe RDF Core WG would like to submit an OWL Test Case with a formal  request to have it included in the OWL Test Cases.    Jeremy      > -----Original Message-----  > From: w3c-rdfcore-wg-request@w3.org  > [mailto:w3c-rdfcore-wg-request@w3.org]On Behalf Of Dan Brickley  > Sent: 10 April 2003 13:34  > To: Patrick.Stickler@nokia.com  > Cc: Jan.Grant@bristol.ac.uk; bwm@hplb.hpl.hp.com; gk@ninebynine.org;  > w3c-rdfcore-wg@w3.org  > Subject: Re: Proposed response for timbl-02 (reification semantics)  >  >  >  > * Patrick.Stickler@nokia.com <Patrick.Stickler@nokia.com>  > [2003-04-10 14:06+0300]  > >  > >  > > > -----Original Message-----  > > > From: ext Jan Grant [mailto:Jan.Grant@bristol.ac.uk]  > > > Sent: 10 April, 2003 13:51  > > > To: Stickler Patrick (NMP/Tampere)  > > > Cc: danbri; bwm; gk; w3c-rdfcore-wg  > > > Subject: RE: Proposed response for timbl-02 (reification semantics)  > > >  > > >  > > > On Thu, 10 Apr 2003, Patrick.Stickler wrote:  > > >  > > > > > -----Original Message-----  > > > > > From: ext Dan Brickley [mailto:danbri@w3.org]  > > >  > > > > > here's a sketch towards testcase, sorry haven't polished  > > > this up but  > > > > > the intent should hopefully be clear. It takes your sample and  > > > > > shows the kinds of interferences that OWL-happy systems  > > > might make in  > > > > > the face of knowing some things have multiple URIs and  > > > OWLs ability to  > > > > > express equality, directly (sameFooAs) or indirectly  > > > > > (InverseFunctionalProperty).  > > > > >  > > > > > [[  > > > > >   _:s rdf:type rdf:Statement ;  > > > > >    _:s rdf:subject <s1> ;  > > > > >    _:s rdf:predicate <p1> ;  > > > > >    _:s rdf:object <o1> ;  > > > > >    _:s #source <http://some.server/some_schema.rdf>  > > > > >  > > > > > <s1> owl:sameIndividualAs <s2>  > > > > > <p1> owl:sameIndividualAs <p2>  > > > > > <o1> owl:sameIndividualAs <o2>  > > > > >  > > > > > ...which with OWL semantics I believe gets us to:  > > > > >  > > > > >    _:s rdf:type rdf:Statement ;  > > > > >    _:s rdf:subject <s2> ;  > > > > >    _:s rdf:subject <s1> ;  > > > > >    _:s rdf:predicate <p2> ;  > > > > >    _:s rdf:predicate <p1> ;  > > > > >    _:s rdf:object <o2> ;  > > > > >    _:s rdf:object <o1> ;  > > > > >    _:s #source <http://some.server/some_schema.rdf>  > > > > >  > > > > >  > > > > > which includes the subset of triples,  > > > > >  > > > > >    _:s rdf:type rdf:Statement ;  > > > > >    _:s rdf:subject <s2> ;  > > > > >    _:s rdf:predicate <p2> ;  > > > > >    _:s rdf:object <o2> ;  > > > > >    _:s #source <http://some.server/some_schema.rdf>  > > > > >  > > > > > which strongly suggests that the triple  > > > > >  > > > > >    <s2> <p2> <o2> .  > > > > >  > > > > > ...can be found in some_schema.rdf, rather than 'can be  > > > > > deduced from...'.  > > > > > ]]  > > >  > > > If you want to distinguish between symbols rather than the things they  > > > refer to, wouldn't you also balk at  > > >  > > > <s1> owl:sameIndividualAs <s2>  > > >  > > > since they're clearly not the same?  > >  > > I have no problem with <s1> and <s2> denoting the same thing.  >  > me neither, though I agree it can seem an odd way to express things.  > OWL, for better or worse, does give us a way to write RDF/XML instance  > data that (when read wearing OWL glasses) tells us that two URIs denote  > the same thing. That's just the world RDF lives in now, and the world  > reification will be deployed in.  > >  > > > Should we ask that a  > > > health warning  > > > be attached to owl:sameIndividualAs?  > >  > > Not at all.  > >  > > > I'm really concerned about this test case. It seems to mix formal  > > > notions (owl:sameIndividualAs) and woolly ones ("strongly suggests").  > > >  > > > Presumably there is an analogous warning to be attached to datatypes?  > > > Since (sooner or later) we might find the situation that  > > >  > > > _:jan eg:age "21.0"^^xsd:decimal .  > > >  > > > "strongly implies" that  >  > yes (jang), my 'strongly implies' was a bit vague. At that point I  > only had Patrick's property name ('source') to go on. Since then we have  > seen the schema, comments on which below.  >  > > >  > > > _:jan eg:age "21"^^xsd:int .  > >  > > After thinking about this some more, I've realized that I don't have  > > a problem with the inference you suggested. I.e., I'm OK with  > > the following entailment  > >  > > {  > >    _:s a rdf:Statement .  > >    _:s rdf:subject <s1> .  > >    _:s rdf:predicate <p1> .  > >    _:s rdf:object <o1> .  > >    _:s #source #x .  > >    <s1> owl:sameIndividual <s2> .  > >    <p1> owl:sameIndividual <p2> .  > >    <o1> owl:sameIndividual <o2> .  > > }  > > log:implies  > > {  > >    _:s a rdf:Statement .  > >    _:s rdf:subject <s2> .  > >    _:s rdf:predicate <p2> .  > >    _:s rdf:object <o2> .  > >    _:s #source #x .  > > }  > >  > > because reification, as now defined, is not quoting.  >  > Ah, ok, that makes things simpler. My previous mail was written  > in concern that  > you somehow wanted to block this inference from going through.  >  > > If we add verbage of any kind, then it should be to the effect  > > that such entailments hold.  >  > OK. Patrick, hope you don't mind us picking on you as a sample user of  > rdf reification, but let's follow this one through a bit further.  >  > Your current defintion for 'source' is as follows:  >  >       <rdfs:Property rdf:about="&rdfx;/source">  >          <rdfs:comment>An RDF schema in which the statement  > occurs.</rdfs:comment>  >          <rdfs:domain rdf:resource="&rdf;#Statement"/>  >          <rdfs:range rdf:resource="&rdfx;/Schema"/>  >       </rdfs:Property>  >  > This (sorry jang)  > 'strongly suggests'  > 'seems to me to be saying'  > 'leads me as an implementor to believe'  >  > that because of  >  > >    _:s a rdf:Statement .  > >    _:s rdf:subject <s2> .  > >    _:s rdf:predicate <p2> .  > >    _:s rdf:object <o2> .  > >    _:s #source #x .  >  > the RDF statement  >  > <s2> <p2> <o2> .  >  > ...occurs in the RDF schema referenced.  >  > Now you don't formally define 'occurs' here.  > For the sake of our example scenario, let us assume that <s2>, <p2> and  > <o2> URIrefs are not anywhere to be found in the RDF document that  > the 'source' property references.  >  > The work of our health warning is to help RDF vocabulary creators use  > language in their defintions for properties such as this which won't  > raise inaccurate expectations. In this case, an inaccurate expedtation  > would be that the URIs <s2>, <p2> and <o2> are labels on a triple  > from the graph serialized in the RDF schema document referenced by the  > source property. (or some refinement of that; it's hard to word  > this stuff)  >  > Does that seem correct? ie. that words like 'occurs' in this context  > are super-slippery...  >  > Dan  >  >        

        (Largely in agreement).      The manifest file makes a lot of difference to this ...    The manifest file should show the approved test cases only.      Art:  >  o Create a zip file (named latest.zip) at the top of the repo.  This  >   zip will be updated as new TCs are added.  This zip may include  >   TCs that have not yet been approved by the WG.      Personally I would find latest.zip more useful if it did not include  unapproved TCs.    There is a maintenance issue here - is it realistic to update latest.zip on  every change.      As a test case user I would like to have a single URL that I go to to check  conformance with the latest WG decisions. Obviously that can link to other  URLs. Also a time lag is acceptable.    Jeremy        

        PatrickS:  > Please begin vigorous backpeddaling ;-)  >  Brian:  >   ... I suggest the WG should prefer an  > acceptable alternative    Having achieved the near miracle of getting Brian and Patrick to agree on  something ...    I won't backpedal before today's telecon but thought I should sketch the  possibilities:    0) rewording to satisfy Patrick's "the lexical form is not a pair"  I stuck the lexical form is a pair in very late in the day, to try and get  section 2.4.4 to flow more smoothly. See below.    1) (only very slight change)    Explicitly prohibit datatypes other than the two predefined types from  using the language identifier in the map. This could be accompanied by (0).    2) back to 'majority' view    This is like (1) except that the two predefined datatypes are instead  expanded as two alternative types of literal. The language IDs are present  and ignored.    3) back to (nearly) 'minority' view     In the datatyped literals there is no language identifier.  (This seems to be Brian's preference)    ====  lexical form explanation:    The text I had problems with was:  [[[  The datatypes used in RDF have either:    + A lexical space consisiting of a set of strings (for example any datatypes  from XML Schema).    Or:  + A lexical space consisiting of a set of pairs: each being a string with a  language tag (for example the two predefined types).  ]]]  and some of the other text in 2.4.4.    This is where the pair (string + lang) originated from.     I could change this to be either a set of stings (first bullet) or a set of  literals (second bullet) [a literal being a triple: including the (constant)  datatypeURI]. That way I could drop the pair/pair way of expressing a  triple.      ===    I note that the chair is weighting concerns about potential feedback we  might receive more highly than the actual feedback we have already received.    Jeremy        

        For RDF Core, a significant part of Martin's comments is the last paragraph  below.  In RDF terms I read it as advocating that the labels of the nodes in the RDF  graph are US-ASCII URIs not IRIs (although implementations should maintain  the original character sequence).    So far I've heard:  - Jeremy, maybe Dan, maybe Larry, in favour of using "IRIs" (at least  original character sequences) as the labels on the RDF graph  - Martin, somehow Aaron as in favour of using US-ASCII URIs as the labels on  the RDF graph.    This is characerised by test 003 in    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Apr/att-0116/01-charm  od-uri.htm    Denying test003 is agreeing that labels are US ASCII URIs.    Equivalently that is that    http://example.org/#Andr%C3%A9    and    http://example.org/#Andre    are completely equivalent and interchangeable. The only observable  difference in behaviour that may be expected is the exact form used by a  viewer or output device.    I am happy to go either way, although I find it difficult to see how to  state the normal form constraint that I think is important.    Consider the US ASCII URI    http://example.org/#Andre%CC%81    where %CC%81 is the UTF-8 encoding of character #x301 the combining acute  accent.    This is, like any US ASCII URI, in Normal Form C, despite the UTF-8 original  character sequence not being in NFC. I don't think I can support or propose  that we prohibit those US ASCII URIs that when viewed as a UTF-8 encoded  original characeter sequence correspond to original character sequences that  are not in NFC. I think a "NOTE: " somewhere about this would be close to  incomprehensible. Going down this path, in my view, limits us to saying  non-normative things about RDF platforms not using OCS's which are not NFC,  but using the corresponding US ASCII URI instead. I could write a  non-normative appendix to our syntax spec that said all this. We could  modify some of the fraud examples to show legal test cases that used the  US-ASCII form of the problematic IRIs.    Jeremy            Jeremy:  > >[[[  > >2.3 Mapping of IRIs to URIs  > >  > >This section defines how to map an IRI to a URI. Everything in  > >this section applies also to IRI references and URI references, as  > >well as components thereoff (e.g. fragment identifiers).  > >  > >This mapping has two purposes:  > >  > >   a) Syntactical: Many URI schemes and components define additional  > >      syntactical restrictions not captured in Section 2.2. Such  > >      restrictions can be applied to IRIs by noting that IRIs are only  > >      valid if they map to syntactically valid URIs. This means that  > >      such syntactical restrictions do not have to be defined again  > >      on the IRI level.  > >  > >   b) Interpretational: URIs identify resources in various ways. IRIs  > >      also indentify resources. The resource that an IRI identifies is  > >      the same as the one identified by the URI obtained after  > >      converting the IRI according to the procedure defined here.  > >      This means that there is no need to define the association  > >      between identifier and resource again on the IRI level.  > >]]]  > >  > >This seems to suggest that we should do the mapping before the  > model theory;  > >which is in tension with the usual refusal to normalize URIs for scheme  > >case, hostname case, port number, missing default path, or anything else,  > >except as part of actually executing the protocol.    Martin:  > Clearing up escape issues is one step before casing issues.  > Most escape issues (for a-zA-Z0-9, everything outside US-ASCII,  > plus a few specials) are completely independent of the scheme,  > they apply to all URIs. Case and the other stuff is very much  > scheme-dependent. This is a big difference.  >    Jeremy:  > >It is potentially self-inconsistent with the phrase:  > >  > >[[[  > >However, this mapping SHOULD only be applied when necessary, as late  > >as possible.  > >]]]    Martin:  > No, it is not. For RDF, it would just mean that when you compare,  > you may want to apply it, but you wouldn't convert and stay there;  > you would keep the original.  >        

        No it doesn't.    Consider:    <ex:age, rdfd:datatype, xsd:string>  <ex:age, rdfd:datatype, xsd:integer>  <Jenny, ex:age, "10">    Fine by the MT, "10" is in the lexical space of both datatypes.    No "TDL" pair in sight. (Or perhaps the point is that there are two TDL  inconsistent pairs around - but no inconsistency in the MT).    Jeremy      Patrick:  >>> ... the combination of the  >>> inline idiom and the rdfd:range/datatype assertion designates  >>> the pairing <xsd:integer, "10"> and that pairing is the basis  >>> for any datatyping interpretation. I.e., the knowledge in the  >>> graph unambiguously identifies a single value by designating  >>> a datatyped literal pairing. What that actual  >>> value is, we don't know *at this level*. But at a higher level  >>> where the full knowledge of xsd:integer is available, then  >>> we know that the pairing <xsd:integer, "10"> identifies the  >>> value ten.  >>>        

      > rdf-charmod-uris: Does the treatment of uris conform to charmod ?    > We need an owner to check this    Again I would prefer not to own this.  However, we did discuss this a bit in the thread:    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Oct/0330.html    My understanding of where we got to was:    In RDF URIrefs are used as unique labels.    The uniqueness is important and so an important aspect is being able to  compare to URIs from different sources and saying that they are the same or  not.    M&S specifies a URIref as per RFC 2396. I understand that as being (a subset  of) US-ASCII only, and hence not charmod conformant.    A required change is to permit the full range of unicode characters in URIs  wherever a URIref is permitted in the RDF/XML grammar.    Such an international URI is subject to a standard algorithm (given in  charmod) to convert it into a US-ASCII URI.    We need to ensure that:  - a URI when given using international characters, and when given using  US-ASCII compares equal.      This can be done by one of the following three techniques:  [A] normalizing URIs on input to US-ASCII  [B] normalizing URIs on input to international form  [C] using the URI normalization algorithm as part of the URI compare  algorithm.    [C] looks inefficient and inelegant.  [B] doesn't work, because a US-ASCII URI with % escapes in it does not  specify the charset used for the encoding, whereas the algorithm the other  way assumes UTF-8.    Thus I believe [A] is the answer.  This normalization should be done in a non-ambiguous way and so I favour  specifying that the hexadecimal escape sequences e.g. "%A3" should not use  a-f but use A-F instead. This allows binary compare.  It also means that:  - %hh must be normalized to %HH where hh is a pair of hexadecimal lower case  digits.  - % is not allowed in the international form of a URI except for introducing  hexadecimal escape sequences. A URI that really does contain a % must then  be encoded by the original document author as "%25"    I can produce some test cases illustrating this, in which RDF/XML documents  with mixed usage of international and US ASCII URIs work successfully.    I suggest that N-Triple be restricted to US ASCII URIs only. N-Triple is not  intended as an end user document format and internationalization concerns do  not apply.    Jeremy        

            I note that this lexical space thread will need restarting once we have  decided the value space :(    Jeremy        > -----Original Message-----  > From: w3c-rdfcore-wg-request@w3.org  > [mailto:w3c-rdfcore-wg-request@w3.org]On Behalf Of Graham Klyne  > Sent: 31 July 2003 20:18  > To: Brian McBride; w3c-rdfcore-wg@w3.org  > Cc: Peter F. Patel-Schneider  > Subject: Re: xml literal lex space question  >  >  >  > [This message rambles a bit... for my final suggestion, skip to ****]  >  > I agree, and suggest:  >  > [[  > The lexical space  >      is the set of all Unicode strings which:  >  >          * are well-balanced, self-contained XML data [XML];  >          * when encoded using UTF-8 yield exclusive Canonical XML  >            (with comments, with empty InclusiveNamespaces PrefixList )  >            [XML-XC14N];  > ]]  >  > It occurs to me that the source of confusion may be:  > [[  > The lexical-to-value mapping  >      maps a string to the corresponding exclusive Canonical XML (with  > comments, with empty InclusiveNamespaces PrefixList ).  > ]]  > --  > http://www.w3.org/2001/sw/RDFCore/TR/WD-rdf-concepts-20030117/#sec  > tion-XMLLiteral  >  > when, now that the canonicalization is handled by the parser, all  > we really  > need to say is:  > [[  > The lexical-to-value mapping  >      is UTF-8 encoding of the lexical form (yielding an octet sequence)  > ]]  >  > It which case, the lexical space description might be:  > [[  > The lexical space  >      is the set of all Unicode strings which are mapped by the  >      lexical-to-value mapping to exclusive canonical XML  >      (with comments, with empty InclusiveNamespaces PrefixList )  >      [XML-XC14N];  > ]]  >  > But hang on, we already have:  > [[  > The value space  >      is the set of all exclusive Canonical XML (with comments, with empty  > InclusiveNamespaces PrefixList ), which when embedded within an arbitrary  > XML start tag and an end tag form a document conforming to XML Namespaces  > [XML-NS].  > ]]  >  > So even that is redundant.  Maybe:  >  > [[  > The lexical space  >      is the set of Unicode strings which are mapped by  >      UTF-8 encoding to valid XMNL literal values (see below)  > ]]  >  > ****  >  > Putting it all together, and polishing a little, my suggestion is:  >  > [[  > The lexical space  >      is the set of Unicode strings which are mapped by  >      UTF-8 encoding to valid XML literal values (see below)  >  > The lexical-to-value mapping  >      is UTF-8 encoding (yielding an octet sequence, where octets are  >      distinct from characters)  >  > The value space  >      is the set of all exclusive Canonical XML (with comments,  >      with empty InclusiveNamespaces PrefixList ), which when embedded  >      within an arbitrary XML start tag and an end tag form a document  >      conforming to XML Namespaces [XML-NS].  > ]]  >  > #g  > --  >  > At 16:11 31/07/03 +0100, Brian McBride wrote:  >  > >A question has come up on comments.  Is "<ex/>" in the lexical space  > >rdf:XMLLiteral.  I believe not, it must be "<ex></ex>", but  > wanted to check.  > >  > >The text in concepts is:  > >  > >http://www.w3.org/2001/sw/RDFCore/TR/WD-rdf-concepts-20030117/#se  > ction-XMLLiteral  > >  > >[[  > >The lexical space  > >     is the set of all strings which:  > >  > >         * are well-balanced, self-contained XML data [XML];  > >         * correspond to exclusive Canonical XML (with comments, with  > > empty InclusiveNamespaces PrefixList ) [XML-XC14N];  > >]]  > >  > >The corresponds to will need clarification.  > >  > >Brian  >  > ---------------------------------  > Graham Klyne  <GK@NineByNine.net>  > Nine by Nine  > http://www.ninebynine.net/  >  >        

          I attach the new test case.  I still haven't worked out how to update the W3C site.    The text of the comment is:  ===      This example is not legal XML, and hence should be rejected    by RDF/XML processors.       The XML error is in the rdf:about attribute, where the ampersand    does not introduce a reference.        Sample error message:       The reference to entity "def" must end with the ';' delimiter.      The intended XML document is probably that in       http://www.w3.org/2000/10/rdf-tests/rdfcore/amp-in-url/test001.rdf    ===    The sample error message was produced by Xerces.    Jeremy            text/xml attachment: error001.rdf          

            I have done a lot of the things on the list I posted yesterday:  (in particular all that impact the text)      >   > Issue to check williams-02  > =====================  > http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2003Apr/0128.html      > http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2003May/0138.html  >  jjc Review concepts to make consequential changes concerning typed literals  >  jjc Provide anchor for rdf:XMLLiteral to Pat Hayes  >   > http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2003May/0031.html      > 20030502#12 jjc update the Concepts WD with words after discussion with PatH   > and GK based on 2003Apr/0368.html text  > (have not had the discussion)  > 15:26:16 <db-scribe> bwm: to jjc, maybe need to point ot last para of   > explanation  > 15:26:29 <db-scribe> jjc: asks path for help rewording, editorially after   > decision  > 15:27:27 <bwm> ack gk  > 15:27:27 <Zakim> gk, you wanted to suggest a small tweak to jeremy's proposal  > 15:27:28 <Zakim> * Zakim sees no one on the speaker queue  > 15:27:36 <db-scribe> jjc points out rewording of first sentence  > 15:27:47 <db-scribe> gkgk: asks that it be made more inclusive as first   > setence, broader      Discussion started.    >   >   > http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2003Apr/0097.html  > 2003-03-28#9  > jjc update Concepts in light of XML Schema LC review editorial comments  > ACTION: jeremy to add anchors to Concepts for def of canonicalistion, and for   > Impl Note  >   >   > http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2003Mar/0138.html  >   > ACTION 2003-03-21#6 jjc: review  >     > http://www.w3.org/2001/sw/RDFCore/TR/WD-rdf-concepts-20030117/#section-rdf-graph  >   in concepts WD after proposal to change in  >   http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2003Mar/0114.html  >   and circulate changes to the WG.  >   > ACTION 2003-03-21#7 jjc: review   >     > http://www.w3.org/2001/sw/RDFCore/TR/WD-rdf-concepts-20030117/#section-blank-nodes  >   in concepts WD after proposal to change in  >   http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2003Mar/0114.html  >   and propose change/non-change or further clarification to the WG.  >   > http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2003Feb/0082.html  > ACTION 2003-02-07#2 (jjc) ensure CONCEPTS is accurate on its use of  >         subject/predicate/object terminology  >   >   >   >   >   >     All of the above actions are now complete.    Jeremy        

        Action done     see    http://lists.w3.org/Archives/Public/xml-names-editor/2002May/0001.html    Jeremy        

          I am taking a long weekend this week.    I am happy to take an action to propose a goofy literal resolution for next   week.    Jeremy        

            Graham Klyne wrote:    >   > FWIW, I think Pat's proposal is marginally easier to implement than what   > we have at the present, and considerably easier than some approaches   > that have been suggested.  >   > (Just an opinion based on my implementation perspective.)      For an implementor who is implementing datatypes then the current solution   requires *no work* except in the parser, and the defn of an L2V mapping   which is essentially the identity.    Pat's solution requires work all over the place, and does not require less   work in the parser.    Implementing from scratch, without datatypes, and not implementing   datatypes at all, I would concede that Pat's solution is possibly easier.    Jeremy        

      >  > To conclude that Jenny's ex:age is ten would be a mistake, an invalid  > inference. We should make this painfully clear to users, so they do  > not get their RDF in a muddle.  >    Smell the coffee!    The WG did agree at the f2f that the lack of "jeremy's entailment" was an  issue.    Pat is speaking wisdom here. "jeremy's entailment" cannot possibly hold if  Jenny's ex:age is the string "10".    The WG can't have its tidiness cake and eat it.    Carping from the sidelines    Jeremy        

          At the F2F I said something about liking a WD before publishing a note.    It was minuted thus in the log:    http://www.w3.org/2004/03/05-swbp-irc#T13-59-18  [... discussion of publication of WD then Note... patent implications of  WDs...]    I withdraw my comments concerning IPR.  I retain the desire that there be a clear point for public review of the  documents we publish.    (I am advised that what I said was incorrect legally ...)    Sorry for any confusion.    Jeremy        

        > - Rec docs sanity check    I am unavailable from tomorrow (telecon start time) to make any changes to  Concepts - until 9th Feb, which I hope will be too late.    Things which might be considered:    - deleting the change log  - updating the OWL and RDF references following Sandro's message to WebOnt.    I could do these before the telecon if someone asks me to do so today.      Jeremy        

          Sumamry:  A short piece in defence of Patrick's account of WG decisions;  a longer piece in self-defence (against Patrick!) with a more detailed  proposal for a "no global" (but untidy) datatyping/model theory solution.    In defense of Patrick ...    Patrick:  >> This has already been rejected by the WG.  DanC:  >I don't recall any such decision.  Patrick:  >> The WG has already decided that datatyping should work by one of the  >> two proposed options,  DanC:  >which decision are you referring to here?    I think  http://www.w3.org/2001/sw/RDFCore/20020225-f2f/#d-2002-02-26-3  covers both of these. Specifically committing us to a particular version of  datatyping (supporting (A)) except in response to a particular problem with  (D) being noted as a problem.    ===    In self defense ...    Patrick:  >Sorry Jeremy, but I don't see your proposal  >as constituting "substantial progress". It's a step backwards.    Substantial progress towards consensus may be a step backwards on some other  measure.    Patrick:  >Of those that chose to explicitly respond as requested to Brian's  >inquiry, there is overwhelming preference for untidy semantics  >(almost unanimous).    Not quite as overwhelming as all that, but I would hope sufficiently so to  make the WG reluctant to continue with tidy literal semantics.    Patrick:  >Most importantly, the tidy/untidy issue is as much about the model theory  as  >it is about datatypes    that's true. To punt on this would require more care.      It won't have escaped your attention that I have been a steadfast advocate  of untidy literals. As a result, at Cannes, I was in a minority that got  outvoted. After this, I tried hard to work out what were the minimal changes  needed to the WG's position to make it possible for me to no longer object.  One of the possible changes then, for me, was to drop the global idiom.    Now, you argue (and I agree) that the tables have turned. However, i still  see a minority with strongly felt opinions. My understanding of the  consensus process is that we should avoid steam-rollering minorities with  strong opinions lest they be right. (Not that they are in this case :)) A  minority (particularly a minority of more than one) should be accomodated as  much as possible.    I tried to suggest that no global idiom would be more acceptable than a  global idiom that was unacceptable to at least three members of the WG, and  some other members of the community.    Pat's second RDF Model Theory document did have a solution to the meaning of  literals that was vague enough to satisfy everyone a bit (and nobody  completely?).    http://www.w3.org/TR/2002/WD-rdf-mt-20020214/    Key features were:    - literal were syntactically untidy  - no constraints were put on the mapping from literals to their values  - the range of the XL mapping was not necessarily a subset of the set IR  "Note that no particular relationship is assumed between IR and LV."    Since in that MT the entailment from    <jenny> <age> "10" .    to    <jenny> <age> _:x .    does not hold, it has actually remained fairly neutral on the truth or  falsity of the (A) questions. Moreover, the (D) question can't be asked  without a global idiom.      Thus to make a more concrete proposal for just having a local idiom:    + use the Valentine's day MT  + use the local idiom  + for each datatype the value space is a subset of IR (this ensures that  bNodes can match datatyped values)    For someone who wishes to view this with tidy literal semantics, they are  free to restrict their view to interpretations in which XL is so restricted.    Is anyone interested in this?    Jeremy        

          Hi Patrick,    note I've moved off-list, but copying to www-archive.  This allows the conversion to be public domain but not in-your-face for the  rest of the group.    Assuming the telecon OKs the plan we've just agreed, I suggest we propose  that we do our work off-list in this way. This should help reduce RDF Core  bandwidth utilisation.    I like your pictures, I think they are really helpful.    I think we should decide which horse to back and forget the others for now.    My reckoning is that S is leading the race, and PL is in the race, and both  are different from the sort of solutions we have been in favour of.    For me, the race will be won on rdf-interest (not rdf-core), hence the  familiarity of the PD proposal is IMO the key.    So I suggest restricting our write-up to PD, and forgetting, for now, U and  P++.    Any thoughts?      On the maths ...    Your suggested framework ...    [[[[[    1. Take up to section 4.1 as a starting point (rework section 3 and     remove sections 4.2 onwards, including section 5).    2. Add math in or following section 4.1 that states that for any pairing           (lexical_form, data_type_URIref)       there is one and only one mapping           (lexical_form, data_value)       between the lexical space and value space of that data type.    Surely the math for this is straightforward (I wish I could provide it).    3. Add final sections detailing the idioms P and D, how they define such     pairings of lexical form and data type.    ]]]]]]]    I started thinking about this and got a bit of nervous.    So far, we have decided not to have a processing model for RDF: step 3 above  looks like creeping towards one, and overall this looks like an extra layer  in our analysis.    I am beginning to see the attraction of trying to do it all in the model  theory, which, as far as I understand, Pat made a stab at in:    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Nov/0011.html    "Datatypes and MT"    I am beginning to feel that I need to bite the bullet and build on top of  Pat's work and actually do some model theory.    Then your diagrams and some text would be the informal part, and we simply  wouldn't have the intermediate level math that would actually be useful to  an implementor!    My understanding is the MT route that we have taken overall is a decision to  leave implementation to implementators and to prioritise being clear over  being at the right level for implementators.    I am flying out to the WebOnt F2F this weekend, I will try and have a stab  at PD model theory on the plane. ("stab" is perhaps an unfortunate turn of  phrase).    Jeremy        

          I don't think we should be suggesting that the meaning of a URI might differ  from that of a URI with a slightly different spelling.    We have remained silent on the relationship between    http://foobar and http://foobar:80/    and I think we should remain silent. The advice in RFC 2396 bis to avoid  forms like the latter of these two is good.    For example using    http://www.w3.org/1999/02/22-rdf-syntax-ns    in place of    http://www.w3.org/1999/02/22-rdf-syntax-ns#    does not work operationally, but I would not commit myself to making that a  semantic truism.    However, I would not object to being a co-signatory on your suggested  textual change.    Jeremy      > -----Original Message-----  > From: w3c-rdfcore-wg-request@w3.org  > [mailto:w3c-rdfcore-wg-request@w3.org]On Behalf Of Graham Klyne  > Sent: 17 February 2004 16:53  > To: Jeremy Carroll; rdf core  > Subject: RE: Heads up: RFC2996bis, possible problem for RDF  >  >  >  > At 15:30 17/02/04 +0100, Jeremy Carroll wrote:  > >This does not look disastrous to me.  > >  > >In RDF URIrefs ending in # (i.e. with explicitly empty fragment) only  > >regularly occur as namespace names. All possible uses of such URIrefs  > >involve qnames which give them a non-emtpy fragment part.  > >  > >The text in question  > >  > >"URI producers and normalizers should omit a delimiter if the  > component it  > >delimits is empty"  > >  > >uses a "should" not a "MUST", and is hence sufficiently weak.  >  > Yes, but the text also seems to claim that it is always safe to apply the  > normalization.  That is my concern.  Section 6.1 says "...  while  > strictly  > avoiding false positives".  >  > >We perhaps could suggest modifying the text:  > >[[  > >  > >, with one exception: a double-slash delimiter indicating an authority  > >component should not be removed, even when the authority is empty, since  > >doing so can lead to misinterpreting the path.  > >]]  > >http://gbiv.com/protocols/uri/rev-2002/rfc2396bis.html#normalize-empty  > >  > >to  > >[[  > >. A first exception is: a double-slash delimiter indicating an authority  > >component should not be removed, even when the authority is empty, since  > >doing so can lead to misinterpreting the path.  > >A second exception is: a common idiom in RDF/XML uses URI references with  > >empty fragments as XML namespace names.  > >]]  >  > I think it would also apply to empty path and query components,  > so I'm not  > happy to just pick out empty fragments as a second exception.  >  > >The overall normalization rules in section 6  > >http://gbiv.com/protocols/uri/rev-2002/rfc2396bis.html#comparison  > >inevitable create a many positive matches that are not honoured in RDF  > >concepts. Like XML namespaces we chose the simplest possible  > definition of  > >equality: string equality. The overall tone of section 6 ought to respect  > >such a choice.  >  > Yes.  I'm waiting to see what response to my comments, but I  > think I might  > suggest that the text:  > [[  > Therefore, comparison methods are designed to minimize false negatives  > while strictly avoiding false positives  > ]] -- (section 6.1)  >  > be something like  > [[  > Therefore, comparison methods are designed to minimize false negatives  > while strictly avoiding false positives when used for purposes of  > retrieval.  > ]]  >  > (This echoes the earlier comment "URI comparison is performed in  > respect to  > some particular purpose" [section 6 intro], and I think provides the  > necessary escape route for RDF and XML namespaces and maybe other  > purposes  > to which URIs are pressed.)  >  > #g  > --  >  > > > -----Original Message-----  > > > From: w3c-rdfcore-wg-request@w3.org  > > > [mailto:w3c-rdfcore-wg-request@w3.org]On Behalf Of Graham Klyne  > > > Sent: 17 February 2004 13:17  > > > To: rdf core  > > > Subject: Heads up: RFC2996bis, possible problem for RDF  > > >  > > >  > > >  > > > I've just reviewed:  > > >  > > >     http://gbiv.com/protocols/uri/rev-2002/rfc2396bis.html  > > > Modified: 16 February 2004 11:36:15  > > > Size: 167.42 KB (171437 bytes)  > > >  > > > Which has recently been "last called" in the IETF URI  > informal group in  > > > preparation for an IESG last-call request, per:  > > >    http://lists.w3.org/Archives/Public/uri/2004Feb/0082.html  > > >  > > > I am concerned that the empty component normalization rules may be  > > > troublesome for RDF.  My review comments are at:  > > >    http://lists.w3.org/Archives/Public/uri/2004Feb/0094.html  > > >  > > > The specific example raised is:  > > >  > > > [[[[  > > > Section 6.2.2.3:  > > > I'm concerned about empty component normalization:  > > > In RDF usage, the URIs:  > > >      http://example.org/  > > > and  > > >      http://example.org#  > > > would result in quite distinct resource identifiers, e.g. in:  > > >  > > > [[  > > > Triples of the Data Model in N-Triples Format (Sub, Pred, Obj)  > > >  > > > <http://www.w3.org/RDF/Validator/run/foo>  > > > <http://example.org/prop> "value" .  > > >  > > > The original RDF/XML document  > > >  > > > 1: <?xml version="1.0"?>  > > > 2: <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"  > > > 3:   xmlns="http://example.org/">  > > > 4:   <rdf:Description rdf:about="foo">  > > > 5:     <prop>value</prop>  > > > 6:   </rdf:Description>  > > > 7: </rdf:RDF>  > > > ]]  > > >  > > > and  > > >  > > > [[  > > > Triples of the Data Model in N-Triples Format (Sub, Pred, Obj)  > > >  > > > <http://www.w3.org/RDF/Validator/run/foo>  > > > <http://example.org#prop> "value" .  > > >  > > > The original RDF/XML document  > > >  > > > 1: <?xml version="1.0"?>  > > > 2: <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"  > > > 3:   xmlns="http://example.org#">  > > > 4:   <rdf:Description rdf:about="foo">  > > > 5:     <prop>value</prop>  > > > 6:   </rdf:Description>  > > > 7: </rdf:RDF>  > > > ]]  > > >  > > > (RDF triples generated by http://www.w3.org/RDF/Validator/)  > > >  > > > Are distinct RDF graphs, even though the URIs are equivalent under the  > > > normalization rules given.  > > > ]]]]  > > >  > > > #g  > > >  > > >  > > > ------------  > > > Graham Klyne  > > > For email:  > > > http://www.ninebynine.org/#Contact  > > >  > > >  >  > ------------  > Graham Klyne  > For email:  > http://www.ninebynine.org/#Contact  >  >        

          > I went back to the paragraph above and added the emphasis keywords.  >  > [[[  > This specification allows some freedom to choose exactly what string  > is used as the lexical form of an XML Literal.  Whatever string is  > used, it MUST correspond to an XML document when enclosed within a  > start and end element tag, and its canonicalization (without  > comments, as defined in [REF]) MUST be the same as the same  > canonicalization of the literal text l.  It is acceptable to use l  > without any changes but this is incorrect if, for example, l uses  > entity references or namespace prefixes defined in the outer XML  > document.  > ]]]  >  > If MUST is used above, then X14CN becomes normative.  And I'm worried  > when we add new normative refs.  We may have to weaken that to SHOULD.  >  > I think  >    "but this is incorrect if, for example"  > might have to be rewritten in the emphasis form something like:  >    "but this MUST NOT be used if, for example,..."  >  > ?  >  >  > I just noticed  > http://www.w3.org/TR/2002/WD-rdf-concepts-20021108/#section-XMLLiteral  > refers to: Canonical XML [XML-C14N] (with comments).  >  > so is it with/without comments?  >      Sorry I have been sleeping ...    Your text looks fine to me, with one word addition    "It is acceptable to use l without any changes"  ==>  "It is often acceptable to use l without any changes"      We use to have a normative ref to XC14N in concepts, this in turn  normatively refers to C14N.  So, moving the XC14N ref to syntax, and having a C14N ref in concepts is  *not* adding to the normative refs burden, just clarifying its size.    On the comments issue the mapping from the syntax to the lexical form was  agreed as with or without comments at implementation descretion.  Hence the minimal requirement is without comments, which is why your text is  good.  However, IMO, if the implementation chooses to keep the comments in the  mapping to lexical form, then it should also keep them in the datatype  lexical-to-value mapping.    This last point I decided arbitrarily at editor's descretion. (invitation to  challenge/discuss that judgement) I guess it would be consistent with the WG  decisions to also allow that dattaype l2v mapping to be implementation  dependent. I prefer to localize the implementation dependency in one spot,  and the syntax doc seems the right place (sorry).    Jeremy        

        [More on query also a substantial clarification of why I "can't live with"  S-B. It encourages unsafe type processing within the application layer].    Lets look at the example query first:    [[[     _:f <dc:Title> "10" .     <mary> <age> "10" .    Given a query:       (?x <dc:Title> ?y) & (?z <age> ?y)    existing applications will return:       ?x = _:f, ?y = "10", ?z = <mary>    ]]]    RDF Query is of course, still an active research area, rather than one where  there is any stable deployed code base. (There is deployed code, but it is  in development).    Hence, discussion about query semantics would perhaps be better placed on  rdf-query, but ...      Under S-B (the relevant idiom here) and RDF M&S, the only possible meaning  of whether two literal nodes are equal is whether their labels are equal.    Suppose RDF M&S and S-B are read untidily then each distinct triple with a  literal as object has a distinct literal as object. There is no mechanism  for indicating that two literals are the same or different except by their  label.    Since the query is asking us to compare two literal nodes, under S-B or RDF  M&S there is only one possibility, compare their labels. Both the new  (untidy) model theory and TDL suggest a second possibility, that of  comparing the values associated with the literal nodes. Neither rule out the  old possibility, they simply permit a new possibility. It is deceptive to  suggest something is not backwardly compatible simply because it offers a  better alternative, while allowing the old deprecated approach.      ===    In terms of the syntactic transformation mapping TDL into S-P [1] the data  in this example becomes:       _:f <dc:Title> _:t .     _:t <rdf:value> "10" .     <mary> <age> _:a .     _:a <rdf:value> "10" .    (I use this transformation for explanatory purposes, I would not implement  TDL like this).    Now, both _:t and _:a can take possible values including < "10", "10" >  (string reading) and < "10", 10 > (numeric reading).  Hence the query as originally formulated is now false. However, if we wish  to execute the query in a backwards compatibility mode, we would expect it  to compare literal nodes using their string labels, rather than their  values.    Hence, the query, in this S-P style, would be equivalent to:         [ (?x <dc:Title> ?t) & (?t <rdf:value> ?y)      & (?z <age> ?a) & (?a <rdf:value> ?y) ]  // checking literal label  equality  |     [ (?x <dc:Title> ?y) & (?z <age> ?y) ]  // checking non-literal node  equality    This could all happen in response to dispatching node equality method on the  basis of the type of the nodes being compared, and on the presence or not of  a backwards compatibility flag.    ====    Now Patrick has argued that comparing on values is correct.  Dan and Sergey argue that comparing on labels is correct (described by them  using tidiness).    TDL allows clarity about this distinction, and allows query researchers to  explore both possibilities.    ====    This framework allows me to illustrate an aspect of my "can't live" issue  with S-B.    S-B allows range constraints, in this example perhaps:    <dc:title> <rdfs:range> <xsd:string.lex> .  <age> <rdfs:range> <xsd:integer.lex> .    I currently understand S-B as, within the RDF datatyping layer, insisting  that "10" is a string.  The two range constraints are used to:  - constrain the set of possible strings  - act as a hint to the application layer that:     * type conversion is possible     * type conversion is desirable.    Thus given the database and the schema the application processing will  correctly treat the title as a string, and the age as an integer. Good.    Now, the query also operates in the application layer.  This returns true.    Thus in the application layer we have the following facts being the case:    The film has the title "10".    mary has age 10.    The age of mary is the title of the film.     i.e. that 10 is "10"    There is a type clash here, and the combination is a logical error.    Thus, S-B maintains a theoretical purity by pushing all typing problems into  the application layer. Moreover it apparantly licenses the unwary  application developer into during contradictory conclusions.    So, S-B is seriously flawed in that it does not assist the application  developer to avoid logical errors associated with datatyping.    =====    Let's now explore this same error from the point of TDL.  TDL requires a clarification of the query, are we speaking about the values,  or are we speaking about the lexical forms.    If we are talking about the values, then the query is only true if we have  compatible type declarations for both literal nodes. Since we are not, we  cannot conclude that    The age of mary is the title of the film.  hence we avoid the error.    If on the other hand we are talking about the lexicalizations we have:     The age of mary as a string is the title of the film as a string.     i.e. 10 as a string is "10" as a string    So TDL assists the application developer in being logically correct.        ----    Brian, I would be very much obliged if you can condense this example to add  to your summary list of concrete "can't live with" issues on the proposals.  My title would be "S-B encourages logically errors in the application type  processing."    PS. Sergey attacked Patrick's list of "can't live with" issues as largely  advocacy of TDL; I do tend to feel that an aspect of "can't live with" is  comparative. Logical errors happen, no framework prevents all logical  errors. Choosing a framework that is logically unsafe when an alternative  safe framework is available is folly. However, modifications to S-B that  assisted the application to make logically safe type inferences would be a  substantial improvement that would address one of my major concerns.        Jeremy      [1]Jeremy Carroll: Re: Datatyping Summary  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Jan/0369.html        

            Jim, Guus    your local organizers think we should start and end relatively late, i.e.  meet at 9.30 a.m. and finish at 6.00 p.m. This is to avoid the worst of the  traffic.    HP will provide a coach between the hotel and HP.    Julie will send a provisional food and drink agenda to you next week.    Jeremy        

        > I agree as well, but with the caveat that those other documents need to   > be written too!        Now's the time to be writing for WWW 2002    Jeremy        

      > 1. In your email: should we emit a namespace for prefixes found in an  > attribute value (or even element content?!).      My take on that was that the rational intent of exclusive C14N was not to  emit such a namespace.    One reason is simply the difficulty of computing such a fact. If I had used  an XSLT example with attribute values being XPath expressions then precisely  which namespaces are being used there is non-trivial to tell. I suspect if  one wanted to supported XSLT in the full, (including element content) then  the question of which namespace prefixes were being (invisibly) used may  even be Turing complete!    I found the choices made in the two specs on this issue quite  understandable.    Jeremy        

          Are the two documents descriptions of the same graph?    <rdf:RDF>    <rdf:Description>      <eg:prop xsi:type="xsd:decimal">2.0</eg:prop>    </rdf:Description>  </rdf:RDF>        <rdf:RDF>    <rdf:Description>      <eg:prop xsi:type="xsd:decimal">2.00</eg:prop>    </rdf:Description>  </rdf:RDF>    I think I heard yes.    Furthermore is this the same:    <rdf:RDF>    <rdf:Description>      <eg:prop xsi:type="xsd:int">2</eg:prop>    </rdf:Description>  </rdf:RDF>    I suspect it is too?    Jeremy        

      Jeremy:  > >    Semantics:                  Model Theory  > >    Second Level Abstraction:   Graph  > >    First Level Abstraction:    Triples (Multiset)  > >    Concrete Syntax:            RDF/XML & N-Triple  > >  > >  > >I guess last week I was assuming that the first level abstraction was not  > >useful.  >    Pat:  > Model theory not useful!??! Humph!!      Just in case you're not deliberately misreading me ...    By 'first level abstraction' I meant the same as the 'First Level  Abstraction' i.e. the notion of the bag of triples.    I wouldn't want to slight the model theory at all (well not this time at  least :) ).        Jeremy        

        Update on where I've got to:    Best bits:  + Worked example of how the rules generate triples    http://www-uk.hpl.hp.com/people/jjc/snail/example/z213.nt.html      + Snail home page, "Excruciatingly Slow RDF/XML Parsing"    http://www-uk.hpl.hp.com/people/jjc/snail/      ------------------      The example was computed by snail which is now working;   download from:    http://www-uk.hpl.hp.com/people/jjc/snail/download.html      there have been some minor changes to the rules which can be found in:    http://www-uk.hpl.hp.com/people/jjc/docs/triples/      ====================================    I would appreciate feedback as to:    + does this approach clarify triple production in RDF/XML?  + if so, is it suitable for the Syntax WD  + if so, should the XSLT parts be omitted or retained?      Jeremy        

            Jan Grant wrote:      > ACTION: 2003-08-29#1 daveb track down LC comments on wrapper solution \  > for XMLLiteral  >   >   [ DaveB pointed these out:  > wrapper comment 1:  > http://lists.w3.org/Archives/Public/www-rdf-comments/2002OctDec/0109.html  >         I had missed that one ... can I be given an action to e-mail the commentor   to ask him specifically whether he likes the recent changes.  (after next publication).    Jeremy        

          Regrets for tomorrow - I have too much work on + family crisis, sorry.    Jeremy        

            Brian McBride wrote:    > At 15:16 21/10/2002 +0200, Jeremy Carroll wrote:  >   > [...]  >   >> Another thing, which negatively impacts DaveB, is that it then becomes  >> clearer that some of the C14N stuff about XML Literals probably ends   >> up in  >> the syntax doc. I could try and work out what.  >   >   > That sounds a bit worrying.  How large a change is this?  Is it really   > necessary?  >   > Brian  >     This isn't *new* text - just text we already have getting reparented - with   all the necessary adoption papers etc.    The problem is already a point of unclarity I suspect in our current round   of drafts.    It's to do with what triple gets emitted in Dave's doc for a   parseType="Literal"      Jeremy        

            Brian McBride wrote:    > b) advice to the CG about what to do about postponed issues      Personally I prefer not to discuss postponed issues (for new recs?) until   we've got this one in the bag.    As HP rep the position I represented was we did not need to resolve these   issues in this standardization round. For the next few weeks that remains   the position I wish to represent.    When we get to rec, I have things that I individually think about the   postponed issues and could contribute to a discussion.    Sorry for being so cautious.    Jeremy        

          Pat:  > C15. The list of Satisfactions looks good, but omits the one rather  > central one which I guess people didnt think to write out explicitly:  > that the idiom used actually means what it ought to mean.    I understand this as meaning that when people write "10" and say that it is  an integer they mean it to be an integer. Not a string, not a pair, but an  integer.    A partial response is simply to say well, nobody got there.  S-A does achieve that in the model theory, but S-B leaves it as a string,  S-P and TDL both use a pair.  If anyone can propose a model theory for either TDL or S that consistently  gets us to values that would almost certainly be an excellent proposal.    I now give a very long digression before responding to the comment.    Please note:   - I am trying very hard to be balanced in this message.   - I have deleted some "knocking S" copy.   - I even say "S-A is the best" below.    DIGRESSION - DATATYPING, THEORY & APPLICATION  =============================================    I'll give a more accurate rendition of my current understanding, which is  inspired by both Brian's "the line"    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Jan/0420.html      and Graham's clarification about the lexical string/value distinction:    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Jan/0395.html  [[[  Jeremy:  >TDL allows clarity about this distinction, and allows query researchers to  >explore both possibilities.    Graham:  So does S.  In the case of S, the method used (value or literal) is  explicit in the vocabulary used.  (For me this is an observation, not a  show-stopper either way.)  ]]]      We seem to be doing RDF with model theory and some programming above model  theory. I will call this enterprise "applied model theory".    I am assuming that the datatyping discussion is about how RDF/XML document  authors and RDF applications communicate and process typed values, and what  responsibilities lie where, and how clarity is maintained in such  communication and processing.    In the old M&S, there was only a data model and no model theory in the logic  sense, and no datatypes. So reasoning about entailment, satisfiability, and  typed values etc. and all responsibility for consistency etc. lies in the  application code:      M&S:  |X|Application Code:  |9|   Consistency, datatyping etc.  |8|  |7|  |6|  |5|  |4|  |3|  |2|============================  |1| Theory: Data model      Some of the datatyping and consistency may be being done by a generic RDF  platform, but that is not part of the standard, and is still conceptually  (at least from the standards viewpoint) application code.    [The numbers down the left of my pictures is just to allow you to print them  off and line them up. Please use HP toner and ink while printing :) ].    With the model theory, the RDF theory now takes responsibility for  consistency, entailment etc.  New Model Theory:  |X|Application Code:  |9|   Datatyping etc.  |8|  |7|  |6|  |5|============================  |4|   Entailment  |3|   Consistency  |2|   Data Model  |1| Theory    The application is still responsible for some logical coherency in what it  does. For example unconstrained type conversion may lead to consistency  problems as in    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Jan/0430.html  Issue B8      S-B is the most conservative datatyping idiom, in that the model theory  still operates entirely at the lexical representation level. Only a very  small extra amount of work is done by the lower layer, that of checking that  type conversion is possible. (But the type conversion is not actually done).    S-B:  |X|Application Code:  |9|   Datatype conversion etc.  |8|  |7|  |6|============================  |5| (small dt support)  |4|   Entailment  |3|   Consistency  |2|   Data Model  |1| Theory    and the application layer is still responsible for the consistency of type  conversation.    S-P and TDL are equivalent and in both the lower layer does the conversion  but only partially in that it does not take responsibility for when to  detach the value from the lexical form.    S-P, TDL:  |X|Application Code:  |9|   Appropriate use of  |8|   string or value  |7|============================  |6|  |5|   Datatype conversion  |4|   Entailment  |3|   Consistency  |2|   Data Model  |1| Theory    From this point of view, S-A is the best on the table, in that it serves up  to the application the typed values it needs to use, and the theory takes  responsibilty for all aspects of datatyping.    S-A:  |X|Application Code:  |9|  |8| ============================  |7|  |6|   Dropping of lexical string  |5|   Datatype conversion  |4|   Entailment  |3|   Consistency  |2|   Data Model  |1| Theory      With this view the choices facing us vis-a-vis datatyping are:    - choose only S-A and deprecate all other idioms.    This is the theoretically most appealling route in my view.  - choose the mixed approach S = S-A + S-B + S-P    This allows document authors to choose which set of    responsibilites they want to take; and how much support    they expect from the model theory.    Applications either have to restrict themselves to    some sub-idiom or be able to cope with the mix.  - choose one of { nothing, S-P/TDL, S-B }    + Doing nothing is known to work - i.e. we know the      downsides of not having any datatyping support and      it isn't appalling.    + S-B (only) is a low risk approach to putting      a bit of datatyping in.    + TDL offers more datatyping support than S-B.      Applications still need to determine whether      to look at typed values or the literal strings.    END DIGRESSION  ==============    > C15. The list of Satisfactions looks good, but omits the one rather  > central one which I guess people didnt think to write out explicitly:  > that the idiom used actually means what it ought to mean.  >    So, in TDL and S-P, the model theory ends at a literal-value pair, which  isn't 'what it ought to mean'.  That's not saying that that's where the application ends, thats where the  application starts. It is an improvement on the current position of the  application starting with a string before getting to 'what it ought to  mean'. It isn't as good as S-A. But then S-A, by itself, doesn't meet some  of the (non model theoretic) desiderata.      Jeremy      PS:  Pat:  > Guys, sorry Im only now getting up to speed on this stuff, and if any  > of these questions/issues have been already covered in the email  > record then just say so and I'll get to them eventually.      Your questions were refreshingly different from the rather tired discussion  that the rest of us have been having.        

        Pat:  > It means that being a lean graph is potentially a very costly  > property to check, whereas I thought it was fairly trivial. Which  > means that in general, checking non-entailment between two graphs is  > potentially expensive.  >    Agreed - simple entailment is probably NP complete    (I am not absolutely sure: the subgraph isomorphism problem (which is NP) is  closely related, but I do not have an exact embedding).    The result for conceptual graphs (irredunancy is NP complete) is probably  applicable to RDFS entailment, but again it is real work to show this.    Jeremy        

      > On Fri, 24 May 2002, Jeremy Carroll wrote:  >  > > <rdf:RDF>  > >  <rdf:Description rdf:about="http://example.org/"/>  > > </rdf:RDF>  >  > FWIW, I always mentally parse this as syntactic longhand for:  >  >  <rdf:RDF>  >   <rdfs:Resource rdf:about="http://example.org/"/>  >  </rdf:RDF>  >  > 'rdf:Description' is a way of saying "there is a resource and  > it has the  > following (URI, properties...)". But it doesn't explicitly assert the  > 'there exists a thing and it is of rdf:type rdfs:Resource  > bit. Which is  > fine, cos everything's a resource, so its a pretty vacuous  > assertion to  > make.    This differs from Dave's position I fear.    If we take the rdfs schema closure of the graph corresponding to the  given RDF/XML file then it contains two triples    rdf:type rdf:type rdf:Property .  http://example.org/ rdf:type rdfs:Resource .    (according to DanB).    This can be formalized within our current framework by saying that an  RDF Graph is a set of nodes and a set of arcs, where each arc is a  triple [ subj, pred, obj ] where subj and obj are in the set of nodes.    Dave's position can be formalized as saying that an RDF Graph is a set  of arcs, and the nodes in the graph are defined as the set of nodes in  the arcs. Isolated nodes that do not partake in any triples are  prohibited.    I currently agree with Dave, but fear this looks like an issue.    Jeremy        

          Another possible test case -  as far as I can tell  xsd:NCName and xsd:ID have the same L, V and L2V, but have different names.    In OWL Full (which admittedly is not our problem), under the LC document we  would have had:    xsd:NCName owl:sameIndividualAs xsd:ID .    being a consistent document.    With the current editor's draft the same document is inconsistent.    I wonder whether Pat's treatment could be changed slightly so that the set D  rather than being a set of datatypes, is a set of pairs of (urirefs and  datatypes).    Then D must be a subset of I (the interpretation function in the MT), which  gets the naming constraint Pat is trying to introduce.      I suspect Pat could make that work ... is it worth his effort?    Jeremy        

          Current status of mine:    >   > ACTION 20030815#9 jjc  >   draft implementation report response to i18n objection    Done  >   > ACTION 2003-09-12#3 jjc  >   mention other designs in I18N proposed response    Not done, will try to do this before telecon  >   >   > ACTION 20030919#1 jjc  >   review syntax text on bnode IDs  >     Done  >   > ACTION 20030919#3 jjc  >   change URI text in concepts  >     Done  >   > ACTION 20030919#4 jjc  >   respond to pfps on URIs cc martin  >   >     Done  http://lists.w3.org/Archives/Public/www-rdf-comments/2003JulSep/0346.html    but peter is still not happy ...    http://lists.w3.org/Archives/Public/www-rdf-comments/2003JulSep/0348.html    >   >   > ACTION 20030919#9 jjc  >   e-mail webont with 02 Oct comment deadline    Done  http://lists.w3.org/Archives/Public/www-webont-wg/2003Sep/0222.html    >   > ACTION 20030919#13 jjc  >   suggest herman makes personal comment before webont OK    Done        

          This is a coment concerning    http://www.w3.org/TR/2002/REC-xmldsig-core-20020212/      We have been reading this recommendation trying to understand how to   make best use of it for signing RDF documents.  We are finding it useful.  We are embedding signatures so formed within further RDF documents and   ideally wish to reuse parts of your RDF data model:    http://www.w3.org/TR/2002/REC-xmldsig-core-20020212/xmldsig-datamodel-20000112.gif    However, there does not seem to be a corresponding namespace or RDF   schema document or ....    If there is such a document, please can you send a pointer. If not,   please can we have the source code for your gif, that will probably be   better than nothing!    If there is such a document I suggest that an erratum including the link   in section 9 should be considered.    Jeremy Carroll (working with Chris Bizer)        

          I appoint Brian as proxy on any votes.    (On the xml:lang issue I suspect "concur" is OK)        (I hope this can count towards quorum if necessary)    Jeremy        

        Jeff:  >  >             I sometimes find myself wavering between whether we  > should develop general use cases or core requirements.  >    I think the other groups are doing the use case thing, and that we should  make the most of taking a different approach, and being up front about that.    I thought Jeff's  > SUPPORTED TASKS:  > Which use cases (or classes of use cases) will benefit from this  > requirement?    adequately captured the need to ground hypothetical requirements in reality,  but we should resist the urge to end with output that pretends to reverse  the direction of our thinking.    In particular this would suggest that if we think a requirement is needed  for one of the other use-case groups we should not do much work on it; and  concentrate our efforts on the gaps between the other groups.    Jeremy        

        B3 log:implies    [[[  DanC is concerened that with TDL:       <mary> <haircolor> "red" .    and a rule:       ?x <haircolor> "red" => ?x <rdf:type> <redhead> .    one cannot conclude       <mary> <rdf:type> <rdfhead> .  ]]]    There is of course a reification in here, with a use/mention issue! Let's  have three contentious issues in one example.    I wonder whether the TDL ==> S-P syntactic transform [1] is useful here:  (Again only for explanatory purposes, not an implementation suggestion).    If we had    <mary> <haircolor> _:a.    _:a <rdf:value> "red".    and the rule      ?x <haircolor> ?y .    ?y <rdf:value> "red" .       =>    ?x <rdf:type> <redhead> .    then I can see a reading of the rule so that it fires, without any range  constraint.    As I am saying (msg with same delivery time) about the query (B4) TDL  clairifies that one could be talking about the lexical form, or one could be  talking about the value, and permitting a decision about which seems like a  good choice to expose to the layer aboce RDF.    So, in answer to Brian's question.  Is the range constraint required by TDL?    No. It depends on the rule semantics chosen.    The rule implementator is free to choose.    In Dan's case I think he should consistently use the lexical forms of  lexical nodes in the interpreation of the rules. I think I am saying that in  a form #2 reification in [2], literal nodes should be mentions, i.e. in the  model theory map them to the lexical form and ignore the value. But then  form #2 was dropped.      [1]Jeremy Carroll: Re: Datatyping Summary  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Jan/0369.html      [2] Jan Grant. Proposals? Re: use/mention and reification  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Jan/0236.html        

        >    2B:  >  >    Monotonicity and the open world assumption on type information.  >    S (idiom B and P) is non-monotonic with respect to type information,  >    or at least forces the RDF application to behave as if the  >    underlying theory were non-monotonic.  > [Sorry this is rather obscure, I will ask for a clarification about S-P,  > which will illustrate my concerns]      In S-P as I understand it rdf:value is understood in relation to the known  datatypes:    [[[[      In other words, rdf:value "extracts" the lexical representation from a given  pair:    EXT(I(rdf:value)) := {<<x,y>, y> | <x,y> is an element of a datatype  mapping}    (Notice that for the above definition to be well-formed, we need to be able  to enumerate all datatype mappings. This can be done using special  vocabulary e.g., xsd:date.map rdfs:subClassOf rdfdt:DatatypeMapping).      ]]]]    So for example, in a  minimal RDF implementation in which we only have  strings rdf:value is a 1-1 mapping. Thus in that sort of implementation we  would have:      _:a <foo> _:b .  _:b <rdf:value> "string" .  _:c <bar> _:d .  _:d <rdf:value> "string" .    implies    _:a <foo> _:b .  _:c <bar> _:b .      (in the premise both _:b and _:d are < "string", "string" > )    If a second RDF implementation has a greater range of datatypes then it may  be the case that "string" can map to something else. In this case the  implication above does not hold.    e.g. if we support xsd:string and xsd:integer then we have the following:    _:a <foo> _:b .  _:b <rdf:value> "1000" .  _:c <bar> _:d .  _:d <rdf:value> "1000" .    does not imply    _:a <foo> _:b .  _:c <bar> _:b .      I believe the semantic web will be built on the systematic application of  the open world assumption.    S-P requires a closed world assumption on datatypes, that results in  defeasible implication, and hence non-interoperability. This is a  significant concern.    Similarly S-B seems to require applications to make similar defeasible  typing above the RDF layer. Without any type information a string should be  treated as a string. In the light of a single range constraint the  application should treat the string in accordance with that datatype. If  multiple range constraints apply to the same lexical node then it is unclear  what an application should do.    So S-B also suffers non-monoticity but in the application layer.    Jeremy        

        * REVISED VERSION *  In particular note the NEW BIT which is stuff that arised from the e-mail exchange last week but  didn't get discussed at the telecon.  If people don't like it, an alternative is to delete that comment, and possibly put sections 1,2  back into the general endorsement part.    A question for the group, one of the conformance requirements is that "Every W3C specification MUST  specify that implementations MUST conform to the requirements applicable to software,".  While this is not unreasonable it jars with the RDF recs that we are writing in that we do not talk  about how to implement RDF hardly at all. If we were aiming at charmod conformance we could stick a  charmod conformance section in, that would say that amongst other things; but it would be a little  strange. Can anyone draft a comment that captures this anxiety; or am I just being overly nervous.    Perhaps someone better with words than me can combine this worry with that expressed in the NEW BIT  and the UNCHANGED comment on section 3.5 - there is this common theme that charmod assumes a certain  sort of recommendation which we are not.    ................      > =========  >  > The RDF Core WG has feedback concerning the following sections  > of charmod:  >  > 1. Introduction  > 2. Conformance  > 3.4 Strings  > 3.5 Reference Processing Model  > 4. Early Uniform Normalization  > 6. String Identity Matching  > 8. Characeter Encoding in URI References  > 9. Referencing the Unicode Standard  > A.2 Other References  > C. Composing Characters  > D. Resources for Normalization  >  >    RDF Core makes no comments on the other sections.    *** MODIFIED, (TONED DOWN) ***  For the sections 3.4, 4, 6, 9, C, D  RDF Core endorses the last call working draft.  We have found earlier drafts helpful in identifying how best to meet our  responsibilities to RDF users world wide.  (However, we do not intend to address all the requirements of these sections in the version of the  RDF recommendations currently in working draft).    *** NEW BIT ***  Concerning sections 1 and 2 RDF Core is concerned that the scope of charmod is overly broad.  In particular, there appears to be no acknowledgement that some languages being defined by W3C  working groups may not be intended as web languages and hence not have a need to address  internationalization issues. (A particular counterexample is the language N-Triples defined in the  RDF Test Cases WD). There may be an implicit (and false) assumption that all W3C recommendations  specify (only) web languages with processing models.        *** UNCHANGED ***  > For the section 3.5 we note that the language is somewhat offputting for us  > as specification developers given that our specification explicitly does  > not have a processing model. We have no particular suggestions about this,  > nor would we object if the I18N WG chose not to address this issue.  >      *** STRENGTHENED ***  The main concern of the RDF Core WG is section 8.  Any normative section of charmod MUST NOT depend  on the IETF IRI draft which is not finished and is not yet stable.      We draw attention to "SHOULD use Internationalized Resource Identifiers (IRI) [I-D IRI]".  The IRI draft is only a draft, the reference to it is not normative, and the strength of this SHOULD  dependency appears excessive ("not optional").  In particular, the IRI draft does not adequately address IRI equality (not merely functional  equivalence in retrieval). Moreover, the bidi section presents a learning curve which developers are  unlikely to want to climb before IRI has consensus around it; We have found the text in Xlink  section 5.4 and XML Erratum 26 adequately clear for some of the IRI questions, particularly those  that are most pressing for RDF and believe that charmod should merely:  - reiterate such text;  - reiterate the early uniform normalization model for the iris when    regarded as unicode strings    *** DROPPED comment about being superceded ***    Jeremy        

        >  > RDF C14N Inclusive or Exclusive (B)  > ===============================  > Discussion of the differences between the two C14N specs.  >    C14N provides two quite different treatment of namespaces.  These two specs also differ in their treatment of attributes in the XML  namespace, (see below).    Background  ==========  People using XML envelopes found the earlier inclusive canonicalization spec  a little problematic, in that information from the envelope ended up in the  canonical version of the payload. Exclusive C14N is intended to be useful  for such applications. rdf:parseType="Literal" appears to be such an  enveloping application and so we should seriously consider exclusive C14N.      Namespaces  ==========    In the inclusive treatment all namespaces on a node are made explicit in the  canonical form.    In the exclusive treatment only those that are visibly utilized on elements  qnames or attribute qnames are made explicit.    http://www.w3.org/TR/xml-exc-c14n#def-visibly-utilizes    As an example consider:      <rdf:Description    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"    xmlns:xsd="http://www.w3.org/2001/XMLSchema"    xml:lang="en"    xmlns:eg="http://example.org/">    <eg:bar rdf:parseType="Literal">      <foo xsi:type="xsd:decimal">10.09</foo>    </eg:bar>  </rdf:Description>    Under inclusive C14N the literal value is:    "\n    <foo xml:lang="en" xmlns="" xmlns:eg="http://example.org/"  xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"  xmlns:xsd="http://www.w3.org/2001/XMLSchema"  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  xsi:type="xsd:decimal">10.09</foo>\n  "    although I've probably got the attributes in the wrong order.    All the namespaces, including the rdf one (which must be present because of  rdf:parseType) are present.    Under exclusive C14N the literal value is:  "\n    <foo xmlns="" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  xsi:type="xsd:decimal">10.09</foo>\n  "    because only the xsi and default namespaces are visibly used.    I note that in some sense the exclusive C14N has got this example wrong,  since we need to preserve the binding of the xsd prefix to preserve the  semantics of this example.      Attributes in the XML namespace  ===============================    Note that the exclusive form does not copy the xml:lang attribute, whereas  the inclusive form does.        

          Is there a group photo somewhere? e.g. from a F2F meeting?    (I don't have a strong preference for which F2F meeting)    Jeremy        

          Dave Reynolds wrote:  [[    Yes I put in rdfs12a and 12b this morning to confirm it could be done,   though I haven't checked the changes into CVS.    Approximate effort:     - 5 mins to enter rules and have code ready to run     - 10 mins to enter a test case and add it to harness     - 5-10 mins to track down three typos in my test case data!    Dave    ]]    We will be needing these rules for the OWL Lite reasoner whatever the WG   decides.    Jeremy        

          Hi,    this is a contribution to the social meaning discussion that came from the   HP rep on the patent policy group.    I am imagining an action on someone to collect a list of pointers for the   CG taking the rdfms-assertion issue forward, and hope this might be   included. Scott has a perspective that is informed in a different way from   many of the participants in the discussion.    Jeremy    -------- Original Message --------  Subject: RE: Social meaning discussion  Date: Thu, 6 Mar 2003 11:42:05 -0500  From: "PETERSON,SCOTT K (HP-USA,ex1)" <scott.k.peterson@hp.com>    Jeremy --    I'll plan to attend the meeting.    I've taken a look at section 4 and at the agenda document. Here are some  current thoughts.    I am presently, strongly inclined toward the conclusion that the binary  concept that an RDF statement is asserted or not asserted is of such limited  utility in forming a foundation for development of social meaning that it  might be actually be counterproductive: it may be counterproductive if the  establishment of this concept impedes the development of more elaborate  concepts.    "Human publishers of RDF content commit themselves to the  mechanically-inferred social obligations."    I see two different interpretations of this sentence.    A response to one interpretation:  It is not apparent to me that social meaning survives mechanical  transformations. I would expect social conventions to result in some social  meaning for a transformed result, but it is not apparent that in all cases  the social meaning of the transformation is mechanically related to the  social meaning of the original, untransformed statement.  Assume some statement X and a mechanical transformation it, Y. It is not  apparent that in all cases the social meaning of X and the social meaning of  Y will be mechanically related, or, in other words, it is not apparent that  there will necessarily be some mechanical relationship between the social  meaning of X and the social meaning of Y.    A response to a second interpretation:  The sentence is like the unhelpful sentence: "x has the social obligations  that are x's social obligations".    "The act of assertion needs some mechanism (e.g. signatures) to carry much  legal force: Peterson"    It would be useful to provide mechanisms to aid people in expressing the  character of their statements, such as the purpose for which the statement  is being made, degree of the commitment to the statement, who is making the  commitment, etc.  Like locks and walls of various types, these technical constructs do not  make law, but are very useful to the law in that social conventions can form  around the use of such technical constructs - for example, social  conventions might not form as readily and/or might not be as clear, if the  technical construct did not exist.    Consider the statement:  "The body color of vehicle #x matches Pantone color #y.  Consider the following contexts:  (1) on an individual's personal homepage that is reporting tedious detail  about the individual's personal life.  (2) a report submitted to the police by the observer of a traffic accident.  (3) a page describing items that are available for sale.  (4) a communication from a seller of the vehicle to the buyer of the vehicle  where the seller is an individual selling their personal car and the buyer  is a dealer in cars.  (5) a communication from a seller of the vehicle to the buyer of the vehicle  where the seller is a dealer in cars and the buyer is an individual  purchasing a car for their personal use.    The social and legal consequences of the statement being misdescriptive of  the actual car will vary significantly depending on the context.    I see similarities between social meaning and trust. This suggests the  possibility that hooks to aid social meaning might be implemented in higher  layers.    -- Scott  ______________________________  Scott K. Peterson  Corporate Counsel  Hewlett-Packard Company  One Cambridge Center  Cambridge, MA 02142  scott.k.peterson@hp.com        

      Brian:  > There must be a strong call from the community to make the change.      I suspect most of the members of the community who understand this issue  are in the WG.    Brian:   > We should resist the temptation to fix things that we don't like but are not  > really broken.      Agreed. This is really broken. Argued elsewhere.    It acts as a significant barrier to the use of the RDF/XML reification  syntax, and hence as a barrier to the use of reification. If reification  is a good thing (which is moot, but I think we should assume) then this  needs fixing.    Jeremy        

          I particularly appreciate the care taken with the unicode escape   production to exclude those things that do not need escaping.    Jeremy        

            Martin Duerst wrote:  ...    > 2) To have the RDF parser handle the fact that for plain text strings,  >    sometimes there may be an rdf:parseType="Literal", and sometimes not?    ...    >   > In my view, the best solution is clearly 2).  >   >   > By the way, I was just trying to check to what extent the actual RDF  > Model and Syntax spec is expressing the fact that its authors (or at  > least one of them, Ralph) thought that rdf:parseType="Literal" without  > any actual markup is the same as a plain literal.  >   > Here is what I have found:  >   >    3. If E is an empty element (no content), v is the resource whose  >       identifier is given by the resource attribute of E. If the content  >       of E contains no XML markup or if parseType="Literal" is specified  >       in the start tag of E then v is the content of E (a literal).   > Otherwise,  >       the content of E must be another Description or container and v is   > the  >       resource named by the (possibly implicit) ID or about of that   > Description  >       or container.  >   > This does not make any distinction WHATSOEVER between  >    <foo>literal text</foo>  > and  >    <foo rdf:parseType="Literal">literal text</foo>  >   > Also, the definition of Literal does not distinguish between what's  > now called 'plain' and 'XML' literals:  >   > Literal  >    The most primitive value type represented in RDF, typically a string of  >    characters. The content of a literal is not interpreted by RDF itself  >    and may contain additional XML markup. Literals are distinguished from  >    Resources in that the RDF model does not permit literals to be the   > subject  >    of a statement.  >   > If you have found evidence to the contrary, please tell me.      I agree with your reading of M&S (although I would defer to Brian or DaveB   on this one), unfortunately that was not found workable. Applications   needed to know whether the markup was an XML literal or not. In the absence   of helpful advice from M&S some RDF applications returned effectively an   additional bit of information indicating whether it was a   parseType="Literal" or not.    RDF Core was chartered to fix bugs in M&S and this was an area where there   were definitely bugs. e.g. the mathml example in M&S requires mechanisms   that are not even hionted at, and we have not provided with clear, if   somewhat difficult text, defering to exc-c14n.    So in brief, M&S was broken, and we were required to fix it.    ...      >> The current phrasing in the editors draft defers to the term exclusive   >> canonical XML:  >> http://www.w3.org/TR/2002/REC-xml-exc-c14n-20020718/#def-exclusive-canonica   >> l-XML  >   >     Martin:    > Just before we forget it, at that place, 'exclusive canonicalization'  > is defined as follows:  > "The exclusive canonical form of a document subset is a physical   > representation  > of the XPath node-set, as an octet sequence, produced by the method   > described  > in this specification"  >   > While the 'physical representation' may have been important for the people  > working on digital signatures, it seems definitely the wrong thing for RDF.  > I hope this can be fixed.        I agree its clunky - I don't believe it is cost effective to fix it.  RDF Core should be defering to an XML group as to appropriate   representations of XML. We require that equality is well-defined. The only   XML groups we found when we determined the main outline of this design two   years ago was the c14n group. When they also penned exc-c14n it was clearly   a better fit.      >   > What is much more important, if using exclusive canonical XML means that  > the xml:lang context of the XML literal in the RDF document is ignored,  > then that's totally wrong.       If that's totally wrong, then why is it not wrong for SOAP, or other   applications of exc-c14n?  This seems to be a comment about exc-c14n rather than RDF.    >It:  > - has never been accepted by the I18N WG (RDF Core agreed with that)    agreed    > - is against the XML 1.0 Recommendation    in as much as exc-c14n is.    > - is against the RDF Model and Syntax Recommendation    M&S is somewhat vague, but I would concede this point.    > - is against the recent RDF last calls    yes.    > - is the opposite of what happens with plain literals, and therefore  >   highly confusing for users.    depends on the application.  I would suspect this is true for XHTML based XML literals, which I would   view as the main application.  See below about confusion.    >   > To make sure xml:lang is not thrown away for XML literals, there is  > no need to change exclusive canonical XML.     We lose xml:lang by using exc-c14n out of the box ... viz:  [[  attributes in the XML namespace, such as xml:lang and xml:space are not   imported into orphan nodes of the document subset  ]]    Because of this, in the LC docs we had a complicated and confusing   work-around that involved putting the xml-literal inside an <rdf-wrapper>   tag, whose sole purpose was to hold the xml:lang attribute. It is certainly   less confusing to have ditched all of that.    >As for plain literals,  > xml:lang can be carried separately.  >       This is current behaviour.    > Maybe I wasn't clear enough above. What we are asking for is not that  > RDF provide a mechanism so that all the following four can be seen  > as one and the same thing.  >   > 1) Text (without markup or language information)  > 2) Text with language information (but no markup)  > 3) Text with markup (but no language info)  > 4) Text with markup and language information  >   > What we are asking for is just that all syntactic artefacts that fall   > within  > any single of the above categories are treated the same, i.e. that in   > addition  > to the four categories above, we don't create any spurious additional ones.  >   >   >> To me this looks like application space, in which semantic web   >> application layers, that are currently not particularly subscribed in     (typo: I meant described not subscribed)    >> W3C documents, get to call the shots.  >   >   > What you refer to, i.e. ignoring markup or ignoring (a suffix of) a   > language  > tag *across* the categories above, can definitely go into application   > space.  > What applications should not have to bother with is spurious differences  > between what is one and the same thing, i.e. *within* any of the four  > categories listed above.  >     >   >   >> The different between an XML document and related strings is complex,   >> and probably goes beyond the bounds of what can be systematically   >> defined.  >>  >> e.g.  >>  >> If we are searching for instances of the word "pot" which of the   >> following bits of XML should count as a match:  >>  >> "<em>pot</em>"  >> "<pot/>"  >> "<eg eg:pot='h' xmlns:eg='http://eg.org/'/>"  >>  >> etc.  >   >   > good question. But if we are searching for 'pot' in the following  > two examples:  >    <foo rdf:parseType='Literal'>pot</foo>  > and  >    <foo>pot</foo>  > would you ever expect an application to return one and not the other?  >     I think you could ask the same question about searching for the string   "100" and wondering whether the number written as "7.5100" is a match or   not. I don't find the use of datatyping for XMLLiterals forced and unnatural.       <foo rdf:dataType='&xsd;decimal'>7.5100</foo>    and       <foo>7.5100</foo>    If you really just want to treat the RDF/XML as text data use a text editor.        >   > Regards,    Martin.    Jeremy        

          Copying to i18n to request help on correct application of charmod. See the   two paragraphs between ****.      This is a proposed draft, note I suggest additional text for concepts, and   and still need additional text for syntax -    [[    Dear Peter    thanks for your comments concerning NFC  http://lists.w3.org/Archives/Public/www-rdf-comments/2003JulSep/0283  http://lists.w3.org/Archives/Public/www-rdf-comments/2003JulSep/0225      These comments also apply to XSD datatypes derived from xsd:string and   xsd:anyURI, so we will respond in full generality.    (e.g. The two character string { e, NON SPACING ACUTE } is a legal   xsd:string that can be 'written' in RDF/XML (in XML 1.0) but does not   correspond to a legal RDF graph.)    We also agree that there are XML 1.0 fragments that can be written within a   an rdf:parseType="Literal" element in an XML 1.0 document that conforms to   the RDF/XML syntax except that this fragment is not in NFC.  However, this would not be an RDF/XML document, since there is no   corresponding RDF graph.    You are correct to point out that this constraint is not made explicitly in   the syntax document, and this is a bug.      Concepts places a similar constraint on the lexical form of all datatypes   e.g. xsd:string, whereas syntax suggests that there is no such constraint e.g.  7.2.16  http://www.w3.org/TR/rdf-syntax-grammar/#literalPropertyElt  [[  If the rdf:datatype attribute d is given then o :=   typed-literal(literal-value := t.string-value, literal-datatype :=   d.string-value) otherwise t.string-value MUST be a Unicode[UNICODE] string   in Normal Form C[NFC], o := literal(literal-value := t.string-value,   literal-language := e.language)  ]]    This text needs modifying.        1. NFC constraint in general    You suggest that RDF should drop the NFC constraint completely.  This would clearly solve the problems you raise.    However, the RDF Core WG has endeavoured to follow charmod  (http://www.w3.org/TR/charmod)  as much as possible, as one of the key inputs from the I18N community.    See  4.4 Responsibility for Normalization  http://www.w3.org/TR/charmod/#sec-NormalizationApplication    [[  [S]  Specifications of text-based formats and protocols SHOULD, as part of   their syntax definition, require that the text be in normalized form.  ]]  [[  [S]  Specifications of text-based languages and protocols SHOULD define   precisely the construct boundaries necessary to obtain a complete   definition of full-normalization. These definitions SHOULD include at least   the boundaries between markup and character data as well as entity   boundaries (if the language has any include mechanism) and SHOULD include   any other boundary that may create denormalization when instances of the   language are processed.  ]]    ****  The RDF Core WG has previously identified the lexical form of literals as   the relevant construct, around which NFC should be required.  While we have been aware of transitional issues, since the specs we build   on (XML 1.0 and XSD) do not require NFC, we do not see those issues as   insufficient to not migrate the RDF recommendation.    It is clear that applications working with XML 1.0 and the current version   of XSD datatypes may choose to be more lenient than this part of our   specification, and then what they should do, is also clarified in charmod.   i.e. they must not normalize. Since the recommendation is clear that these   are errors, the responsibility for fixing them is clear.  ****    2. Clarity of RDF Concepts document    We have made the following changes to concepts:    In section 5  [[  The lexical space of a datatype is a set of Unicode [UNICODE] strings.  ]]  to  [[  The lexical space of a datatype is a set of Unicode [UNICODE] strings in   Normal Form C [NFC].  ]]    and in 5.1  [[  The lexical space  is the set of all strings:  ]]  to    [[  The lexical space  is the set of all strings:  - in Normal Form C [NFC].  ]]        3. syntax document    [TBD]      ]]        

          The following comment was agreed, and I have sent it to the comments list   (it has not shown up though).    I point out that all the parties with a declared interest, except for Peter   Crowther, were at the meeting and agreed to this resolution.    In particular Patel-Schneider and Parsia who raised issues with the   section, and Connolly, Brickley, Eric Miller and Berners-Lee (amongst   others) for W3C (who originally raised the issue rdfms-assertion).    I have asked Crowther to endorse the resolution.    Jeremy    -------- Original Message --------  Subject: RDF Concepts - section 4  Date: Thu, 06 Mar 2003 23:07:23 +0000  From: Jeremy Carroll <jjc@hplb.hpl.hp.com>      The Semantic Web Architecture meeting at the W3C tech plenary  resolved unanimously to this message.    We suggest that:  - section 4 is struck  - postpone rdfms-assertion  - strike other text concerning rdfms-assertion  - CG prioritise work on this issue,      co-ordinated with the TAG over URI denotation.      Jeremy Carroll.        

          See latest comment from Tex; we might be off the hook.  http://lists.w3.org/Archives/Public/www-rdf-comments/2003AprJun/0020.html  [[  1) I now understand that the lowercasing of the lang identifier is  constrained  to the RDF graph.  The proposed text is a better solution as it makes the specification  explicit,  but I would find the test cases as adequate to clarify the issue.  ]]    The "proposed text" was:  [[  > Note: The case normalization of language tags is part of  > the description of the abstract syntax, and implicitly the abstract  > behaviour of RDF applications. It is not intended to constrain an  > RDF implementation to actually normalize the case. Crucially, the result  > of comparing two language tags should not be sensitive to the case of  > the original input.  ]]    The "test cases" were:  [[  > 1) add new test cases to reflect that  >     en-US en-us and en-Us  >     all mean the same thing.  > This would be easy, and unlikely to meet opposition.  ]]    At the time, (a few weeks back), I had entailment tests in mind. I would  prefer *not* to require lower case lang tags in N-triples, and Dave seems  minded to oppose any graph comparison tests dressed up as parser tests.    e.g.    file1:  <a> rdfs:comment "a"@en-us .  file2:  <a> rdfs:comment "a"@en-us .  file3:  <a> rdfs:comment "a"@en-US .    Tests:  file1 entails file2  file2 entails file3  file3 entails file1    So Yet another tex-01 proposal is:  ***  We resolve tex-01 by:  - adding the note above to concepts  - adding the test cases above to the test suite  ***    I am happy with any of the three proposals I have now made, this third is  pretty much like the first:  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2003Mar/0152.html  but the note is shorter.    Jeremy      > -----Original Message-----  > From: Dave Beckett [mailto:dave.beckett@bristol.ac.uk]    > I already asked the WG to stick with canonicalizing the lang tags  > values to 1 form.  I don't care what it is, as long as it is one way.  > Anything else makes simple RDF applications harder.  >        

            Possible unhelpful observation ...    once XML Schema give us a URI for user defined types, and using facilities  in OWL DL then:    define     realComment as an owl:DatatypeProperty with range string of length  1000000 or less.    add an axiom giving    <owl:Class rdf:about="&owl:Thing">    <owl:equivalentClass>      <owl:Restricition>        <owl:onProperty rdf:resource="⪚realComment"/>        <owl:minCardinality rdf:datatype="&xsd:integer"         >&VeryBigNumber;<owl:minCardinality>      </owl:Restriction>    </owl:equivalentClass>  </owl:Class>    As long as &VeryBigNumber; is exactly the number of strings of length  1000000 or less then we have addressed Ian's requirement.    (All possible realComments are necessarily true)  It is hard to know how many strings there are - it might not even be time  constant.    Jeremy        

      [erroneously caught by spam trap -- trying to diagnose -rrs]    Date: Fri, 28 Sep 2001 07:54:46 -0400 (EDT)  Message-ID: <JAEBJCLMIFLKLOJGMELDOEDLCCAA.jjc@hplb.hpl.hp.com>  Received: from tux.w3.org (tux.w3.org [18.29.0.27])  by www19.w3.org (8.9.0/8.9.0) with ESMTP id HAA19557  for <w3c-rdfcore-wg@www19.w3.org>; Fri, 28 Sep 2001 07:54:40 -0400 (EDT)  Received: from hplb.hpl.hp.com (hplb.hpl.hp.com [192.6.10.2])  by tux.w3.org (8.9.3/8.9.3) with ESMTP id HAA10359  for <w3c-rdfcore-wg@w3.org>; Fri, 28 Sep 2001 07:54:40 -0400  Received: from otter.hpl.hp.com (otter.hpl.hp.com [15.144.59.2])  by hplb.hpl.hp.com (8.9.3 (PHNE_22672)/ HPLabs Bristol Relay) with ESMTP  id LAA03335  for <w3c-rdfcore-wg@w3.org>; Fri, 28 Sep 2001 11:44:36 +0100 (BST)  Received: from carrollj2 (carroll-j-2.hpl.hp.com [15.144.90.5])  by otter.hpl.hp.com (8.9.3 (PHNE_22672)/HP-Labs Bristol Internal Mail Hub)  with SMTP id LAA08023;  Fri, 28 Sep 2001 11:44:24 +0100 (BST)  From: "Jeremy Carroll" <jjc@hplb.hpl.hp.com>    DanC:  >  >     rdfms-literal-is-xml-structure : A literal containing XML markup is  >     not a simple string, but is an XML structure.  >  > Jeremy seems to be leading the charge on a related topic  > (2001-09-07#5 Literals); I'd like it if he'd explicitly  > address this issue in his proposal.    I am the official owner, see:    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Aug/0141.html    (penultimate item).    I note your request to more explicitly address this issue. I will be happy  to - but will see what else comes up at todays meeting!    Jeremy        

            A few comments ...    > >  > >Publication of a graph, or an RDF/XML instance, should not equate to  > >assertion.  >  > I don't think that follows. And in any case, its too late to try to  > change this now, seems to me.      Some published RDF/XML docs are asserted, some are not (e.g. WG test cases).  We dropped the sections of RDF Concepts that presumed that  publishing=asserting, partly because there was no consensus.        > Asserting isn't a kind of logical sentence, it's a speech act. It  > stands outside the logical semantics.    English works both to carry content and speech acts, I think the suggestion  is that RDF can carry its own speech act status, and the bootstrapping is in  the user perceptions (the trust layer).    > Well, how about this. Publication is assertion: but what gets  > asserted depends on the publication mode, which is set by an optional  > 'publishMode' property in the RDF XML element tag. If it isnt set,  > then the graph is asserted by the publication: the default case. If  > the mode="quote" then what is asserted by the publication is simply  > that the graph exists and has the name that it has, ie this  > publication is like saying  >  > here is the graph named "ex:foo" : "......"  >  > without asserting the graph itself. This still allows other people to  > import it if they want to assert it.  > The combination of a publication with mode="quote" and then having  > another asserted graph which just imports he first graph is almost  > exactly like publishing the graph plain.  >  > This mechanism is obviously expandable by allowing other values for  > that property, eg maybe someone wants to say publishMode="deny" or  > publishMode="archaic". It even allows for URIs in there pointing to  > hypothetical future ontologies of publication mode types, whatever.  > And it doesn't require any modification to RDF or to OWL, and its  > uniform across media types.  >    I was initially taking this point of view, but it is just more data, and  apart from the bootstrapping problem, putting it all in RDF does seem more  minimalist.    Things can be bootstrapped from English ...    The fact that the WG Tests are not asserted is found in the Test Cases  Recommendations (not that they say so explicitly).    Jeremy        

           > describe anything about which one wants to reason using OWL, then I think   > there's potentially a serious architectural disconnect.    As I understand it,      An OWL DL or OWL Lite reasoner reads both the ontology data and the   instance data and interprets them with the OWL abstract syntax (which has   the the section called facts for such instance data:  http://www.w3.org/TR/owl-semantics/syntax.html#2.2  [[  There are two kinds of facts in the OWL abstract syntax.      The first kind of fact states information about a particular individual, in  the form of classes that the individual belongs to plus properties and values  of that individual.  ]]  )    All of these are subject to the bnode restrictions - although there are   subtle differences between those on the unnamed individuals and those on   the description and restriction nodes. I believe the WG endorsed my   comments on the unnamed individuals and not the description nodes - which   is fair enough.    Graham, if you think you have an issue here that is not covered by the   comments Brian has sent, I would suggest you send a personal comment.    Jeremy        

            text/html attachment: owl2.html          

        Sorry, I got Julie's e-mail address wrong.    ===  Hi,    this thread is intended as a brain storm about the social arrangements for  the  webont f2f in Bristol.    We need:    - a restaurant for Monday night dinner  - something less formal for Sunday, when people are likely to turn up at  various times, and we can't easily commit to a number    I am hoping that we can come up with something ...    The hotel is very near ILRT and the University area    http://www.consignia-online.com/etc/util/mapping.jhtml?addr1=76&pc=BS81LX&db  =ap&height=400&width=400&zoom=NONE&scale=25000      Reading    http://www.seeleys.demon.co.uk/    I wonder whether we might ask for the use of the Spanish Bar on the Sunday  evening? Maybe it would be better to get out though.      Julie Lanfear is helping organise the f2f.    Jeremy        

        Jos,    what was the motive for removing the <code> tags in some of the test   descriptions...?    Genuine question.    (I had put them in, allowing XHTML in the descriptions).    Please copy www-archive or www-webont-wg on correspondence about the test   document, (I am having difficulties getting to my e-mail at the moment).        Jeremy        

          > >  o semantic bugs in domain and range  >  > This is misnamed. There are currently bugs in subClassOf and  > subPropertyOf, and I will fix those bugs in the next draft of the MT.  > The question about domain and range is a genuine question, not a bug:  > we can go either way, and there are arguments in both directions, so  > we have to make a genuine decision. And since, by the way, I seem to  > be in a lone minority on this argument, I am willing to just go with  > the flow and accept the Jeremy entailment (superclasses of ranges are  > also ranges). If that will rapidly reach consensus, please let us  > rapidly reach consensus.    You are only in a minority of one in webont on a different but related  issue.  My take is that there are currently no strong advocates of the "Jeremy  entailment" (I am not one). However, this issue does interrelate with webont  issues - I suggest we:  - decide whether we prefer the Jeremy entailment or not by a straw poll  - indicate that preference to webont  - ask webont to accept this or ask us to change quickly.  (I will create the relevant web issue later today).      >  > >  o semantics of lists  >  > Let me ask that we place lists high on the agenda as we need to get  > this sorted out in order to get the MT done, and Webont needs it, and  > there are apparently some strongly held opinions about it.    As the person with the strongly held opinions I guess I should articulate a  way forward that I could support:  [[      RDF Core provide only syntax  Webont use range constraints etc to convert rdf:List into owl:List    owl:List subClassOf rdf:List  owl:unionOf rdfs:range owl:List  owl:List owl:unionOf << _:nil _:properList >> .  _:nil owl:oneOf << rdf:nil >>  _:properList is restriction on rdf:List to things  with exactly one rdf:first and exactly one rdf:rest.      There is still a need for a magic wand to be cast by Pat or Peter to address  the problem that we really want finite non-circular lists, a constraint that  is not first-order. That wand is cast in WebOnt.      ]]    >  >        

        This is a comment about RFC 2396 that I have been actioned to send on behalf  of the W3C RDF Core Working Group [1]    The key issue concern resolving same document references and/or resolving  against non-hierarchical URIs.    These have been causing us difficulty in using xml:base    As one of our deliverables we produce test cases [2].    A summary table of our URI resolution problems is as follows;  the answers we have agreed are in the attached HTML file.      EASY:  a "http://example.org/dir/file"      "../relfile"  b "http://example.org/dir/file"      "/absfile"  c "http://example.org/dir/file"      "//another.example.org/absfile"    GETTING HARDER:  d "http://example.org/dir/file"      "../../../relfile"  e "http://example.org/dir/file"      ""  f "http://example.org/dir/file"      "#frag"    MASTER CLASS:  g "http://example.org"               "relfile"    h "http://example.org/dir/file#frag" "relfile"  i "http://example.org/dir/file#frag" "#foo"  j "http://example.org/dir/file#frag" ""    k "mailto:Jeremy_Carroll@hp.com"     "#foo"  l "mailto:Jeremy_Carroll@hp.com"     ""  m "mailto:Jeremy_Carroll@hp.com"     "relfile"      We have reached consensus on and approved all these tests except for the  last which some of us consider an error and others resolve as indicated in  the html file.    The rationales for our views are approximately as follows:    d "http://example.org/dir/file"      "../../../relfile"    [[[RFC2396     In practice, some implementations strip leading relative symbolic     elements (".", "..") after applying a relative URI calculation, based     on the theory that compensating for obvious author errors is better     than allowing the request to fail.  ]]]  Not permitted in RDF/XML.    e,f,i,j,k,l  Base does apply to same document references in RDF/XML    g  Failure to insert / is a bug with RFC 2396    h,i,j  Strip frag id from base uri ref before resolving.  Notice j is particularly surprising.    k,l  Same document reference resolution even works for non-hierarchical uris.    m  - no consensus      The test suite is structured as follows:    The positive tests on the test cases web site show a usage of xml:base in  RDF/XML and the resolution of that usage in terms of the RDF graph produced  (with absolute URI ref labels). Each test consists of two files, an RDF/XML  document and an n-triple file (substitute .rdf with .nt in the URL), being a  list of the edges of the graph.    The negative test case shows possibly illegal usage of xml:base in RDF/XML.      Our intent is that these tests will be part of a normative revision of the  RDF recommendation.    Jeremy Carroll  HP Rep W3C RDF Core WG        [1]  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Apr/0008.html  2002-03-22#4:  jeremy Send mailto:uri@w3.org with appropriate tests    [2]  http://www.w3.org/2000/10/rdf-tests/rdfcore/xmlbase/            text/html attachment: uri.html          

      A few comments ...    Patrick:  > > The S idioms, while also doing the job, do so with more machinery and  > > most significantly are contrary to the intuitions of current RDF users  > > (data typing by predicate rather than by rdf:type).    Graham:  > I don't recognize that description of S:  > - I don't see "more machinery" here, whatever that means,  > - "contrary to the intuitions of current RDF users" is precisely one area  > where I think S scores very strongly, based on my intuitions from work  with  > CC/PP (modulo small issues raised in my comments to Sergey's paper).    The machinery I find hard to justify is:   - Needing three URIs for each datatype.     Seems a bit like needing to talk about "Jeremy's body", "Jeremy's soul"  and "Jeremy' mind". Might be useful sometimes, but plain "Jeremy" will get  you a long way. I suppose RDF is about triples!   - Having two incompatible usage idioms (two compatible idioms would somehow  be less cumbersome).   - Always carrying the lexical values in the graph, and having the lexical  values in the model theory.    I find idiom A contrary to my intuitions simply because it is very  unfamiliar, in a way that P & D are not. I find idiom B contrary in its  insistence on talking about the lexical space when what I mean is the type -  it's like a doctor who only cares about my body and not the well-being of me  as a whole.    elsewhere Patrick:  > It appears to me that the S idioms A and B are not compatible    I found that to be the intent of the current document too, and I agree that  it is a problem that the PD combination does not suffer from.    graham:  > The advantage of the S scheme is that is sits comfortably within the  > current model theory.    and again graham:  > Point me to the model theory, and I may be convinced.    I find S a theoretical work that is practically unappealling. The model  theory is the tail not the dog.    Yes, we do need a model theory to capture the PD proposal; but being  well-grounded in the model theory is not the most important consideration.  Most users will have only a passing understanding of the MT, and merely  wished to be reassured by it. If every time they think of a datatype they  need to get unnecessarily involved in the complexities of lexical spaces,  value spaces and the mappings between them they will rightly curse us.    Jeremy        

          Hi Graham,    http://lists.w3.org/Archives/Public/www-archive/2001Jun/att-0021/00-part      Issues which are ours:  ======================  rdfms-assertion  rdf-charmod-uris  rdf-namespace-change (?)  rdfms-identity-anon-resources  rdfms-graph  rdfms-literalsubjects  rdfms-uri-substructure  rdfms-xmllang  rdfms-literal-is-xml-structure  rdfms-identity-of-statements  rdf-charmod-literals    M&S section  intro:    1, 2.1,    para60 (deleted property namespace)  html embedding    para75  graph:    5  namespace    p196 beginning  xml-literals     p203 note  uris    p204  literals    para216-220  xml:lnag    para 221    Issues which are to do with vocab:  ==================================  rdfms-boolean-valued-properties  rdfms-names-use  rdfms-fragments  rdfms-replace-value    rdf;value    2.2.3    2.3  containers    para 90 91    3.5  reification    para 135,    4.1  reserved vocab    para 223    acknowledgements     8.          Issues which might be ours:  ===========================  rdfms-validating-embedded-rdf (own)  rdf-equivalent-representations (not important)  appendix B transporting RDF (drop?)      Looking at schema it is very cut down and does not describe any  semantics for containers and/or reification.    Hence I suggest we should own taking the M&S text forward under issues  to do with vocab, unless the schema or series editors deem otherwise.    Jeremy        

          >   > Patrick S asked, "what if there is no such form?" Well, I choose to  > accept the axiom of choice, which (I think) covers this*.     Was that awful pun intended ???    Jeremy        

        Jos De_Roo wrote:    > Jeremy, this proposal works for me and as I said in  > http://lists.w3.org/Archives/Public/public-swbp-wg/2004Apr/0201.html  > I'm happy to participate in XSCH TF  > what I also believe is that a set of test cases could  > be a supportive deliverable  >       I'll add that to the next draft ... I might wait until we have some   input from XML Schema WG.    Jeremy        

        Chris Bizer wrote:    >>>Using signatures also don't make signing agents special (=owners),  >>>because  >>>several agent can sign the same named graph instance.  >>  >>True, and then they are joint owners/publishers, if that signing occurs  >>in the graph itself.  >>  >   >   > Initial comment: The signature of a graph can not be included into the graph  > for technical reasons.  >   >   >   > Signing a graph works the following way:  >   >   >   > 1. You take a graph  >   > 2. You calculate the hash of it  >   > 3. then you encrypt the hash using your private key.  >   >   >   > Having the signature inside the graph makes it impossible to calculate the  > hash, because things are getting circular.  >   >     This doesn't matter you just need to exclude that triple (the one with the   signature) as a special case ... maybe it's better to replace the triple   with an empty signature triple ...    _:w swp:signature ""^^xsd:base64Encoded .    then it is clear where you need to put it back again.    Jeremy        

        Uschold, Michael F wrote:  > OPEN QUESTION:   > ?should we make it a requirement that, say all notes at least            have RDF/XML in an appendix? -or-  > ?should this be entirely up to the author's discression?      I believe that a statement of general policy, with extensive discretion,   is the best way forward. This allows any reviewer who cares to easily   challenge author discretion when it goes against the main thrust of the   policy. Otherwise we need to over-engineer the letter of the policy,   rather than gradually come to a shared understanding of the spirit    (e.g. I think having examples in Turtle and RDF/XML, in-line, like in   the OWL Test Cases, fits the spirit, without fitting the letter of   Mike's proposal - I don't think this is worth discussing except on a   case-by-case basis)      Jeremy        

        Uschold, Michael F wrote:    >   > Jeremy: you said that there are problems with trying      to do this with OWL-Full. Can you give a simple example     that shows the problem?  >       Here's a very simple one:    Saying that Pat Hayes is the author of RDF Semantics may be said in RDF   with a single triple:    <http://www.w3.org/TR/rdf-mt> dc:creator "Pat Hayes" .    To say that in OWL AS we may well end up with something like    individual(      <http://www.w3.org/TR/rdf-mt>      annotation( dc:creator "Pat Hayes" ) )    The difficulty is that the mapping rules automatically will generate  dc:creator rdf:type owl:AnnotationProperty .  as well as the triple we want and some other fairly harmless triples.    A different way of saying a similar thing in the AS would be:      individual(      <http://www.w3.org/TR/rdf-mt>      value( dc:creator "Pat Hayes" ) )    And here we would need to have dc:creator as a datavalued property, giving   the triple:    dc:creator rdf:type owl:DatatypeProperty .    Under the OWL Full semantics these two are not semantically identical (in   fact neither entails the other), and neither is entailed by what might   actually be written in a concrete document which might just be the single   triple.    Jeremy        

          (Just rdf core)    > It would be helpful if you could spell out the arguments for why a  > parseType="Literal" fragment should not inherit xml:lang from its  > context?  >       Let's try brain storming, I am sure Patrick could copy paste one or two out   of his earlier post. (but not too much context)    I'll try ...  - XML makes no provision for providing xml:lang except on elements. In   particular it is not possible to provide xml:lang on mixed content. For   legacy reasons rdf:parseType="Literal" takes mixed content. For RDF to   provide such a mechanism in this case, would require some special apparatus   not required elsewhere in RDF:       We have had substantial comment against specific instances of       such apparatus:     + a speical sort of literal       Massimo [1], TBL [2],     + a special sort of datatype       PFPS [3], (seven comments!)     + wrapping       Reagle [4]       (None of these have commented about the language requirement        just a variety of proposed solutions)     Each of these comments is sufficient to justify trying a different   solution, in total, we note that the only actual use case we have, that  of embedded xhtml is adequately met by use of span. This is our current   solution, and the argument against, that it makes it more difficult for  someone hand-editing RDF/XML is insufficiently compelling.    Jeremy    [1]  http://lists.w3.org/Archives/Public/www-rdf-comments/2002JulSep/0165.html    [2]  http://lists.w3.org/Archives/Public/www-rdf-comments/2002JulSep/0092.html    [3]  http://lists.w3.org/Archives/Public/www-rdf-comments/2003JanMar/0091.html  http://lists.w3.org/Archives/Public/www-rdf-comments/2003JanMar/0093.html  http://lists.w3.org/Archives/Public/www-rdf-comments/2003JanMar/0088.html  http://lists.w3.org/Archives/Public/www-rdf-comments/2003JanMar/0089.html  http://lists.w3.org/Archives/Public/www-rdf-comments/2003JanMar/0087.html  http://lists.w3.org/Archives/Public/www-rdf-comments/2003JanMar/0086.html  http://lists.w3.org/Archives/Public/www-rdf-comments/2003JanMar/0064.html    [4]  http://lists.w3.org/Archives/Public/www-rdf-comments/2003JanMar/0434.html        

        (Pat: my comments refer to I think not quite the latest draft, sorry if  any of the issues have been fixed).      The Model Theory draft is stunning.  I am certainly happy to see it go out.    I particularly liked the touch of section numbering from 0.  From the very first symbol in the table of contents it is clear that  this aims to be a serious mathematical document, rather than a  computer scientist's hack.    I have a few comments: three minor contentful points, and a few  spellings.        1: rdf:domain and rdf:range from RDFS spec.    In Section 4, in the paragraph before the table, the phrase  "rather than the wording in the M&S" should be  "rather than the wording in the RDFS spec."    2: Finiteness    In section 5, in the paragraph after the table, there is the word   "finitely".    This is the first mention of finiteness in the document, personally  I was not assuming when reading this that the vocabulary was finite.    I believe infinite RDF models are out-of-charter, so would be happy  with making all vocabularies finite by changing the first paragraph of  section 1.4 to start    "All interpretations will be relative to a finite set of URIs, called  the vocabulary of the interpretation"    More conservatively, finiteness could be introduced in the second  paragraph of section 5    "Suppose E is a finite RDFS graph "    3: RDFS entailment rule missing?    In the table in section 5, I think rule 3     aaa rdfs:subPropertyOf bbb .     =>  aaa rdf:type rdf:Property .    should also have    bbb rdf:type rdf:Property .    on the RHS.   This is only necessary when E does not contain any    xxx aaa yyy .    since otherwise the triple follows from the other rules.    Also, I would prefer if the rules were numbered.  (Perhaps those who know me and have got fed up with me discussing  grammar production 6.12, my favourite, would prefer if they   weren't.)      4: Spellings ...  Ones I noticed were:  "sematnic" in 1.1  "the the existential closure" in 2.1  "decideable" in 3.1 after the Interpolation Lemma.      Jeremy        

          Patrick    you are losing my support this morning :)      TDL inevitably requires interpreting one occurrence of a literal differently  from another occurrence of the same literal. e.g. the literal node label  "1984" will be interpreted as a string when it is a book title, and as an  integer when it is an age.    If this literal happens to be stored in the same memory location as the  other is completely irrelevant. In as much as they are being interpreted  differently they *are* different literals.    Thus any implementation detail about whether or not we share storage and  thus technically about whether the representation of the graph in the  computer memory is tidy or not is beside-the-point.    What S requires (as you yourself have pointed out) is that there is one  literal node for each literal label and that has one interpretation. If  multiple meanings are needed that is up to the application semantics.    What TDL requires is that different occurrences of literal nodes with the  same label have different meanings. It is an implementation detail how  literals are actually store, but the clearest exposition of the TDL position  is that the graph is untidy. Anything else is mere sophistry.      Jeremy        

            Brian McBride wrote    > I couldn't see how it related to I18N issues.        I will try and be on-topic, and I'll get off to a good start by digressing.      In Budapest, I spoke with the bbc world service website people.  They have material in 43 languages in an XML workflow in their website   production system.    I was thinking about the rdf:XMLLiteral issue and their application.    1. Mapping their data to RDF would suggest 43 different subgraphs each   hanging off a blank node labelled with the correct language.    2. Within the italian subgraph we would expect all/most plain literals to   be marked with language tag: it    3. An XMLLiteral (always? XHTML) in this subgraph would need to have <span   xml:lang="it">  </span> surrounding it.    4. When searching the whole thing for an italian word "domani"@it we could:     a) find the italian subgraph and search that for "domani"    or     b.1) search for all plain literals with language range @it-* containing   domani as a substring     and     b.2) search for all XMLLiterals with xml:lang="it-*" in them and domani   occurring in scope.        Looking at the decision about language tag and XML Literal by itself,   intially I thought the decision looked bad because of 4.b.1 no longer   working for XMLLiterals. Then on second thoughts it seemed that 4.b.2 is   the correct algorithm, and always was the correct algorithm. i.e. to   operate on language within an XMLLiteral it is necessary to treat the   XMLLiteral as XML not merely a text string. That seems fundamental to the   problem; and the WG decision avoids encouraging implementors to half-solve   the problem.    Martin appears to be advocating treating XMLLiterals just like a text   string, which, in the end, is likely to encourage incorrect code.      Jeremy        

          > The benefit of using a signature-special datatype over just  > base64EncodedBinary  > is that the datatype specification can say how the actual signature is  > produced  > and used.    No - a datatype is defined as a lexical space, a value space and a mapping  .. I don't think there is room in such a definition for throwing in the  kicthen sink. That's why we strongly suggest against using xsd:QName, or  xsd:ID which expect an XML context in which to be used.    Jeremy    > Does that help to convince you in the least?    Guess :)        

        Issuette:  Should we change the term: "plain literal" to mean a literal of just a   lexical form, and then have a new term "language tagged literal"?    Possible text based on a 'yes' to this question is:    Section 6.5 RDF Literals    [[  A literal in an RDF graph contains one or two named components.    All literals have a lexical form being a Unicode [UNICODE] string in Normal   Form C [NFC].    Language tagged literals have a lexical form and a language tag as defined   by [RFC-3066], normalized to lowercase.    Typed literals have a lexical form and a datatype URI being an RDF URI   reference.    Plain literals do not have a language tag or datatype URI.  ]]  Notes etc unchanged.    Possible text based on a 'no' answer (i.e. the term 'plain literal' is   unchanged)    Section 6.5 RDF Literals    [[  A literal in an RDF graph contains one or two named components.    All literals have a lexical form being a Unicode [UNICODE] string in Normal   Form C [NFC].    Plain literals have a lexical form and optionally a language tag as defined   by [RFC-3066], normalized to lowercase.    Typed literals have a lexical form and a datatype URI being an RDF URI   reference.    ]]      (Hmmm I had thought that the 'yes' text was going to be obviously better,   but it's not clear).      The rest of the goofy literals proposal is more-or-less as in:  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2003May/0151.html  with possible knock on effects of the terminology change with plain   literals. (Note some of these knock on effects occur in semantics and are   quoted in the issue resolution below. The equivalent text in 2003May/0151   is with the meaning of plain literal unchanged).      Further note: the wording used, which actually caused the comment, is   intended to be suggestive of a many sorted logic to prevent confusion   between say a language tagged literal and a typed literal, or a plain   literal and a uriref. I avoid being explicit about this because: (a) I   think it is overkill solving a problem that isn't really there - this is   obvious (b) the complexity of explaining a many sorted logic is greater   than the benefit in clarity (c) I believe the wording in semantics allows   the separation of the domain of discourse questions from the abstract   syntax questions.      <<  PROPOSE  Accept danc-02.  Our design of literals was a bit goofy, and we have changed it:  [[  **new text as above**  ]]  Moreover, we believe some of the concern was to do with the denotation of  literals in the domain of discourse. To avoid copying any goofiness in the  abstract syntax into the domain of discourse,  we have hence changed the following rule in rdf-mt:  http://www.w3.org/TR/2003/WD-rdf-mt-20030123/#gddenot  From  "if E is a plain literal then I(E) = E"  to  http://www.w3.org/2001/sw/RDFCore/TR/WD-rdf-mt-20030117/#gddenot  "if E is a plain literal "aaa" then I(E) = aaa"  "if E is a language tagged literal "aaa"@ttt then I(E) = <aaa, ttt>"    The textual gloss is:  "Plain literals and language tagged literals are always interpreted as  referring to themselves: a character string or a pair consisting of  two character strings."    The informative text in concepts:  "As recommended in the RDF formal semantics [RDF-SEMANTICS], these plain  literals are self-denoting."  becomes  "As recommended in the RDF formal semantics [RDF-SEMANTICS] plain  literals and language tagged literals are self-denoting."   >>>>        

        Comments on Model Theory Editors draft  ======================================  http://lists.w3.org/Archives/Public/www-archive/2002Jan/att-0007/01-RDF_Mode  l_Theory.htm      Of course, overall unreserved compliments ...    I'll divide my comments into things that look to me like errors,  some stylistic points, and an enhancement request for next time.      Errors?  (For all of these I defer to Pat's judgement)  ======================================================    Section 1.4, last line, I made it "none of the above"  instead of  "only one of the above".  []    Section 2. Delete all comments to do with tidiness.  Delete the word "tidy" from the definition of skolemization.  []    Counterexample to Anonymity lemma 1:    E =  <a> <b> _:c .  <a> <b> <c> .    E' =  <a> <b> <c> .  []    Counterexample to Anonymity lemma 2:    E =  <a> <b> _:c .  _:c <d> <e> .  <a> <b> _:d .      E' =  <a> <b> _:c .  _:c <d> <e> .  []    End of section 5 (penultimate para).  "Since these clearly ...".  No they don't.  I don't see  IEXT(I(rdf:type)) contains <x,I(rdf:Property)> iff x is in IP  (I think this should be explicitly added).  []      Style comments  ==============  (Note: Pat writes substantially more clearly than I do, and hence should  probably discard at least half of my style comments!)    (Excessive use of bracketed text. I (particularly) dislike the doubly  nested use of brackets).    I think deleting all brackets around complete paragraphs would be an  improvement. (Even your asides, Pat, deserve our full attention :) ).    In section 0.2 para "To indicate blank nodes ..." I suggest that the  bracketed text "(However, we ... brevity.)" be pulled out as a separate  unbracketed paragraph.    In section 1.2 para "We do not take ..." I suggest replacing "(If" by  "Alternatively, if" and deleting the matching paranenthesis.    In section 1.3 first para I found the bracketed text "(For a lexicalized  ... lexicalization.)" unclear. I think it would be better somewhat more  concrete e.g. "For an interpretation of the graph corresponding to an  N-triple document it is normal to use a vocabulary consisting of the  set of urirefs occurringin the document."    When I got to section 1.3 I was surprised by XL - I had missed its  introduction. Should links or more headings be used to help the reader  around the document?    Section 2.2 first para repeats fourth para of section 0.2. It was OK,  but could possibly be improved ...    Section 5, just above the table, "Note, these ... ".  This refers to the old RDF Schema spec as if there were no other.  (Well there isn't!) But I understand our intent is that there will  be, and then this para will read quite strangely.  RDF Schema has not yet made it to full rec. largely because it needed  this change.    Enhancment Request  ==================    I was disappointed that no account was offered of the relationship  between:    <a> <rdf:type> <rdf:bag> .  <a> <rdf:_1> <b> .  <a> <rdf:_2> <c> .    and    <a> <rdf:type> <rdf:bag> .  <a> <rdf:_2> <b> .  <a> <rdf:_1> <c> .    My belief is that we either need to offer such an account  or drop rdf:bagID from the syntax. In certain cases a parser  may produce either from identical input.    (cf:  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Oct/0013.html  )          Jeremy        

          Hi Peter,    I have thought a bit more about the datatyping rule; and also realized we  did not discuss one other aspect of difference (blankNode rdf:type  rdfs:Class .)    The datatype rule is:    datatypeID    =>    datatypeID rdf:type rdfs:Datatype .    I think it will be easier to simply not permit rdfs:Datatype anywhere; and  change the rule to:    datatypeID    =>    // empty    Rationale:  1)  The rule as is needs some change, since this should be at most optional  for builtin datatypes (which are the only ones we have).    2) Making it optional then still leaves the orphaned datatype declaration  problem; made worse since a datatype that is only used in a cardinality  constraint gets orphaned.    i.e.    xsd:int rdf:type rdfs:Datatype .  _:x rdf:type owl:Restriction .  _:x owl:onProperty eg:p.  eg:p rdf:type owl:DatatypeProperty .  _:x owl:minCardinality 1^^xsd:int .    is in OWL Full and not OWL DL, by the current mapping rules.    3) Two possible fixes to the orphaned datatype are:     a) add new datatype declaration directive to Abstract Syntax (my  preference)     b) change mapping rule to not output any triple (easier)    =====================    There are a number of places where the mapping rules include  _:x rdf:type rdfs:Class . [opt]    I have a mild preference for deleting them all; but leaving triples like    classID rdf:type rdfs:Class . [opt]    I requested the addition of such triples for uriref subjects for  compatibility with RDFS; but I cannot think of a use case in which the  corresponding triples for blank nodes aid compatibility. This is  remembering: (a) blank nodes cannot be shared between documents and (b) RDFS  does not use blank nodes as classes or properties (it is not actually  prohibited, just not useful).    Jeremy        

          I wasn't present (in the group) for this meeting, but it seems to be the one  where it was decided that unqualified attributes from "the List" were not in  RDF.    Since we are being asked to review that decision, I thought I would review  the minutes.    A particular issue that I was trying to get my head round is why DaveB's  preference for deprecating was rejected.    Dave:  [[[  3.  Unprefixed attributes are deprecated - they SHOULD NOT be used in      the syntax from this date and WILL be forbidden in the next RDF      syntax document.  ]]]  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001May/0166.html    The minutes record:  [[[  Connolly: licensing processors to accept documents that aren't in the  language is risky... the user community learns what the language is by what  the tools do  ]]]    This is a good argument, but we have seen in practice a reluctance on the  part of the tool builders to do more than issue a warning on these  constructs. The tools have effectively deprecated unprefixed attributes.    The warning mode also, to some extent, counters DanC's arguments that "the  user community learns".    So, in reconsidering this issue, my preference would be to reconsider only  part 3 of DaveB's original proposal, and suggest that the syntax doc  specifically note that deprecation warnings on this construct are  appropriate.      ===    Being an outsider at the time, I found the original decision surprising.  Reviewing the minutes and the e-mail log I think the arguments for it were,  overall, compelling; and we should not backpedal too far or too fast.      Jeremy        

      I wrote:  >   whereas the interpolation lemma  > seems to be false.    Oops, no I made a mistake. A smaller graph (in terms of edge count) can  entail a larger graph.    Rest of the message stands, thanks Jos for the proofs.    By the way, I am happy with anonymous nodes as existentially quantified, I  just wished to highlight one of the corollaries.    Jeremy        

            Graham Klyne wrote:      > At the level of RDF concrete syntax, using namespace prefixes (as in   > QNames) might be OK, but I think it would be problematic in an RDF graph   > where the concept of scoping is, at best, very weak.  In this respect,   > the decision to use (just) full URIs as identifiers seems rather sound.  >       Only superficially compelling.  The only syntax that matters here is RDF/XML - we could do the qname to URI   mapping bwteen RDF/XML and the graph.    I don't think there are any killers here.  In particularly I disagree with Patrick when he raises non-XSD types -   simply out of scope as far as I am concerned.    Jeremy        

          Pat:  > > actual technical arguments for his requests. They amount to statements  > > of opinion about the proper role of XML in semiotics, opinions with  > > which one may have legitimate disagreement.  >      Later ... at meeting for call for advancement      W3C Director:      and why did you reject the comment from Durst?  RDF Core WG Chair: it was a matter of semiotics.  (with straight face)  W3C Director:      and what does that mean?  RDF Core WG Chair: please see the RDF Semiotics WD.      "If you get this far they've probably already 'read the signs' which suggest  that you are either eccentric or insane and communication may have ceased. "    end of first paragraph of introduction to Semiotics for Beginners  http://www.aber.ac.uk/media/Documents/S4B/sem01.html    (Quoted out of context to completely distort the meaning).      Jeremy        

          Scribe notes:  1) I have been relatively informal through-out, using first names  except for roll call.  If anyone would rather be minuted with  any other name e.g. "Prof. James Hendler" please let me know  and I will send out amended minutes. Also, unless people complain  my case behaviour with names is random.    2) Each ACTION appears twice, once in the summary, and once  in the detail - I had a strong objection to this in WebOnt,  so used a different format for that group. Personally I prefer it  this way, but again if anyone doesn't like it, I will make  appropriate amendments.    3) I don't know Ivan's sirname.    4) Did Bijan attend the RDF/XHTML part, or was he only on IRC?    5) Mark is the correct XML.com link  (Simon St. Laurent review of Mar. 10)?  http://www.oreillynet.com/pub/wlg/4553      Minutes follow ...  =================================  SWBPD WG Telecon 18 March 2004, 1500Z    Summary  (new actions)  ACTION: Ralph talk with Guus and create a strall poll form for meeting times  ACTION: Guus to propose a format for TF description  (the following depend on the above)    ACTION: JimH write description of WorldView TF    ACTION: ChrisW write description of OPEN TF    ACTION: aldo describe Wordnet TF  ACTION: danbri get rdf-thes contacts from Guus  ACTION: aldo e-mail WordNet update to mailing list  ACTION: guus read bernard's e-mail with draft TMAP msg  ACTION: guus to finalize TMAP e-mail, notify cg, and send out msg  ACTION: danC to send mail requesting feedback on RDF/XHTML & GRDDL to both  lists.    (continued actions)  ACTION DanBri: investigate publication of Turtle as SWIG note  ACTION ChrisW present his time ontology in the next telecon  ACTION DanBri: ask SemWeb CG about constraints and advice re WD, Note, etc.    (decisions)  RESOLVED: contact Topic Maps as in bernard's e-mail    Also:  The Chair suggests that everyone sends an introduction to list.  Ralph will edit the list of Task Forces. (a new document)    Agenda:  http://lists.w3.org/Archives/Public/public-swbp-wg/2004JanMar/0069  IRC:  http://www.w3.org/2004/03/18-swbp-irc      Detail:  1. ADMINISTRIVIA (10 min)    Role call:    Chris Welty,    Ralph Switck,    Jim Hendler,    Aditya Kalyanpur,    Dan Brickley,    David Norheim,    Libby Miller,    Ivan ???,    Natasha Noy,    Jen Golbeck,    Brian McBride,    Bernard Vatant,    Shimizu Noboru,    Deb McGuinness,    Guus Schreiber (chair),    Nick Gibbins,    Jermey Carroll (scribe),    Dan Connolly,    Mark Birbeck,    Aldo Gangemi  Regrets: Marco Nanni,    RESOLVED to accept the minutes of the Cannes kickoff ftf:  http://lists.w3.org/Archives/Public/public-swbp-wg/2004JanMar/0067.html    Amended to show Deb's remote attendence.    Thanks to people who attended kickoff.  The Chair suggests that everyone sends an introduction to list.      RESOVED: next telecon date 1 April  Long discussion about time of telecon:  (selected comments)    Deb: this time is very difficult for me.    Ralph: I concur with Deb's concern, since the F2F was not representative.    Jim: an alternating time is difficult to schedule for me.    Shimizu: it's impossible to satisfy everybody - I prefer one time    Chris: with alternating times some people can only participate once a  month    Deb: once a month is better than zero times a month  *No* time for next telecon decided.    ACTION: Ralph talk with Guus and create a strall poll form for meeting times    2. ACTION ITEM REVIEW (5min)    Completed actions:    ACTION: danbri send msg to public-esw-thes letting them know BDP WG is  considering work in thes2rdf area  ACTION GuusS asking JimH whether he's wanting to coordinate "Worldview  Note" TF  ACTION JJC: send to the WG list an example of using www-archive (and perhaps  some relevant advice)  ACTION RalphS: add attachment policies to list archive cover page  W3C Guidelines for Email Attachment Formats  ACTION Guus: forward some tips for scribes (from Dan to webont)  ACTION: Bernard to draft a message to be sent from this WG to ISO Topic Maps  community for discussion at an upcoming teleconference    Continued Actions:  ACTION DanB: investigate publication of Turtle as SWIG note  ACTION ChrisW present his time ontology in the next telecon  ACTION DanBri: ask SemWeb CG about constraints and advice re WD, Note, etc.      3  TASK FORCES      3.1 Task force list (taken after 3.1(a))    Guus presented:  [[  Proposal to create and maintain a WG task-force list, in a similar  spirit as a regylar issue list. To discuss:  - format task-foce description  - list maintenance / editor  - process similar to issue process: proposed, "opned" (i.e. strated),     proposal to close (e.g. WG noet), close/postponed  ]]    The TF list contains the mission and expected results of each TF,  and the TF membership while the TF is live.  Ralph volunteered to edit this list.  Brian asked for discussion of his e-mail concerning issues  http://lists.w3.org/Archives/Public/public-swbp-wg/2004JanMar/0082  (chair did not allow time)    3.2 Discussion on selected task forces      (a) World-view note - explain diff owl, rdf, xml etc.    JimH: two themes WorldView about SemWeb (e.g. rdf vs owl)  or               WorldView about Web vs SemWeb (e.g. xml vs rdf)  This could be one document or two.  So far, Deb and Brian are in the TF with Jim (lead)  Possibles: Pat Hayes, Frank van Harmaleen  David Norheim is interested.      ACTION: JimH write description of WorldView TF    (b) Demos and applications  No coordinator, no TF ...  There remained interest but no one willing to coordinate this TF.      (c) Porting thesaurii to the Web  DanBri reported "Not much to report ..."  ACTION: danbri get rdf-thes contacts from Guus        (d) Ontology Patterns and Engineering  (ChrisW, DebM)  Chris felt it was a waste of WG time to discuss acronym.  Tf may meet independently on that.  E-mail should go through the WG list.    Chris asked how to work (ie html, wiki ...)    The W3C encourages use of CVS, WG members can get  CVS write access to pages held on www.w3.org.    Can also send msgs to www-archive@w3.org and w3c-archive@w3.org  for documenting archiving.    There is a Wiki we can use: http://esw.w3.org/topic/    DanC pointed out that using a Wiki is encouraging other people  to write, which may be inapprorpriate for a TF      (e) WordNet ontology conversion support  (AldoG)  FOllowing people expressed interest   { Alberto Reggiori, Libby }  Aldo gave an update, which the scribe failed to summarized.  Aldo gave an update again after the XHTML TF agendum: the  scribe remained confused - here are some notes:    The TF will review previous work and contact people    who have done ports. e.g. Steffan Decker. It will    contact someone in Switzerland, and someone in    Princeton. There was discussion about the commercial    terms of Euro Wordnet.    ACTION: aldo e-mail WordNet update to mailing list     (e.g. a clearer version of the scribe's muddle)  ACTION: aldo describe Wordnet TF        (f) Link to TopicMaps  (Bernard proposed sending, seconded by Jeremy)  http://lists.w3.org/Archives/Public/public-swbp-wg/2004JanMar/0081    ACTION: guus read bernard's e-mail with draft TMAP msg  ACTION: guus to finalize TMAP e-mail, notify cg, and send out msg  RESOLVED: contact Topic Maps as in bernard's e-mail      3.3 RDF-XHTML task force (20 min)  (current lead DanC:  "I'm willing to lead, but would be happier  for somebody else to lead")    Mark Birbeck and Dan Connolly joined for this section.    Jeremy has sent a review of Mark's work:  Jeremy: I like it. I raised a number of technical details.  http://lists.w3.org/Archives/Public/public-rdf-in-xhtml-tf/2004Mar/0004    The XHTML WG are commited.    Mark mentioned an XML.com review:  http://www.oreillynet.com/pub/wlg/4553  This review did not understand motivations, problems, or constraints.    DanC suggested the GRDDL background doc as perhaps useful  for Mark in explaining these issues.    DanC asked who are the customers: Dublin Core, AKT, Foaf  Nick: AKT has had to solve this problem;        we want a single solution.    ACTION: danC to send mail requesting feedback on RDF/XHTML & GRDDL to both  lists.        

      [erroneously caught in spam trap -- trying to diagnose -rrs]    Date: Fri, 28 Sep 2001 07:54:49 -0400 (EDT)  Message-ID: <JAEBJCLMIFLKLOJGMELDKEDLCCAA.jjc@hplb.hpl.hp.com>  Received: from tux.w3.org (tux.w3.org [18.29.0.27])  by www19.w3.org (8.9.0/8.9.0) with ESMTP id HAA19565  for <w3c-rdfcore-wg@www19.w3.org>; Fri, 28 Sep 2001 07:54:41 -0400 (EDT)  Received: from hplb.hpl.hp.com (hplb.hpl.hp.com [192.6.10.2])  by tux.w3.org (8.9.3/8.9.3) with ESMTP id HAA10365  for <w3c-rdfcore-wg@w3.org>; Fri, 28 Sep 2001 07:54:40 -0400  Received: from otter.hpl.hp.com (otter.hpl.hp.com [15.144.59.2])  by hplb.hpl.hp.com (8.9.3 (PHNE_22672)/ HPLabs Bristol Relay) with ESMTP  id LAA03259  for <w3c-rdfcore-wg@w3.org>; Fri, 28 Sep 2001 11:37:45 +0100 (BST)  Received: from carrollj2 (carroll-j-2.hpl.hp.com [15.144.90.5])  by otter.hpl.hp.com (8.9.3 (PHNE_22672)/HP-Labs Bristol Internal Mail Hub)  with SMTP id LAA07897;  Fri, 28 Sep 2001 11:37:33 +0100 (BST)  From: "Jeremy Carroll" <jjc@hplb.hpl.hp.com>    Pat's MT has not been limited (much) by RDF.xml syntax.    He has left open the question of whether Literals are Resources.    While he does not have bNodes as properties, what he has done could be  cleanly embedded within such a treatment.    Hence, I feel that the MT has been both fair with the past and fair with the  future. Fair with past by taking a clean reading of M&S while not going  further than necessary to do that. Fair with the future in leaving open  those steps that strike us as attractive, without forcing them on future  WGs.        Personally, I would favour making changes to the XML syntax to allow all of  Pat's models to be expressed.    I could propose representing bNodes in rdf:about and rdf:resource as  "_:name".  This is not a URI, since '_' is not a legal scheme name, hence is  technically an extension of the syntax. (whether a uri-reference appears  allow a uri-reference or a bNode-reference ). I believe in practice it would  be found to be backwardly compatible. (Only pedants check uri-refs against  RFC2396). I haven't a clue how to address the property not ending in an  XMLName character problem.      Jeremy        

        Graham,    I found your message very helpful.    It is clearly logically correct.    Our general approach to discussion in the WG does try to treat issues in  isolation, and that can lead to problems.    The need to release a new draft of TDL with the model theory revisions in it  is clear, and is moving up my todo list.    Jeremy    > -----Original Message-----  > From: Graham Klyne [mailto:Graham.Klyne@MIMEsweeper.com]  > Sent: 30 January 2002 09:48  > To: Patrick Stickler  > Cc: Jeremy Carroll; Brian McBride; www-archive@w3.org  > Subject: Re: (offlist) Re: Datatyping Summary  >  >  > At 09:12 AM 1/30/02 +0200, Patrick Stickler wrote:  > > > I find this completely non sequitur.  > > >  > > > If any show stopper can be removed by introduction of a different show  > > > stopper, that doesn't mean there are no show stoppers.  > >  > >I'm not sure I follow you there. Both Dan and Sergey in their "can't  > >live with S" postings focused primarily on the fact that because TDL  > >presumed untidy literal nodes, it was fundamentally broken. I.e.  >  > OK, let's back up.  The original show stopper in this case was,  > in my view,  > the lack of self-entailment of a document, which was in turn a  > consequence  > of the treatment of untidy literal nodes.  >  > Jeremy offered a proposal that overcame the self-entailment problem, but  > which required a fundamental change to the handling of RDF  > (relative to at  > least DanC's and my understanding).  >  > The non sequitur here is:  >  >    Proposal A is broken for reason of problem B.  >  >    Proposal C fixes problem B  >  >    =>  Proposal A+C is not broken.  >  > Roughly, you have to consider the wider picture,  you can't just pick off  > problems in isolation.  >  > #g  >  >  > ------------------------------------------------------------  > Graham Klyne                    MIMEsweeper Group  > Strategic Research              <http://www.mimesweeper.com>  > <Graham.Klyne@MIMEsweeper.com>  >         __  >        /\ \  >       /  \ \  >      / /\ \ \  >     / / /\ \ \  >    / / /__\_\ \  >   / / /________\  >   \/___________/  >  >  >        

          I will try and propose what it would take, in about 18 hours time, (i.e.   tomorrow morning in Europe).    It seems that Martin wanted a bit more than Brian's text - discussion of   matching problem etc. I suspect a MUST NOT normalize might help too.    Jeremy        Brian McBride wrote:    >   >   > Martin Duerst wrote:  >   >>  >> At 11:00 03/10/02 +0100, Brian McBride wrote:  >>  >>> Well, the overnight developments I had hoped for aren't going to happen.  >>  >>  >>  >> If that's referring to a response from our side, sorry.  >   >   > It wasn't.  I'm sorry that wasn't clear Martin.  I was not casting any   > aspertions about timeliness in your direction, and in fact, I'm grateful   > for this quick response.  >   > [...]  >   >>  >>  >> I agree with 'rarely in practice'. NFC was designed to align with current  >> practice where possible.  >>  >> The example you give is not exactly typical, here are some:  >> - A string contains a base character and a combining character, and there  >>   is a precomposed character for this combination  >> - A string contains a character (e.g. Angstrom) that is a canonical  >>   equivalent (i.e. exact copy) of another (A-ring).  >> - A string starts with a combining character with nothing to combine with  >   >   > Thanks Martin, thats helpful.  >   >>  >>  >>> One issue of concern to Peter is that the current specs prohibit us   >>> saying in say Owl that some string (which is not in normal form C) is   >>> not in normal form C.  I think this is wrong, in that it is possible   >>> to invent a datatype whose lexical space consists of strings in   >>> normal form C, but whose value space is not, that would allow the   >>> representation of all strings.  The same could be done for XML   >>> fragments, though would then loose the benefit of the   >>> parseType="Literal" convenience syntax.  >>> Thus whilst the RDF specs would not be providing a standard way of   >>> representing non-NFC strings, it would not be preventing their   >>> expression.  >>  >>  >>  >> I'm a bit confused here, but I'll try to use my own words.  >>  >> RDF would always be able to represent non-NFC strings, e.g. by  >> defining them as a collection/sequence of integers represented  >> by a graph. There is in my understanding nothing one can or should  >> do or be able to do to prevent that if somebody really wants to  >> do that.  >   >   > Right.  I think that's the essential point - there are other ways of   > representing non-nfc strings if you really want to.  >   >>  >> What you propose above seems to be somewhat different, i.e.  >> normalized strings would represent unnormalized strings.  >> But this would run into all kinds of problems,   >   >   > Then I won't pursue it - I merely meant it as an example of one   > approach.  If that doesn't work no matter, as the one you have suggested   > does.  >   > [...]  >   >>  >>> That said, it does seem odd to me that we are precluding RDF from   >>> representing some legal fragments of XML 1.0 as XML Literals.  Please   >>> interpret "odd" as massive English understatement.  >>>  >>> This situation has arisen because we have been striving to be good   >>> citizens, especially with respect to internationalization and have   >>> adopted good practice earlier than some other specs.  This does not   >>> play well when we embed fragments of language conforming to those   >>> other specs in our language.  This is a situation when one has to   >>> consider the wisdom of trying to be "ahead of the pack".  >>  >>  >>  >> I think for RDF specifically, doing matching to build up the graph,  >> and having this very clearly defined, was one of the basic requirements,  >> and reasons for 'early' adoption.  >>  From a user point of view, different normalizations should match.  >> But from a machine point of view, this can be a lot of work.  >> Requiring clean data to start with is what we have proposed, and  >> you have adopted.  >   >   > I see.  >   >  A possible alternative would be to not strictly  >   >> require clean data, but to clearly blame any responsibility for  >> matching problems on the side providing the dirty data.  >   >   > That looks like a possible compromise - language of the form "SHOULD be   > in NFC" rather than "MUST be in NFC, as I suggested later in my email:  >   > [...]  >   >>>  >>> I also wonder whether this issue might be addressed by toning down   >>> the language from MUST to SHOULD e.g.  >>>  >>> [...]  >>>  >>>> which includes the additional following para:  >>>> [[  >>>> The string in both plain and typed literals is required to  >>>> be in Unicode Normal Form C [NFC]. This requirement is motivated  >>>> by [Charmod] particularly section 4 Early Uniform Normalization.  >>>> ]]  >>>  >>>  >>>  >>> becomes something like  >>>  >>> [[  >>> The string in both plain and typed literals SHOULD be in Unicode   >>> Normal Form C [NFC].  This is motivated by anticipation that   >>> [Charmod], particularly section 4 Early Uniform Normalization will   >>> become standardized practice.  Implementations SHOULD accept strings   >>> which are not in Normal Form C and MAY issue a warning in such   >>> circumstances.  >>> ]]  >>  >   > I think I heard you say that you think such an approach would be   > acceptable to I18N.  Right?  >   > Peter, would it work for you?  >   > Brian  >   >         

        N3 is very poorly documented, however it does have some mindshare. Given that   this paper is likely to be an aggressively anti-N3 paper ever (it needs to   describe log:implies as incoherent or worse), we would be well-advised to   take some good features out of N3 where relevant ...      > Look, its *logically valid* to substitute any bnode label for any   > other, as long as you do it systematically throughout the graph. So   > any use of a bnode to be a label is *logically invalid*.  No matter   > how lexically convenient it might be, that's a bad place to start.    SECOND VERSION OF RESPONSE    We could modify the abstract syntax to permit a graph to be a node in another   graph - this would permit the nested graph within a formula that does seem   genuinely useful. This feels like hard work too ...      FIRST VERSION OF RESPONSE:    I find this uncompelling ...  You invented reading a blank node as an existential and hence determined what   was and was not logically valid for blank nodes.  The point being that we can make changes, but given the success of reading   blank nodes as existentials these changes should be limited.    At the moment we are heading towards rdfg:Graph's being intensional resources,   somehow associated with the graphs that they name. (This might or might not   be a good way to go).  Pursuing this, we could augment classic RDF Semantics with a partial mapping   G: IR -> the set of RDF Graphs (syntactic)  we never get to apply I to G(r) for any r in IR, that is we cannot reapply the   semantic theory to the syntactic objects that we have just embedded within   it.    We can then modify the semantics along the following lines:    Given a set of named graphs N, and a set A of names that we are accepting   (i.e. the agent reading N gets to choose which of the graphs are believed, so   the interpetation of N is not a map to {t,f} but 2^|N| such maps, depending   on which names are in A)    Then, an interpretation of N following A is ... maybe you're right, I don't   think this is going to work ...    I'll sleep on it    TEST CASE    Here's a simple test case:    _:a ( eg:a eg:b eg:c )  _:b ( eg:a eg:b eg:c .         eg:d eg:e eg:f )  _:c ( _:a rdfg:subGraphOf _:b )    Graph _:c seems to be to me necessarily true with these named graphs. I find   it very difficult to see *real* problems, rather than merely artefacts of a   particular style of giving these things meaning.    If we force _:a and _:b to be given names we might get    #g1 ( eg:a eg:b eg:c )  #g2 ( eg:a eg:b eg:c .         eg:d eg:e eg:f )  #g3 ( #g1 rdfg:subGraphOf #g2 )      or      #g2 ( eg:a eg:b eg:c )  #g1 ( eg:a eg:b eg:c .         eg:d eg:e eg:f )  #g3 ( #g2 rdfg:subGraphOf #g1 )    which are different since the two #g3's are not isomorphic. However this   difference is a totally specious artefact of the skolemization.  I think that permitting blank nodes as graph names avoids this and is   desirable.    Jeremy        

            Mary Brady wrote:    > Many of the complexities of the test harness stem from dealing with other  > technologies, and how each implementation deals with  > them.      I felt that Ian's talk over-emphasized testing just one technology at a   time. If the problems occur in using two or three technologies or two or   three specifications together then test suites should cover those cases.   This is particularly important where it is not clear which spec covers the   area since we can get implementorA saying "reading spec A we do it this   way", and implementorB sayig "reading spec B we do it this other way".    I think a test case is a good way of banging the heads of WG-A and WG-B   together    (While I have phrased this in my issue-driven mindset, I think the point is   good for conformance testing too - the goal is interoperable   implementations in that case)        Jeremy        

        This is the rationale I have sent to the jena-devel list.  .....    > ACTION: jjc send rationale for typed literals decision to jena-devel list    On Friday RDF Core changed the definition of a literal, so that a literal  can be one of the following:    A lexical form  A lexical form paired with a language tag  A lexical form paired with a datatype URI      This eliminates the possibility, visible in the Last Call drafts, of    A lexical form, a langauge tag and a datatype URI        The changes to the syntax and N-triples spec will eliminate the langauge tag  from typed literals in N-triples, and an in-scope xml:lang declaration will  be ignored in the generation of typed-literals (including rdf:XMLLiteral) in  the syntax document.    ===    Part 1:  -------  Types other than rdf:XMLLiteral:    In the last call documents the langauge tag is irrelevant, explicitly  meaningless, and a potential source of confusion:    From  http://www.w3.org/TR/rdf-mt/#dtype_interp  [[  For any typed literal "sss"^^ddd or "sss"@ttt^^ddd in G, if I(ddd) is in D  and 'sss' is a valid lexical form for I(ddd) then IL("sss"^^ddd) =  L2V(I(ddd))(sss)  ]]    http://www.w3.org/TR/rdf-concepts/#section-Literal-Value  [[  The value associated with a typed literal is found by applying the datatype  mapping associated with the datatype URI to the lexical form.  ]]    http://www.w3.org/TR/rdf-concepts/#section-Graph-Literal  [[  Note: When using the language identifier, care must be taken not to confuse  language with locale. The language identifier only relates to human language  text. Presentational issues, how to best represent typed data to the  end-user, should be addressed in end-user applications.  ]]    In RDF Test Cases we see:    http://www.w3.org/2000/10/rdf-tests/rdfcore/datatypes/test004a.nt  eg:foo eg:bar "10"^^xsd:integer .  entails  http://www.w3.org/2000/10/rdf-tests/rdfcore/datatypes/test004b.nt  eg:foo eg:bar "10"@fr^^xsd:integer .      User defined types with a Lexical2Value mapping depending on the language  tag were not permitted.    For all these datatypes, syntactically excluding the language tag from typed  literals merely better articulates the WG's earlier decision (approx Nov  2002) that such language tags had no meaning. That decision is clearly  articulated in three of the last call documents.    Part 2  ------  rdf:XMLLiteral    The Last Call documents are clear that:  - language tags are relevant to XML Literal  - language tags impact the meaning of XML Literal    The WG decided to change this.  Moreover, the current <rdf-wrapper> stuff in the lexical2value mapping is  now unnecessary and will be deleted.    There appeared to be three justifications for this:  - the <rdf-wrapper> seems an ongoing source of confusion  (c.f.  "Confusion about wrapping of XMLLiteral"  http://lists.w3.org/Archives/Public/www-rdf-comments/2003JanMar/0434.html  )  - the benefits of a uniform clarification of literals exceeded the costs of  requiring users of rdf:parseType="Literal" to explicitly include an xml:lang  in their data.  - having the xml:lang in scope can be positively harmful. From  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2003May/0089.html  [[  Option 4 [the agreed resolution] simplifies matters the most,  I think, and also has the  added benefit that XML literals can be used for modular content  management without concern of infection from the particulars of  a given RDF/XML serialization (i.e. xml:lang attributes).  ]]  From http://www.w3.org/TR/xml-exc-c14n/  In Abstract:  [[  some applications require a method which, to the extent practical, excludes  ancestor context from a canonicalized subdocument  ]]  later:  [[  attributes in the XML namespace, such as xml:lang and xml:space are not  imported into orphan nodes of the document subset,  ]]    I believe that the WG will provide, in either the primer or the syntax  document, or both, examples of use with xhtml showing the need for a <span>  element to carry an xml:lang attribute.  e.g.    <rdf:Description xmlns="...xhtml...">    <eg:prop rdf:parseType="Literal"    ><span xml:lang="en">Hello World</span><eg:prop>  </rdf:Description>    ===    In summary  The decision on typed literals is:  + merely editorial for types other than rdf:XMLLiteral, and any opposition  to it is based on a misreading of the last call, which this change  eliminates.  + substantive for rdf:XMLLiteral, but better aligns with the WG's earlier  decision to base the treatment of rdf:parseType="Literal" on xml-exc-c14n,  by excluding more of the surrounding context from the meaning of the  literal, and better enabling rdf:parseType="Literal" to be an enveloping  mechanism for XML content.      Joke, sort-of ...    Ha, got you there with a catch-22 if you don't like the change that adds to  the evidence that it is needed!        

          Locks etc.    Chris currently has the latex sources with lock.  Later today, he should send these sources to Pat and the archive and Pat   can either change the latex sources or write plain text (like last time).    Chris would like the lock on Tuesday UK time, I would like the lock on   Wednesday.    Pat could have the lock from this evening through to Monday night.    Hope this works,    Chris and Pat can probably sort things.    Please make sure there is an agreed abstract on the archive soon, since I   will submit it Monday.    Jeremy        

        ewallace@cme.nist.gov wrote:  > This brings up a question though: What is the intended audience for  > OEP notes?  I think we are targeting those new to the Semantic Web  > and even KR.  I am expecting that audience to be dominated by domain  > experts and modelers over the next few years (this seems to be   > validated by the emails I have seen on the protege-owl list).  Making   > the SW easy to use and understand for those groups is why I joined this   > WG.  So when picking terms, structure, examples and even the subject  > of these notes, I would place a higher priority on the needs of these  > groups than the needs of groups exemplified by say the members of   > rdf-logic.    >   > Is this a controversial view?    It puts the case well ...    this same audience may get confused though, if they pick up introductory   RDF material, such as the Shelley Powers' book, or the RDF Primer, and   find a discussion of reification which is somewhat at odds with the   discussion in this note. Perhaps your target new SW users are different   from mine. I suspect that they will read such books first, and the note   second. "The word is gone, taken from us..."    Jeremy        

        With Guide ref fixed?          text/html attachment: owl3.html          

        I am planning my trip for the WOW-G F2F 14th,15th January and I am looking  for other things to do on the 16th, 17th in New England.    It seems a shame to come across the atlantic just for a couple of days ...    Any ideas/invitations?      Jeremy Carroll  HP Labs, Bristol        

      I agree with Brian,    Dan:  >  > On the contrary: the RDF Core WG is in the W3C Technology  > and Society domain for a reason: to make the connection  > between bits on the wire and social obligations.  >  > There is some crazy laywer running around trying to encourage  > web site owners to screw up their P3P policy files in such  > a way as to be able to disclaim responsibility for their content.  > [P3P isn't quite written in RDF, but it was supposed to  > be, and should be, in a future revision, I hope].  > I suggest that this WG has an obligation to say that no,  > that's not consistent with the community's agreement  > about how this technology works.        The problem is that this is not about the meaning of the RDF, but about the  meaning of the RDF in a particular context.    There are a lot of non-technical clues about the context, some of which I  think would mean that an RDF offer would be binding from a legal point of  view, and some of which would make it non-binding.    In particular, if, an economic individual (a person or a business)  habitually trades using RDF to describe their goods and offer prices then, I  would expect that a reasonable system of law should require them to be  contractually bound by such offers in a way that is similar to other offers  that they have made.    However, the very same RDF, the very same web site, put up on an .edu server  as a student project is non-binding and has a different (i.e. non-existent)  legal force.      Take another legal issue, slander. If someone writes RDF like:    <rdf:RDF xmlns:animals="...">    <animals:Pig rdf:about="mailto:Jeremy.Carroll@hp.com"/>  </rdf:RDF>    and then says (in English) "the RDF statement in this message is not true".  I think that that's OK. If they say (in English) "the RDF statement in this  message is true", then maybe I have a case on the basis of the English, not  the RDF (except by reference). If they just put up the RDF without any  context allowing its interpretation, I think I stick with Brian; if it means  something in this non-context is not a sufficiently interesting problem that  we should address it.    I recently wrote a complaint to a supermarket about some goods branded as  "italiano" which were in fact not Italian; saying that it was disingenuous  to tell lies in a foreign language. It is however probably legal    Jeremy        

          I find Aaron's arguments both substantive and somehow unpersuasive.    So there are issues with fragments - is the RDF specs the right place to  address them, or should they be addressed elsewhere.    >  They're not URIs    Fix RFC 2396    > Their semantics only work in the context of a single representation    Fix RFC 2396    > They don't integrate well with the HTTP Web    Fix HTTP defns to allow these features    > Fragments don't allow redirects    Fix HTTP    > Fragments aren't consistent across content-negotiation    I am not sure where this should be fixed.    > Some fragments break even when you change the document:  (xe.g. #xpointer(id("reasons")/li[3]) )    Fix users! :-) This fragment is fairly broken, but that doesn't damn the  system.      As we expand the demands we are making on URIs it is inevitable that we make  new requirements that haven't previously been addressed. While we have to be  confident that we can get by with the current versions of the standards  (RFC2396 and HTTP defn, wherever that is), it doesn't have to be perfect. At  the next rev of these things we have some input.      Jeremy        

        Patrick Stickler wrote:  >> Sorry, this 'super-SW-RDF' is like Kryptonite. If it existed we could   >> leap tall buildings with a single bound. Trouble is, we can't.  >   >   > OK, I'm probably using the term 'interpretation' incorrectly (again).  >   > Let's just say that insofar as this global 'super-SW-RDF' is concerned,  > we are all using the same URIs in the same way.    Pat's unfortunately right here - if you want to use a URI in RDF and be   sure that I mean the same as what you do, you need to use  <URI>^^xsd:anyURI ... :( which somewhat shuts out much of the interesting   stuff. I think that can be partially fixed, but that's another paper!    >   >     > Will a MT taking this approach be able to deal with the special case  > whereby in order to determine if (a) a graph is owned by a particular  > authority, when claims about authority are made in the graph itself,  > and (b) whether a given performance (e.g. assertion) is defined by the  > graph itself, or does this presume that all claims about authority and  > all performatives must be external to the graph.  >   > I.e. does this approach cover the "bootstrapping" problem?  >    Yes    >>  >   >>> I think we're blurring two issues: assertion and authentication.  >>  >>  >> I do not know what authentication means. Why are we distinguishing it   >> from assertion?  >   >   > Authentication is the verification that (a) the authority exists and  > one is able to obtain the information necessary for testing signatures  > issued by that authority, and (b) testing a signature to verify that  > (i) the signature was issued by the particular authority and (ii) the  > signature identifies the graph in question.  >   > All of the above is extra-RDF, based on information provided by RDF  > statements.    I have got rough text that covers this distinction now ... give me a few hours.        (I haven't really got through to the end of the message)    Jeremy        

          >  > Jeremy, re QAIG, do you have an url for their agenda? We could maybe  > arrange things to help...  >  http://www.w3.org/QA/2004/02/f2f.html    I am most interested in the QAF review and issues Monday PM, (with a flow  over onto Tuesday PM). Hence I would prefer if the SWIG topics that I have  expressed interest in (particularly contexts, etc) were Monday or Tuesday  AM. I would hope to attend QAIG on Monday PM, and make a call Tuesday  lunchtime as to which (QAIG or SWIG) to attend Tuesday PM      Jeremy        

          I thought this had already come up and been added to the postponed issues  list.    That's the best we can do, IMO.    WebOnt don't have much of a leg to stand on, we added the collections syntax  following their design, and got sign-off from them ...    The requirement statement was wrong. Fixing it at this stage is too  difficult.    Jeremy      > -----Original Message-----  > From: w3c-rdfcore-wg-request@w3.org  > [mailto:w3c-rdfcore-wg-request@w3.org]On Behalf Of Graham Klyne  > Sent: 21 February 2003 14:57  > To: RDF core WG  > Subject: [collections] Re: Web Ontology Working Group Consensus Review  > of RDF Core documents  >  >  >  > While I recognize that there are significant technical difficulties to  > allowing literals in list-collections, I also have considerable sympathy  > with the view expressed here.  In my own work with RDF, using Notation3  > rather than the XML syntax, I have found lists containing  > literals to be a  > useful feature.  >  > #g  > --  >  > At 05:17 PM 2/20/03 -0500, you wrote:  > >--------------  > >WOWG comments on RDF language decisions  > >--------------  > >  > >i. Design of rdf:XMLLiteral and rdf:parseType="Literal":  > >  > >The full integration of this feature of RDF into OWL  > necessitates that the  > >denotation in the domain of discourse be fully defined by the  > source RDF/XML  > >file. We therefore request that you remove sufficient implementation  > >variability to ensure that this is the case.  An example fix would be to  > >require an RDF/XML parser to use a specific canonicalization on input.  > >  > >ii.Constraints on rdf:parsetype="Collection"  > >  > >We would prefer that rdf:parsetype="Collection" would be allowed to be a  > >list of datatype literals, not just a list of RDF node elements. This,  > >would permit some constructs in OWL that are difficult under the current  > >design.  >  > -------------------  > Graham Klyne  > <GK@NineByNine.org>  >  >        

          Despite my earlier insistance of being on holiday, my wife has to work on  Friday afternoon; so I will too, and attend our teleconference.    Jeremy Carroll    PS. I will not receive e-mail until 4th Sept, I am checking the web e-mail  archive.        

      Sergey:  > As a developer, I don't have an option. With TDL-RDF, all of my own  > applications in mediation, model management, backend storage etc. would  > technically become non-RDF applications, or applications "formally known  > as complying with the deprecated RDF 1.0" ;) I don't see any practical  > benefit in migrating all existing code to TDL, and I might not be a  > single implementor out there.    I would like to better understand this.    The intent in the TDL model theory was that an interpretation with no  supported types was the same as the current model theory. I suspect this  boils down to the tidy versus untidy literal nodes issue.    Tidiness had already vanished from the latest editors draft of the model  theory, which is the one I was working from.    Is that right?    Jeremy        

        Patrick:  > Perhaps some brave soul out there who has the ability would like to take  > a stab at the math for the pairing-based model I am trying very hard to  > express in this troublesome and slippery natural language?    In Pat's offlineness, I fear I am the most qualified.  & Of your supporters I am also the most vocal in this bout!  I am, unfortunately quite busy.    My understanding of what is needed is   - a shortish document   - for rdf-interest and the community   - to present the alternatives   - in a way that facilitates comparison.    Currently Sergey's doc presents S, and no more work is needed on S to  achieve the above goal.    The PD proposal is being vocally backed by Patrick + Jeremy.    [Is the perl (PL?) proposal still active?]    If Patrick could volunteer to lead a PD write-up (which should IMO be no  more than picking out the best couple of pages of prior e-mail) I am willing  to fill in *necessary* math. For the model theory though, I would be  inclined to duck, pointing to some of Pat's e-mails from November and hoping  that he would be able and willing to fill in the blanks when he's back  online. I would also be happy to act as first (friendly) reviewer prior to a  WG review.    Then we would ideally want an overview doc that put the proposals  side-by-side. Alternatively we could present them to the community just as  two or three separate proposals.      Jeremy        

          In the abstract syntax I could specify that either lang is oblig and  defaults to "" or that lang="" is illegal. Probably the former is most in  tune with XML. DaveB might then need some wordsmithing.    Jeremy    > -----Original Message-----  > From: w3c-rdfcore-wg-request@w3.org  > [mailto:w3c-rdfcore-wg-request@w3.org]On Behalf Of Brian McBride  > Sent: 19 September 2002 10:21  > To: RDF Core  > Subject: Fwd: Erratum to XML 1.0 spec to allow xml:lang=""  >  >  >  > Affects rdf/xml syntax?  >  > Brian  >  > >Resent-Date: Wed, 18 Sep 2002 15:31:03 -0400 (EDT)  > >X-Sender: pgrosso@172.27.10.30  > >X-Mailer: QUALCOMM Windows Eudora Version 4.3.2  > >Date: Wed, 18 Sep 2002 14:24:23 -0500  > >To: chairs@w3.org, <w3c-xml-plenary@w3.org>  > >From: Paul Grosso <pgrosso@arbortext.com>  > >Cc: w3c-i18n-ig@w3.org  > >X-MIMETrack: Itemize by SMTP Server on LORAX/DTW/ATI(Release 5.0.8 |June  > >18, 2001) at 09/18/2002  > >  03:32:29 PM,  > >         Serialize by Router on LORAX/DTW/ATI(Release 5.0.8 |June 18,  > > 2001) at 09/18/2002  > >  03:32:30 PM,  > >         Serialize complete at 09/18/2002 03:32:30 PM  > >Subject: Erratum to XML 1.0 spec to allow xml:lang=""  > >Resent-From: chairs@w3.org  > >X-Mailing-List: <chairs@w3.org> archive/latest/2129  > >X-Loop: chairs@w3.org  > >Sender: chairs-request@w3.org  > >Resent-Sender: chairs-request@w3.org  > >List-Id: <chairs.w3.org>  > >List-Help: <http://www.w3.org/Mail/>  > >List-Unsubscribe: <mailto:chairs-request@w3.org?subject=unsubscribe>  > >X-MailScanner: Found to be clean  > >  > >  > >As previously mentioned [1], [2], at the request of the I18N WG [3],  > >the XML Core WG has been considering whether the explicit licensing  > >of the use of xml:lang="" to "un-declare" a language should be made  > >an erratum to XML 1.0 or merely included as part of XML 1.1.  > >  > >The XML Core WG has debated this issue thoroughly, seeked the  > >input of various groups (including chairs, XML Plenary, and  > >various public email groups), and canvased current implementations.  > >  > >It has been decided that the optimal situation is to issue this as an  > >erratum to the XML 1.0 spec.  Hence, you can see this reflected in the  > >current Errata document at http://www.w3.org/XML/xml-V10-2e-errata#E41 .  > >  > >The XML Core WG thanks all who provided feedback in this decision.  > >  > >Paul Grosso, co-chair, XML Core WG  > >  > >[1] http://lists.w3.org/Archives/Member/w3c-xml-plenary/2002Aug/0000  > >[2] http://lists.w3.org/Archives/Member/w3c-xml-plenary/2002Aug/0026  > >[3] http://lists.w3.org/Archives/Member/w3c-xml-core-wg/2002AprJun/0161  >  >        

          A quick comment that Brian's proposed rule:    xxx rdf:type rdf:Seq .    _:xxx rdf:_nnn _:yyy .    entails    _:xxx rdf:_mmm _:zzz .    when nnn > 1 and mmm = nnn-1    was one that I had thought we had decided against ...    Pat,    if you do add it in this round please include a comment that it's still in  discussion.    Oh, and BTW, you got the hang of those SHOULDs pretty quickly!    Jeremy      > -----Original Message-----  > From: w3c-rdfcore-wg-request@w3.org  > [mailto:w3c-rdfcore-wg-request@w3.org]On Behalf Of Brian McBride  > Sent: Monday, November 11, 2002 8:53 PM  > To: RDF Core  > Subject: mt comments attached this time.  >  >  >        

      I also think "No" but for reasons that perhaps I should have highlighted  earlier:      The exc-c14n spec says:    [[[[  The exclusive canonical form of a document subset is a physical  representation of the XPath node-set, that is an octet sequence, produced by  the method described in this specification. It is as defined in the  Canonical XML Recommendation [XML-C14N] except for the changes summarized as  follows:    + attributes in the XML namespace, such as xml:lang and xml:space are not  imported into orphan nodes of the document subset, and  + namespace nodes that are not on the InclusiveNamespaces PrefixList are  expressed only in start tags where they are visible and if they are not in  effect from an output ancestor of that tag  ]]]    I see special treatment of xml:base as excluded by the first bullet point.  Our resolution I think then prohibits an implementation that does import.  If we had gone for inclusive c14n it would have gone the other way.    Jeremy    > -----Original Message-----  > From: w3c-rdfcore-wg-request@w3.org  > [mailto:w3c-rdfcore-wg-request@w3.org]On Behalf Of Dave Beckett  > Sent: 08 April 2002 11:41  > To: Brian McBride  > Cc: RDF Core  > Subject: Re: xml:base and rdf:parseType="Literal"  >  >  > >>>Brian McBride said:  > > Jeremy,  >  > Well, you addressed this to the group  >  > > I came across this in some RDF Stuart has written:  > >  > > <rdf:Description rdf:about="http://example.org/"  > >                   xml:base="http://example/org/base/">  > >    <rdf:value rdf:parseType="Literal">  > >      <a href="foo">link</a>  > >    </rdf:value>  > > </rdf:Description>  > >  > > I wasn't sure whether the xml:base had any effect on the href.  >  > No.  >  > Since  >  > 1) xml:base applies only to fields that contain URIs that XML  >    applications (RDF/XML here) know about.  RDF/XML doesn't do that  >    inside parsetype literal content.  >  > 2) the <a> has no namespace.  >    RDF/XML doesn't apply to non-namespaced elements anywhere  >  > 3) X/HTML don't use xml:base so even if it was an X/HTML fragment  >    and element, it wouldn't apply.  >  > Dave  >  >        

          Improved wording ...      OLD:  > bwm@hplb.hpl.hp.com wrote:  > > ...  > > 15: Issue #rdfms-rdf-names-use  > > Propose the WG  > >  > >   o resolves that the use of rdf:Description except as the name of a  > >     description element is an error  > >   o resolves that the use of rdf:ID, rdf:about, rdf:resource, rdf:bagID,  > >     rdf:parseType except as reserved names as specified in the grammar  > >     is an error  > >   o resolves that the use of rdf:Bag, rdf:Alt and rdf:Seq  > except as typed  > >     nodes is an error    Sergey:  > ? If not, the wording should be improved.      New proposed:    o resolves that the use of the qname 'rdf:Description' except as the    name of a description element is an error  o resolves that the use of the qnames 'rdf:ID', 'rdf:about',    'rdf:resource', 'rdf:bagID', 'rdf:parseType' except as reserved     names as specified in the grammar is an error  o resolves that the use of the qnames 'rdf:Bag', 'rdf:Alt'    and 'rdf:Seq' except as typed nodes is an error      Jeremy        

        (I have deleted the tail of this forwarded message)    It should appear in the member archive soon.    Jeremy    -------- Original Message --------  Subject: Re: WD between LC and CR/PR  From: "Ian B. Jacobs" <ij@w3.org>    On Tue, 2003-09-02 at 11:02, Jeremy Carroll wrote:   > I note that the current charmod publication   >   > http://www.w3.org/TR/2003/WD-charmod-20030822/   >   > says   > [[   > This is a W3C Working Draft published between the second Last Call on 30   > April 2002 and a planned Candidate Recommendation. This interim publication   > is ...   > ]]   >   > I note that the process document does not prohibit such a publication,    Correct.     > and could be read as requiring such publications every three months.    That is true.     > The paragraph:   > http://www.w3.org/2003/06/Process-20030618/tr.html#return-to-wg   > [[   > After republication as a Working Draft, the next forward step available to   > the Working Group is a Last Call announcement. The Last Call announcement   > MAY occur at the same time as the publication of the Working Draft.   > ]]   >   > appears to only apply after the TR has been returned to the WG for further   > work.    Yes.     > ===  ....        

        Thomas Baker wrote:    > On Mon, Apr 05, 2004 at 03:59:28PM +0200, NANNI Marco FTRD/DMI/SOP wrote:  >   >>To conclude, i think it is useless and perhaps even a bad educational  >>choice to present   >>RDF, RDFS and OWL as 3 (or 3 + 2) different languages each of them to be  >>used for a set of problem instead of one language (OWL) with a set of  >>features each of them which can be used for a set of problem.  >   >   > Could all three be subsumed under one heading, e.g., W3C  > Semantic Web Language (SWL)?  >   > The basic message could then be: "there is one language,  > which offers different vocabularies and constructs depending  > on what you want to say".  >     That's not made easier by the semantic differences between the languages.  (Jeremy said unhelpfully)      > Rather than: "there are three or more languages and this is  > how they differ."  >   > Tom  >         

      My views Y(es)/N(o)/?(undecided), justifications follow.    >  > Jeff'sDeborah'sOriginal list  > ----------------------------------------------------------  > shared meaningmulti-user  Y  > ontology reuseextensible  Y  > ontology evolutionversioningversioning  Y  > interoperabilitydiff and mergedomain mapping  Y  > inconsistencyinconsistency  Y  > scalabilityscalabilitylarge ontologies  Y  > user-friendlyease of use  ?  > data persistence  N  > security  N  > XML interfaces  N  > internationalization  ?  > ontology-based search  N  > ontology querying  N    ================  Justifications of Ns & ?s  -------------------------  N> data persistence  N> security  N> xml interfaces  ?> internationalization    are part of the metadata layer of semantic web architecture (RDF), not part  of the ontology layer. RDF might not offer adequate answers yet but the  problems should be fixed there.  There may be internationalization issues that are part of the ontology  layer; but most i18n is in the metadata layer.    N> ontology-based search  N> ontology querying    I think these are later work. I would expect standardization of metadata  layer query to precede that of ontology layer query. There is no sign of  metadata layer query standardization so I think WOW-G should duck ontology  query standardization.    ?>user-friendly    "If you want friendly get a dog"  The language is for machine to machine communication. Friendliness is for  apps on top of it.    Jeremy        

      Pat:  > >> Another possibility is to allow certain namespaces to be declared to  > >> be dark, so that any triple using a property from a dark namespace is  > >> considered to be unasserted. Again, this does not require any change  > >> to the syntax, but only some extra conventions to be added to the  > >> language.  > >>  Jeremy:  > > This could be a namespace prefix rather than the namespace e.g.  > >  > >  > > <rdf:RDF xmlns:eg="http://example.org/"  > xmlns:egdark="http://example.org/"  > >        rdf:darkPrefixes="egdark">  > >    <rdf:Description eg:aserted="foo" egd:unasserted="bar" />  > >  > > </rdf:RDF>  > >  > > Jeremy  Patrick:  > This becomes problemmatic (in a practical sense) if we want to  > use the same vocabularies for both asserted and unasserted  > statements.    A fair point ... my example is bad stylistically, but does show that the XML  syntax is as flexible as the n-triple syntax.    Patrick:  > An alternative:  >  > How about an element rdf:Expression (or some such) which is in all  > other ways identical to rdf:Description except that statements  > are not asserted. E.g.  >  >    <rdf:Expression rdf:about="#Bob>  >       <ex:age>35</ex:age>  >    </rdf:Expression>  >  > gives us  >  >     :Bob ex:age "35" ;  > or  >     - :Bob ex:age "35" .  >  > This doesn't require any significant changes to current parsers  > and the only modification is to activate a flag when seeing  > rdf:Expression rather than rdf:Description and add the non-asserted  > punctuation when outputting the triples.    This too is a fair syntax ....    I suspect somewhat more confusing though ...    We still can get the confusion of using the same vocab both ways ...    e.g.    <rdf:RDF>    <rdf:Expression rdf:about="#Bob>        <ex:age>35</ex:age>     </rdf:Expression>    <rdf:Description rdf:about="#April>        <ex:age>35</ex:age>     </rdf:Description>  </rdf:RDF>      and would need clarity about embedding      e.g.    <rdf:RDF>    <rdf:Description rdf:about="#April>        <ex:foo>         <rdf:Expression rdf:about="#Bob>            <ex:bar ex:doublyEmbedded="??"/>          </rdf:Expression>      </ex:foo>    </rdf:Description>  </rdf:RDF>    that clarity could be done (I would favour a one level reading like for  bagID).      Jeremy        

        Peter Patel-Schneider wrote:  > > So finish the job!  :-)    I think I will try to echo what I hear Peter suggest, since Patrick seems to  be (1) following this thread (2) of the opinion that there is not a proposal  that changes rdf:XMLLiteral to be a normal rather than a special datatype.    So:  We have not been contemplating changing either:  1) the rdf:parseType="Literal" syntax  2) the representation of this, as a canonical XML doc, in the domain of  discourse  We have  changed the treatment so that:    most of the syntactic transformation of from (1) to (2) is done in Syntax  and not in rdf:XMLLiteral mapping rules.  We could go the whole hog, and make the mapping rules of rdf:XMLLiteral the  identity.  Leaving (2) fixed we have that the syntax document not only has to  canonicalise the literal content, but also it converts it into an XML  document as currently specified in concepts.  This would change test cases: e.g.    <rdf:RDF>    <rdf:Description xml:lang="en">      <rdfs:comment rdf:parseType="Literal"      ><b>Bold</b></rdfs:comment>    </rdf:Description>  </rdf:RDF>    would correspond to n-triples    _:a rdfs:comment  "<rdf-wrapper xml:lang=\"en\"><b>Bold</b></rdf-wrapper>"^^rdf:XMLLiteral .    or something like that (I don't swear I've canonicalized correctly).  Whether or not we include a redundant @en in the literal is immaterial.    We may well then have  rdf:XMLLiteral as a subdatatype of xsd:string  i.e. it is completely well-behaved and may or may not have synonyms and we  don't care, and language tags never participate in l2v mappings. We could  even ditch them all together from typed literals.    Jeremy        

        Bill:  > I like to fight the good fight against that: a lang tag  > is clearly not necessary for all literals.    If RDF 2.0 goes with Sergey's datatyping suggestion it would certainly make  sense then to move xml:lang off as a property of the bNode above the literal  string.    I currently have shared understanding with Jan on this one, some literals  have a lang tag and some don't. When they do, it matters.    If we feel it is important to be able to specify that some literals *do not*  have a lang tag then we could use xml:lang="und"   (und is the ISO-639-2 tag  for undetermined).    e.g.      <rdf:RDF xml:lang="it" xmlns:rdf="..."     xmlns:eg="http://esampio.it/"     >     <!-- Questo documento e` scritto in italiano. -->     <rdf:Description rdf:about="e-mail:Jeremy_Carroll@hp.com">       <eg:cognome>Carroll</eg:cognome>       <eg:codice-fiscale xml:lang="und">65CA X3450 JJX</eg:codice-fiscale>       <eg:numero-patente xml:lang="und">343589201  459215-0</eg:numero-patente>     </rdf:Description>  </rdf:RDF>      This gives a default language (italian) to the document, my family name is  then understood as an Italian language string, whereas the fiscal code and  driving license numbers are both specified as an "undetermined" language  string. (Both details are incorrect!).    I don't think this is a good idea.    Bill:  > And it makes abstract notions of RDF dependent on at least one  > other spec, that isn't in my mind central to web architecture.    rdf depends on xml depends on xml:lang depends on rfc 3066 depends on  (ISO-639-2 and ISO-3166).    It's a living.    Personally I think the *world wide* bit of web architecture is important. My  understanding is that the I18N WG wish charmod to be a central plank of web  architecture, and charmod depends on rfc 3066 amongst other things (like  unicode). The obscure dependencies thing is a bit of a problem though.    A new language tag is going through at the moment, Penang Sign Language,  proposed xml:lang="sgn-MY-P". A document that wasn't legal may become legal.  I don't think that that has any deep influence on RDF though.    Jeremy        

        Satoshi wrote:  > 1. Qname production  My view is that we are now regarding the old grammar as "informal" in that  we are not trying to make sense of what it is defined over (text strings?).  The infoset approach is what I hope will be normative.  In the infoset representation, elements must be namespace qualified. Text to  that effect, maybe with Satoshi's example which are qualified but not  prefixed could be included.  I understand that we have discontinued non-qualified elements. Personally I  think that the modified grammar with the new rule 6.19 captures the  requirement for qualification better than the old rule 6.19; it is then an  XML issue that in fact the prefix can be the default namespace. (Just as the  grammar specifies an order for all attributes, and it is an XML issue that  allows them to be reordered).    > 3. Whitespace handling  >  > It seems that there is no description about whitespace handling. I suggest  > that spec sites that whitespaces contained in elements that never have  > character contents must be ignored.    I like the conciseness of that statement, but suggest it might be too  concise. An example (which I thought I had already posted, but can't find in  the archive) is:    <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">    <rdf:Description>      <rdf:value>      </rdf:value>      <rdf:value rdf:parseType="Resource">      </rdf:value>    </rdf:Description>  </rdf:RDF>    The whitespace is significant in the first rdf:value element, and not in the  second.  My attempt  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Aug/0147.html was  "Whitespace is significant in attribute values, where XML whitespace  processing applies, and within literal values. Elsewhere it is ignored."      > 5. Is rdf:RDF optional?  >  > # Aaron has already mentioned about this  >  > Different parsers might generate different models without rdf:RDF,  > especially in case where rdf-ns can be used as a namepsace uri of  > propertyElt. So I suggest that WG recommend to use rdf:RDF for any RDF/XML  > document.    The only cases I've seen which don't have rdf:RDF are standalone files,  hence the rule maybe    RDF ::= <rdf:RDF> description* </rdf:RDF>       | description    Current M&S does not specify how RDF is signalled when embedded, unless by  rdf:RDF. Does anyone know of an embedding of RDF which does not use rdf:RDF  as the signal to move to rdf processing mode.    Personally I support the proposal to mandate the use of rdf:RDF    > 6. More than one rdf:RDF  >  > Is it legal to have more than one rdf:RDF elements in one XML document?  Yes.  > Is it different from having all rdf:Description in one rdf:RDF?  No.    At least I think so, we probably should make this explicit if that is what  people think. In particular it suggests that using an ID in one rdf:RDF  element in the file, prohibits the use of the same ID in some other rdf:RDF  element.    > 7. Attribute value normalization  >  > Should parsers perform another attribute value normalization for ID or  > bagID, or must not ?      The XML spec is clear.  http://www.w3.org/TR/2000/REC-xml-20001006#AVNormalize  "the XML processor must normalize the attribute value"    Since RDF processing logically follows XML processing we MUST normalize  attribute values.  All we can do is include your example somewhere as a dire warning of things  that shouldn't be done by users who are trying to avoid unnecessary pain.    Jeremy        

          Pat    I saw in    http://lists.w3.org/Archives/Public/www-webont-wg/2002Jun/0178.html    that you argued against Jos for the truth of basic set theoretic facts from  nothing.    My range and domian rules seem to me to be of a similar truth status. (There may  be a choice, and that choice depends upon how we regard the representation of  logical facts within the domain of discourse. Given that webont wants to be able  to represent such facts without having to explicitly assert them, then shouldn't  we be taking the same position in RDF Core too?)    Jeremy    > -----Original Message-----  > From: w3c-rdfcore-wg-request@w3.org  > [mailto:w3c-rdfcore-wg-request@w3.org]On Behalf Of Jeremy Carroll  > Sent: 26 June 2002 10:09  > To: pat hayes  > Cc: w3c-rdfcore-wg@w3.org  > Subject: RE: MT RDFS closure rule bug?  >  >  >  >  > >  > > >Pat,  > > >  > > >don't we need RDFS closure rules that add range and domain constraints  > > >e.g.  > > >  > > >aaa [rdfs:range] yyy  > > >yyy [rdfs:subClassOf] zzz  > > >  > > >then add  > > >  > > >aaa [rdfs:range] zzz  > > >  > > >  > > >and similarly for rdfs:domain.  > >  > > NO. That would be disastrous for the datatyping and in any case not  > > make sense. Why do want them?  > >  > >  >  > We don't *want* them, they are just true!  > Or maybe I've been talking to Peter too much!  >  > Any interpretation of any  >  > > >aaa [rdfs:range] yyy  > > >yyy [rdfs:subClassOf] zzz  >  >  > is an interpretation of  >  > > >aaa [rdfs:range] zzz  >  >  > thus the closure rule holds.  >  > (Not) Proof:  >  > Ahh, it depends on rdfs:range not being in the domain of discourse.  > neglecting that little factette and invalidating the proof ...  >  > Whenever  > iii aaa jjj .  > then  > jjj [rdf:type] yyy .  > hence  > jjj [rdf:type] zzz .  >  > hence  >  > aaa [rdfs:range] zzz .  >  > ==  >  > I smell danger.  >  >  > Jeremy  >  >  >  >  >  >        

          Mine are done:      In editors draft.          20030919#3  jjc  change URI text in concepts  20030926#1  JJC  add nfc text to Concepts as proposed      Just done now.        20030926#5  JJC  draft proposal that whitespace processing is part of   L2V map        

      Graham said that he found the IRI examples not fully compelling, I wanted to  understand the WG's response to the literal based example below (from the  earlier zip).    If we do not find such examples compelling, IMO, it is only a political  problem of how to satisfy the I18N WG rather than a technical problem of how  to satisfy the I18N requirements as we see them for RDF. i.e. I think I have  adequately captured what the normalization issue is about in these examples.    <!-- Issue: charmod-literal          Test:  1            Example showing two different literals, that display the same.          In a context where there is a unique naming convention, this can          cause confusion, possibly moral and/or legal confusion.            The use case consists of:          - a site collecting Dublin Core data,            using a unique names convention for individuals.          - One of the editors of Charmod registers himself and his            work.          - Someone else, with the same name, creator of an adult internet            site, registers a different but visually indistinguishable            name; along with his work.          - The consumers of both works get confused and disappointed,            probably to the detriment of at least one of the Martins.          - This file consists of some of the (ill-formed) RDF used by the            metadata site.    -->    <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"           xmlns:eg="http://example.org/">           <!-- An author database uses the property eg:name with a          unique naming convention.     -->       <!-- D?rst registers himself as a creator of the Charmod WD. -->     <rdf:Description  rdf:about="http://www.w3.org/TR/2002/WD-charmod-20020220">     <!-- The ? below is a single character #xFC in NFC -->        <dc:Creator eg:named="D?rst"/>     </rdf:Description>       <!-- Someone else registers himself under the unused name of Du?rst,          along with some other creation as its creator. -->     <rdf:Description rdf:about="http://example.org/adult-content.html">     <!-- The u? below is two characters a u followed by            #x308. It should be displayed identically to  ?. -->        <dc:Creator eg:named="Du?rst"/>     </rdf:Description>       <!-- Readers of such data will be given no visual indication that     these are two different people despite the unique naming convention.     This example minimally shows significant risk of confusion.     -->    </rdf:RDF>      With an unambiguous property declaration from an ontology layer this can be  done entirely within (future) W3C specs.      Jeremy        

        Brian:  > Your noting is noted.  Did you have a specific suggestion in mind?    Thank-you, ...     The current test cases have a regular format that is easy to automate  tests against: look for an rdf file, and an nt file and match them up.  Or look for an error file and check you fail it.    If we were to extend the test cases with different paradigms I would  suggest:  + the paradigm should be clear.  + there should be no need to read a readme to understand a particular  test  + the different paradigms should be different top-level directories.    e.g. we copy all the current tests into a directory "syntax" leaving the  internal structure unchanged,     The paradigm syntax supports error*.rdf and test*.{rdf,nt} tests.    We could then have a paradigm "entailment" each test could consist of a  directory with two sub-directories "premises" and "conclusions".    The "premises" sub-directory would then include the axioms file as well  as others.    Personally I think I would prefer that each test in the "entailment"  paradigm used either RDF/XML or N-triples for its facts (not both). No  point in confusing a test for one thing with a test for another.    We can still have a readme explaining the paradigm, just we expect to  have more than one test in the same paradigm, and the developer having  chosen to run tests of this paradigm only needs to write one lot of  code.      Another paradigm I proposed earlier was "equality" where each test  consisted of two or more RDF/XML files that contain the same model. I  saw this as useful for testing xml:lang, which does not occur in  N-triples.      Jeremy        

          I am not sure how aware everyone is of already deployed PKI    On a windows environment    Open IE    Tools => Internet Options     Content => Certificates ...    Then Intermediate Certification Authories or         Trusted Root Certification    Then select one and click on View and you can find out a lot about it ...    I was surprised not to find an address - but you do get country and name    I think we can presuppose this sort of infrastructure or equivalent if we   want it.      I would tend to see this as only necessary for financial transactions, and   the algorithm I just posted is intended to be useful with different trust   policies at step 3.    Jeremy        

            Graham Klyne wrote:      > XML namespaces 1.1: http://www.w3.org/TR/xml-names11/  >   > I also note that this spec does not *define* IRIs,       Yes it does,  Definition:    http://www.w3.org/TR/xml-names11/#dt-IRI    Ahh, I made a mistake, they use the term IRI reference not IRI ...    Hence the proposed resolution should be to globally substitute URI   reference by IRI reference and uriref by iriref etc.    Jeremy        

          Note my section 4 is there mainly for Pat to trash and start over.    I tend to think that an approach which permits you to trust (yes/no) a  number of named graphs of your choice gets close to the continuum approach  that is clearly a more accurate model of how people operate. e.g. as my  level of paranoia goes up I will trust fewer graphs. This is then reflected  in a classic logic with just t/f    Jeremy        > -----Original Message-----  > From: Chris Bizer [mailto:chris@bizer.de]  > Sent: 16 March 2004 14:59  > To: Patrick Stickler  > Cc: phayes@ihmc.us; Jeremy Carroll; www-archive@w3.org  > Subject: Re: more text / Trust bipolar decision or continuum  >  >  > We tend to see trust as a bipolar decision by an agent. You trust  > a graph or  > you don't trust it. This conflicts with the view of the majority of trust  > researchers, who see trust as a continuum.  >  > See quote from one of my documents below:  > "There is a wide range of different trust definitions known from  > physiology,  > sociology, economic science and computer science. There is no general  > agreement on the term "Trust". A comparison of the different views on the  > topic and the different trust definitions can be found in [Marsh94] and  > [Gambetta00]. Following Joseph M. Reagle [Reagle02], we define trust as:  > Trust (worthiness) is the degree to which an agent (human or machine)  > considers information to be true for a given time and context.  > Our definition refers to the following aspects of trust:  > -There is uncertainty in trust situations, which cannot be  > eliminated. It is  > only possible to minimize uncertainty.  > -Trust is subjective. Different users have different views of the  > world and  > different subjective trust requirements in the same situation.  > -Trust depends on the context and changes over time.  > -Trust in a continuum and no bivariate property. "  >  > This conflicts with what we write in  Chapter 4:  >  > "The meaning of a set of named graphs depends on a separate decision about  > which of the graphs to accept. We represent this decision as a set A of  > nodes naming the accepted graphs. The meaning of a set of accepted named  > graphs hA,Ni is given by taking the graph merge Sa2A N(a), and then  > interpreting that graph using the semantics of RDF[?]. Any extension  > semantics of RDF can be used; in this paper we uniformly use those of OWL  > Full[4]."  >  > I totally agree with Jeremy, that for practical reasons we should have a  > bipolar view on trust in the context of the Semantic Web at it's current  > state of development. But the interesting question is: Is this  > bipolar view  > required for RDF semantics or OWL to work or can we be open to  > agents using  > continuum based trust models (modal logic ??) ?  >  > I don't mandate, that we should include this stuff in the paper, but it  > would be nice if our approach wouldn't exclude future agents that  > might use  > continuum based trust models (and will have the unlimited processing power  > to reason based on these models :-). In addition it would make  > our work less  > attackable for the trust community.  >  > Chris  >  >  >  >  >        

        Jeff Pan wrote:  >   > How is it possible use the predicate cmPerM to detect the inconsistency in  > the above example, i.e., 15cm is not 1.5m?  >     Isn't this one of those things that we currently have no solution to.  The document it and move on approach might be appropriate.      OTOH assuming we had an oracle that could tell us      SameIndividual(      individual(type(LengthQuantity) value(150) unit(cm)),      individual(type(LengthQuantity) value(1.5) unit(m)))    then we seem to have a modelling problem ... because we now have two   different values for the same thing ...    in other words is a diameterValue a pair (value,unit) or is it an   abstraction of a length. If the latter then we can't represent it as   simply a pair becase of the many different equivalent pairs.  This would suggest a lengthInM and lengthInCM approach to modelling   units so that    SameIndividual(      individual(type(LengthQuantity) lengthInCM(150) ),      individual(type(LengthQuantity) lengthInM(1.5) ))    works without contradiction.    I suspect that long-term it is best to work with the abstraction rather   than the concrete pair.    Jeremy        

            I support Pat's proposal (credited to Peter).      However, I would like to detail the small amendment that Pat alluded to in:  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2003Aug/0021.html  [[  but can  be thought of as the Xpath nodeset  ]]    which I think should be possible to massage to the point where it addresses  Patrick's worries about lack of explicitness, and allow Frank to talk in the  primer either of XPath nodeset or canonicalized XML or both as he sees fit.    Details in line:      Pat Hayes:  > Gentlemen:  >  >  > I am completely sick of all these debates about XML literals.      +1    >  > 1. Concepts section 5.1 modified as follows (change starts at ***)  > .....  >  >  > Such content is indicated in an RDF graph using a typed literal  whose  > datatype is a special built-in datatype rdf:XMLLiteral ,  defined as  > follows.  > A URI reference for identifying this datatype  > is http://www.w3.org/1999/02/22-rdf-syntax-ns#XMLLiteral .  > The lexical space is the set of all strings which:  > are well-balanced, self-contained XML data [ XML ];  > correspond to exclusive Canonical XML (with comments, with empty  > InclusiveNamespaces PrefixList )[XML-XC14N] ;  > when embedded between an arbitrary XML start tag and an end tag form a  > document conforming to XML Namespaces [XML-NS]  > ***  > The value space is some set of entities, called XML values, which is:  > disjoint from the lexical space  > disjoint from the value space of any XML schema datatype (refer XSD)  > disjoint from the set of Unicode character strings (refer Unicode)  > in 1:1 correspondence with the lexical space.  >    Change - delete this line (moved further down)  > The exact nature of XML values is not specified.    >  >  > The lexical-to-value mapping is a 1:1 mapping from the lexical space onto  > the value space.    *** query - I think this dangling fragment is a typo  > The value of the lexical-to-value mapping      Add:  [[  Note: While the exact nature of an XML value is not specified,  one possibility is to use an XPath nodeset [XPath] corresponding  to the lexical form. This nodeset does not include any namespace  nodes other than those that are <a href="exc-c14n#???">visibly used</a>  within the lexical form.  In such an approach, to complete the definition of the value space equality  between XPath nodesets needs to be given via exclusive XML canonicalization  [XML-XC14N].  ]]    I am easy as to whether the reference to XPath 1.0 is normative or  informative.  Argument for informative is that this is merely a note.  Argument for normative is that there is a transitive normative dependency on  XPath 1.0 so perhaps we should be 'in your face' about it.      This note is, in my mind at least, adequately detailed to show that the work  could be done this way, and adequately brief to not give hostages to fortune  (and informative).    One final point is that it is an XPath nodeset, rather than an infoset,  because C14N works on the nodeset not the infoset.    Jeremy        

        >  > I note that all of the implementations of RDF with which I am  > familiar have  > implemented M&S with the assumption that literals have string semantics,  > i.e. literal("foo").equals(literal("foo")).  >  I read M&S as merely articulating syntactic facts, and hence reflecting a  syntactically tidy graph; this does not preclude semantic untidiness.    I prefer the option of "not deciding".  I could live with any of the options.    Syntactically tidy, (possibly) value based semantics, and valentines day MT.  For details see below.  (Or,  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Sep/0086.html  )    PROS:    - does not require changes to preexisting implementations: equals is taken  as syntactic    - does not preclude the "10" in <Jenny> <age> "10" from meaning the  integer ten.    - could support rdfs:range="xsd:int" construction    - could support tidiness    - does not fly in the face of the community feedback.    CONS:    - somewhat contorted (the divergence between syntax and semantics may  confuse)    - stresses further the separation of the abstract graph syntax (the Model  in M&S) and the interpretation (the Model in the MT) [we already have this  with our decision on datatypes of last Friday, see below for example]        Specifically:  - the graph is syntactically tidy  - the interpretation of a typed literal is given by its datatype  - the interpretation of a triple with an untyped literal has an extra level  of indirection (semantically untidy, the interpretation of the literal in  the triple depends on the property, and maybe the subject too)  - otherwise, and in general terms, the model thoery follows the valentines  day approach, which does not permit bnodes to match literals in entailments,  and hence the decisive questions cannot be asked.      As an implementator I would expect to implement two equivalence  relationships over graph nodes. equals() would reflect syntactic equality,  and sameValueAs() would reflect semantic equality:    e.g.           not equals( literal("<xsd:int>010"), literal("<xsd:decimal>10.0") )    but         sameValueAs( literal("<xsd:int>010"), literal("<xsd:decimal>10.0") )    and         n = literal("untyped")         equals( n, n )  but         not sameValueAs( n, n )    (I might prefer not to have sameValueAs defined over literal nodes, but only  over triples).      This does not require implementations to change; clarifies how to implement  RDFS; is somewhat contorted; and is a bit of a fudge.    A modification to this, would be to explicitly support [p rdfs:range  <datatype>] in it, in which case it is untidy. My weak preference is to not  require that there are any literals which do not have tidy semantics. (i.e.  exactly the valentines day mt position; the machinery of untidiness is  presented, but no commitment to actually use it!)    Jeremy      PS: At the Bristol F2F Guha talked about the mapping of the literal node  depending on either:   - only the literal   - the literal and the property   - the literal, the property and the subject    I can't remember whether any crucial showstoppers were identified to any of  these. I remember that rdf:object was a little disappointing with the middle  one. (And I think only the last made me feel alright about dc:Creator, but  then I'm out on limb with dc).        

        Patrick Stickler wrote:  > I think it's OK for bnodes to name graphs, but not for  > bnode graph names to span graphs.    I am convinced, does this leave bnodes as graph names as useless ... there   are further difficulties in the semantics that I need to raise.  Both Chris and Pat argue for URIrefs only as graph names.  (I'll send a further msg detailing the problem I have found)      Most of the detailed points I say "OK" or something, which means yes this   looks like a good point, I'll work it into the text and/or get back to you   on it.    >   > Section 2, para 1:  >   > I think we need to constrain bnode graph names to statements  > occurring within that particular graph itself. I.e., if you  > need to make statements about a graph in *another* graph, you  > must use a URI.  >   > Your examples in section 8 have statements where the subject  > is the bnode label of another graph, and I don't think that's  > valid (or should be valid) because it suddenly turns bnodes  > into global identifiers just like URIs when they are used  > as graph names.  >   While I disagree with the argument I agree with the conclusion, so I won't   discuss the argument.      > --   >   > Section 4: "using the URL from which an RDF/XML file is retrieved  > as a name for the graph"  >   > Perhaps it would be better to use the xml:base, if defined, thus  > avoiding some of the problems where the same document may be  > returned as a representation when resolving various URIs which  > may not in fact denote the graph in question. ???    Unfortunately there is no such thing as *the* xml:base, an RDF/XML document   can have many xml:base's defined within it.    > Section 4: use of parentheses  >   > Perhaps we should use curly brackets rather than parentheses  > to be more compatible with N3/Turtle, which use parentheses  > for collections.    I am easy - parentheses as opposed to braces was Chris's choice - I'll let   him argue the case (if he wishes to).    >   > --   >   > Section 6:  >   > Not that we need to mention this in the paper along with the plug  > for TriQL (though feel free to do so if you like ;-) ... but  >   > The definition for RDFQ [1] also now supports named graphs (or  > will, once I get around to updating it ;-)  >   > [1] http://sw.nokia.com/rdfq/RDFQ.html  >   > The rdfq:Query instance can have any number of rdfq:graph's  > defined, which constitute a form of "pre-query" to identify  > all graphs which match any of the specified templates, after  > which, the target templates are applied to the set of matched  > graphs. I.e.  >   > rdfq:inGraph a rdf:Property;  >    rdfs:domain rdfq:Query;  >    rdfs:range rdfg:Graph;  >    rdfs:comment "A template constraining the query to only matching   > graphs.".  >   > [a rdfq:Query;  >    rdfq:graph  [a rdfq:Graph; swp:assertedBy [a swp:Warrant;   > swp:authority [foaf:email <mailto:john.doe@example.org]]];  >    rdfq:graph  [a rdfq:Graph; swp:assertedBy [a swp:Warrant;   > swp:authority [foaf:email <mailto:mary.smith@example.org]]];  >    rdfq:target [a rdfq:Target; dc:created [a rdfq:Value; rdfq:lt   > "2004-02-02"^^xsd:date]]].  >   > or minimally  >   > [:graph  [swp:assertedBy [swp:authority [foaf:email   > <mailto:john.doe@example.org]]];  >  :graph  [swp:assertedBy [swp:authority [foaf:email   > <mailto:mary.smith@example.org]]];  >  :target [dc:created [:lt "2004-02-02"^^xsd:date]]].  >   > I.e. find resources created before 2004-02-02 from graphs asserted by   > either John Doe  > or by Mary Smith.  >   > There can be any number of graphs specified, and for those that match   > the specified  > criteria, the templates are then applied only to statements in those   > graphs. I.e. first  > identify all matching graphs, then all matching targets within those   > graphs.  >   > If no graph is specified, then the templates are applied to all/any graphs.  >   > If one is able to infer class membership of graphs as trusted and   > asserted, then one  > can qualify all queries easily as:  >   > [a rdfq:Query;  >    rdfq:graph [a x:TrustedAssertedGraph];  >    rdfq:target [a rdfq:Target; dc:created [a rdfq:Value; rdfq:lt   > "2004-02-02"^^xsd:date]]].  >   > or minimally  >   > [:graph [a x:TrustedAssertedGraph]; :target [dc:created [:lt   > "2004-02-02"^^xsd:date]]].  >   > I.e., find resources created before 2004-02-02 according to claims made   > in trusted,  > asserted graphs.  >   > If one simply wants all of the dc:title values for such resources,   > rather than  > complete descriptions of the matched target resources, the property   > rdfq:select  > can be used, and the results are expressed as variable bindings using the  > Result Set Vocabulary:  >   >   > [:select ( "title" );  >  :graph  [a x:TrustedAssertedGraph];  >  :target [dc:created [:lt "2004-02-02"^^xsd:date];  >           dc:title   [:id "title"]]].  >   > One of the nice things about the way RDFQ handles this in vocabulary is   > that  > the actual syntax of RDF/XML, N3/Turtle does not have to change in order to  > express graph-specific queries.  >   > --       Another reference is good, I'll trim your text down (possibly just to a   single phrase)    >   > Section 7:  >   > The example should be terminated with an extra statement in  > graph G5 so that the provenance chain is bounded:  >   > G5 (...  >     G5 dc:creator Peter .)  >   OK      > --   >   > Section 8.1: bnode graph names  >   > As mentioned above, you have bnode bindings spanning multiple graphs,  > which I don't think should be valid. The use of _:g1 in graph _:h  > should have no meaning outside of graph _:h and thus does not in  > fact refer to graph _:g1 since the bnodes of graph _:h are disjunct  > from the bnodes of graph _:g1.  >   > A bnode graph name is only relevant to statements within that graph, IMO.  >   > Better to just use URIs in these examples. In fact, I think we should  > consider it a best practice to use URIs to name graphs rather than  > bnodes.    Best practice = let's change it now and drop bnodes as graph names?    >   > Thus:  >   > G, G1 (...)  >   > H (...  >    G1 swp:quotedBy _:w2 .  >    ...)  >   > --   >   > Section 8.1: "We require [the value of the swp:signatureMethod property]  > to be a literal URI, which can be dereferenced on the Web..."  >   > Question, what is the difference between a URI and a literal URI? Do  > you mean rdfs:range xsd:AnyURI?  >     xsd:anyURI I think - a literal URI denotes itself in the RDF Model Theory   and hence can then be used for dereference operation, whereas a URIref node   denotes a resource, presumbably the same resource as that for which you get   a representation when you dereference it, but that takes us well into the   social meaning issue, that we are trying to skirt around.    > Also, while requiring the signature method to be denoted by a URI,  > I don't think we need to go so far as to require that the URI be  > web-dereferencable. It's *convenient* if it is dereferencable, and  > it's probably a "best practice" for it to be dereferencable, but  > I don't see it as an actual requirement. As long as the publisher  > and consumer understand the URI in the same way, that's all that  > counts.  >     That's technically correct, however in practice there will only be a   handful. For the paper I am inclined to leave it as required, it simplifies   the explanation without any real great loss of generality. Without the   document it is much harder to write the semantics of signature which does   actually depend on the method indicated (and if that method is by private   agreement then it is slightly awkward!)    > --   >   > Section 8.2, last para, last sentence:  >   > Consider changing "...some of their RDF does include its own assertion"  > to "...some of their graphs do include their own assertion", which  > I think is what you mean and what we want to say. "their RDF" is  > pretty broad...    I'll look at this.    >   > --   >   > Section 10:  >   > I'm OK with your proposal to delete and address elsewhere.  >   Chris likes that idea, so I think does Pat ...      > --   >   > That's all. The rest reads pretty good to me. I especially appreciated  > the use case of syndication showing where assertion vs. quoting is  > useful.  >   > Patrick  >     Jeremy        

            Brian McBride wrote:    > Capiche!      ?? Capisci?        

        This comment is prompted by:    http://lists.xml.org/archives/xml-dev/200306/msg00052.html      I have had NFC checking for RDF/XML for many months.    The first announcement message was:    http://lists.w3.org/Archives/Public/www-rdf-interest/2002Jul/0012.html    That version 1.5.0 and onwards, checked plain strings, and IRIs for NFC   compliance, rejecting documents with data not in NFC (in strict mode; in   default mode a warning is issued).    Because of changed advice from RDF Core based on changed advice from I18N   WG, the latest version (Jena2preview3) no longer checks IRIs.    The relationship between this and XML 1.1 NFC checking is not direct.    + The input documents are XML 1.0 (not 1.1).  + These are analysed according to the RDF/XML syntax.  + This generates a set of triples.  + The triples are checked for NFC compliance according to the rules   suggested by the RDF Core WDs.    I had hoped that there would be an XML 1.1 system that did the NFC   checking, according to the XML 1.1 CR rules, since then the last step is   redundant.    I am pretty sure that there are other implementations of RDF/XML that make   similar checks.      Frankly, integrating NFC with an XML parser is not hard, given public   domain libraries such as icu4j.    Jeremy        

        > " We believe that these rules are complete in the following sense: if S   > rdf(s)-entails E then there is a graph which can be derived from S+the   > rdf(+rdfs) axiomatic triples by these rules which simply entails E.   > However, this has not been conclusively established at the time of   > writing."  >   > Note that this does not mention closures, so the question of whether or   > not they are finite does not come up.  >   > This is done in a modified version:   > http://www.ihmc.us/users/phayes/RDF_Semant_Edit_appenda.html  > dated 18a June  >   > I will try to propose resolutions for the outstanding semantic issues   > asap, but I may have to get on a plane soon.  >   > Pat      That version suffers the following defects vis-a-vis simple completeness    <eg:a> <eg:b> <eg:a> .    entails    _:a <eg:b> _:b .    but this cannot be shown.    Similarly    _:a <eg:b> _:a .    entails    _:a <eg:b> _:b .      but this cannot be shown.    However your wording in msg    http://lists.w3.org/Archives/Public/www-rdf-comments/2003AprJun/0202    is, I believe, satisfactory.    ...      The same phrase could be used to conjecture the completeness of the simple   entailment rules.    Again, stylistically I dislike the phrase "at the time of writing" in the   statement of your conjecture. (Take it or leave it)    Jeremy        

        IRI or URI original character sequence?    I am happy *enough* with Dave's possible new text (particularly third para),  but should highlight a choice between using IRI term or not.    Dave suggested:  [[[  might be changed to:    -----------------------------------------------------------------------    absoluteURI  ::=  character+ with escapes as defined in section URI  References    -- http://www.w3.org/2001/08/rdf-test/#absoluteURI      3.3 URI References      URI references are sequences of US-ASCII character productions    encoding Unicode characters that form an Internationalized    Resource Identifier (IRI) [IRIs].      Disallowed IRI characters (see [IRIs] 2.3 part B) are represented in    UTF-8 and then encoded using the %HH format, where HH is the byte    value expressed using hexadecimal notation.      Characters above the US-ASCII range are made available by the \u or    \U escapes as described in section Strings for ranges [#x80-#xFFFF]    and [#x10000-#x10FFFF] respectively.      Characters [#x0-#x1F] and #x7F are forbidden in URI references.      -- http://www.w3.org/2001/08/rdf-test/#sec-uri-encoding    -----------------------------------------------------------------------      along with a new reference      -----------------------------------------------------------------------    [IRIs]       Duerst and Suignard, Internationalized Resource Identifiers (IRI)       IETF Internet Draft (work in progress), April 17 2002,         http://www.ietf.org/internet-drafts/draft-duerst-iri-00.txt      -- in section http://www.w3.org/2001/08/rdf-test/#ref_normative      -----------------------------------------------------------------------  ]]]    Since IRI spec is still draft, and not yet at consensus, it is  peculiar to have a normative link.  A different way to go, probably by copy-and-paste is to use the  wording of X-Link at the point where the I18N guys got in there.    This has real differences for BiDi, (and maybe other areas).  i.e. the IRI specs says that some ways of doing bidi are OK,    and other ways are not. X-Link approach ignores issue    and hence implicitly blesses all ways of doing BiDi.    I'll try and propose alternative text replacing the IRI link.    BTW: petty wordsmithing point is that first para says we are talking  US-ASCII and third para says we're not.    Jeremy        

          I wanted to draw the WG attention, particularly Pat, to a mathematical issue  with the graph syntax.    I do not believe that this has any substantive content, but is merely  aesthetic!      In the very first version of the model theory, the RDF graph was described  as having nodes some of which had labels, and the labels were URI refs or  strings.    In the most recent version, some of the nodes are URI refs and some of the  nodes are strings (and none of the nodes are labelled).    In the new document draft, we have reverted to the earlier version using  explicit node labels.    The motivations for this include:  - tidying a graph is an explicit operation rather than implicit by  mathematical construction  - it easier to modify the exact tidyness specification (if the WG changes  its mind about whether literals are tidy or not - uriref nodes don't seem in  doubt).  - implementations will almost all use nodes with explicit labels.      The first point is the decisive one. From a mathematical point of view Pat's  latest model theory treatment in which the URI refs and strings *are* the  nodes is extremely elegant. Tidiness just falls out and no text needs to be  spent on it.  However, in practice any implementor needs to be aware of tidiness as an  operation which has to be coded, and any user needs some understanding of  tidiness. Thus, I felt that Pat's earlier treatment, while a little more  clunky, is clearer for our intended audience: implementators, users, web  architects - rather than mathematicians.      Although I raise this issue now, I would hope that any debate, if debate is  needed, can be postponed until after the first WD. I don't think this is a  crucial issue either way.    Jeremy        

        Jeremy:  >> - agreement from two or more software developers of Semantic Web tools   >> to add API support for the schema  >     Aldo Gangemi wrote:  > Are you offering to investigate on this?  I am offering to suggest to the Jena team that we should provide some   support for a WordNet schema if there was *one* to support. (The range of   choices is our main current obstacle).    I don't think we have the time to do much work on this ... the normal level   of support we provide for such things is pretty minimal - a Java class with   the schema property and classes as member fields - but that is quite useful   and not very much work. I would be surprised if we would do more than that   in the short term, (there are some Jena-team discussions that suggest we   might want to do more).    I wouldn't want to take the lead here (in terms of what other software   teams might do), I suggest that the message you're drafting includes a   specific part for tools developers asking what support for WordNet they   might include. If so I promise a response from the Jena team.        >   > Wait wait ... WordNet as an ontology (the synset network) is stable, and   > versioning is Princeton's work. When anyone takes it, should mention   > which version is using, what parts are used, etc.  > The researches aimed at "changing" the synset network (in the best   > cases) do not modify WordNet arbitrarily, but "remap" some synsets in   > order to make it compliant to some other resource. WordNet's structure   > is still there, but it is  "aligned" to something else (check the   > projects I have mentioned). The benefits of these remappings are quite   > well known and described, and have applications (cf. the FOS project I   > have mentioned above: without alignment, we couldn't use WordNet for   > that task).    The penny began to drop here ... I had not realised this complexity, and   begin to see the need for 'phase two' (in my terms). That looks hard.      >   > I hope to circulate a draft message before the next telecon.    We're making progress ...    Jeremy        

          text/html attachment: stored          

      I am sorry, I messed up.    The wording I proposed does not meet up with DaveB's proposal for N-triple  (i.e. that xml ltieral equality in N-triple is binary compare).    Here's another attempt, with the same intent but also getting compatibility.      NEW:  [[[  1. Propose that:  - the exact form of the string value corresponding to any given XML Literal  within RDF/XML is implementation dependent.  - the string value is well-balanced XML that can be inserted as the elment  content between two tags:    <foo></foo>    to form an XML document, satisfying both XML and XML Namespaces.    - taking the exclusive canonicalization of both the original XML Literal in  its containing document, and the string value within the dummy "<foo></foo>"  document produce the same character string.  - that the canonicalization above is without comments  - that this closes the xml literal and xml literal namespaces issues    2. Propose that:  The Ntriple test cases for xml literal are defined using the exclusive  canonicalization without comments. The following algorithm can be used to  generate n-triple output to verify test case conformance:  - take the string value returned from the parser for an xml literal  - create a new XML document by inserting that string value between  <foo></foo>  - take the exclusive canonicalization without comments of the element  content of this new document and output this value as the string component  of the n-triple.  ]]]      Moreover, we don't need to add a suite of C14N-X tests to the test suite, so  how about restricting our test cases to as easy as possible ones while  exercising the relevant cases, e.g.:  - no predefined entity or character references in the output  - keeping the number of attributes in elements down, and trying to avoid the  cases where reordering of attributes happens.  - no new lines at all  - input should be reasonably canonical (e.g. canonical use of whitespace,  use of (") not (') for attribute values)      I would guess we do need to show  - adding visibly used namespace declarations  - PI handling?  - entity reference substitution?    I think we could omit:  - comment handling?  - removing of unused namespace declarations?    The dividing line is:  - the ones I think should be in show what is interoperably required of any  implementation needs to do (e.g. expand entities, retain PIs, put in  visisbly used namespaces)  - areas which are only part of C14N and not really imported into the RDF  specification except as a way of getting equality are not in the tests  - areas which we are deliberately leaving vague are not in the tests.    OLD:    > [[[  > Propose that:  > - the exact form of the string value corresponding to any given  > XML Literal  > within RDF/XML is implementation dependent.  > - the string value is well-balanced XML that can be inserted as the elment  > content between two tags:  >  > <foo></foo>  >  > to form an XML document, satisfying both XML and XML Namespaces.  >  > - taking the exclusive canonicalization of both the original XML  > Literal in  > its containing document, and the string value within the dummy  > "<foo></foo>"  > document produce the same character string. Equality between xml  > literals is  > defined on this basis, but only for the purpose of exercising the test  > cases. [Such equality may be used for other purposes but there are  > other notions of equality (such as via Inclusive Canonicalization) that  > may also be useful.]  > - that the canonicalization above is without comments  > - that this closes the xml literal and xml literal namespaces issues  > ]]]  >        

          I am not sure whether these changes are included in the Last Call version or  not.  I think it is important that the additional sentence the DanBri drafted in  the telecon be included in the SOTD either way.    Jeremy    > -----Original Message-----  > From: w3c-rdfcore-wg-request@w3.org  > [mailto:w3c-rdfcore-wg-request@w3.org]On Behalf Of pat hayes  > Sent: 17 January 2003 09:33  > To: w3c-rdfcore-wg@w3.org; bwm@hplb.hpl.hp.com  > Subject: summary of changes to semantics doc  >  >  >  > Peter was right in noting that a vital condition had been left out of  > the RDFS semantics, this being that ICEXT(I(rdfs:Literal)) should be  > a subset of LV. This has now been fixed; also,  any recognised  > datatype must be a subclass of rdfs:Literal.  >  > Typed literals with language tags are now handled by the semantic  > equations.  >  > Rule rdfs11 has been renamed rdfD0c and moved to the datatype  > section. Also two new rules rdfD0a/b have been added to handle  > language tags in typed literals.  >  > The rules rdf3a/b for handling XML literals have been rewritten to  > handle the bug noticed by Jan. (The result is kind of ugly, but it is  > correct and this way I didn't need to rewrite all the recursion  > lemmas; and there is a remark to the effect that this could be  > replaced by a canonicalization operation provided that it is applied  > to antecedents and consequents; similar comments have been added to  > the discussion of datatype normalization in section 4.3)  >  > The Lbase axioms for datatyped literal handling have been largely  > rewritten and a few other of the axioms revised in the light of  > Graham's observation. The newer ones are a little longer but more  > obviously in correspondence to the model theory. The axioms now have  > an explicit predicate for describing language tags, as suggested by  > Peter.  >  > Ive added the term 'token' to the glossary.  >  > ------  >  > Pat  >  >  > --  > ---------------------------------------------------------------------  > IHMC(850)434 8903 or (650)494  > 3973   home  > 40 South Alcaniz St.(850)202 4416   office  > Pensacola               (850)202 4440   fax  > FL 32501            (850)291 0667    cell  > phayes@ai.uwf.edu          http://www.coginst.uwf.edu/~phayes  > s.pam@ai.uwf.edu   for spam  >  >        

        >  > >The key question is what will this achieve in terms of actual deployment.  > >What I have seen in webont is that at least some of the target community  > >for RDF is resistant to XMLliterals at all.  > >Every obstacle to easy deployment of XMLLiteral will be a reason to not  > >deploy it.  >  > So do you think that half-way deployment (in the sense that an  > unsatisfactory solution is deployed) is better?  >  > Just some background on why this argument which may look very  > convincing to you may not really help you to convince us:  >  > Traditionally, i18n people are not very sympathetic  > to arguments such as "this will be doing the right thing for 80%  > of the world, so let's do this rather than risk that things won't  > be done at all". For i18n, 80% is just simply not enough.  > Also, we are somewhat used to the unfortunate fact that i18n  > features don't always get implemented first. We just had to  > learn to live with it.    I am certainly not saying that.      >  >  > >Currently (based on the LC design) webont have declared that OWL tools  > >should minimally support xsd:string and xsd:integer, whereas  > >rdf:XMLLiteral is optional. This means that certain entailments are  > >implementation dependent  > >(contrast  > >http://www.w3.org/TR/owl-test/proposed-misc-200-xmlliteral#miscel  laneous-204  >http://www.w3.org/TR/owl-test/proposed-misc-200-xmlliteral#miscellaneous-20  5  >)  >The same file is constistent or inconsistent depending on implementation  >specific parameters (reasoning support for rdf:XMLLiteral, which is  optional).    >If I understand this example correctly, an OWL parser that does not  >support XML Literals will not be able to decide whether by chance,  ><b>Good!</b> and <b>Bad!</b> might are actually the same after  >canonicalization, and therefore may not see that there is a conflict  >because there are two different property values for a functional  >property?    Well yes and no. Yes in that in the LC design canonicalization was done in  the reasoner. No, in that with our current design it is much easier for an  OWL reasoner to support rdf;XMLLiteral. The parser does the  canonicalization.    > If that's true, then there will be similar problems for datatypes  > such as float and double, and so on. Is that considered acceptable?    Yes    > If that's true, then it also means that the RDF parser actually  > does not do any canonicalization on the XML, nor that any RDF store  > would seem inclined to do canonicalization on the XML. That seems  > to me to be highly inefficient, i.e. in terms of actual implementations,    Yes we've changed it, the reagle-01, reagle-02 LC issues. This change is  essentially orthogonal to the xml:lang issue.    > If RDF parsers and RDF stores actually cannonicalize XML, then  > the question is why would it be so difficult for OWL applications  > to support it?    Ask WebOnt (there is no good reply in my view)    > Turned the other way round, when DanC asked us  > whether we are okay that only string and integer types have  > to be supported by OWL applications, we should probably have  > asked to add XML Literals, because the benefit for i18n is  > large while it seems that the actual cost on the OWL level  > is actually rather low.    too right      >> From my point of view this is a failure of *this* WG to have a design  >> that is sufficiently simple that implementors and others feel they can  >> commit to it. I believe that the simplifications we have made will be  >> beneficial for I18N, in that the only remaining difficulties for  >> XMLLiteral are in the parser, and many parser writers seem bought in to  >> doing the work.  >  >So do they actually do the canonicalization, or not?    Some do, we believe the others will.    Jeremy        

      *** sounds of back-pedalling ***    >  > 16: Issue rdfms-aboutEach  >  > It has been suggested:  >  >   o  the WG resolves to remove rdf:aboutEach from the language on  > the grounds  [..snip..]  >  > Alternatively, it has been suggested that we are straying beyond  > the borders of our charter in removing it, and it can be useful.  >  > Propose, on the grounds that it does not seem to be harmful  > that it should be retained.  >  >        Given that I am alluded by the suggesting, I note that the charter's  function has been further clarified to me (not in e-mail).    I would be happy to go either way on this; and will concur with the  majority.  I think Dave made a good case for dropping it; but not bullet-proof. Graham  later observed:    [[[  Which makes me think that the criteria for dropping bad features should  probably be less stringent than the criteria for adding "cool"  features.  ]]]    which is a good point.      Jeremy        

            I propose that we reject the comments in  http://lists.w3.org/Archives/Public/www-rdf-comments/2003OctDec/0120.html    with headings    - Treatment of language information for XML Literals:  - XML Literals as typed literals    and send the following reply:    [[    Dear Martin,    thank you for your comments.    This message replies to the two comments    - Treatment of language information for XML Literals:  - XML Literals as typed literals    We regret that we have decided to reject these comments.    A rationale can be found in  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2003Sep/att-0275/i18n-par  t.html    (with the addition of the link to the following msg which is the webont  endorsement of the current design:  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2003Oct/0039.html  )    Please reply cc-ing www-rdf-comments as to whether you accept this or not,  and if you wish to formally object.    thanks again    Jeremy Carroll    ]]        

        > We also have the case of names not in the name space.  Should the parser  > barf if it meets a property or a typed node like rdf:foo?  >    Any reasonable parser will barf. It is unlikely that the user intended to  write what they did write.    If the WG decide that this is not permitted then the barf will be an error,  otherwise the barf will be a warning.    Jeremy        

        > RDF XML Canonicalization Intro  > ==============================  > Intended for the RDF group, summarising C14N and XML subsets.  >    There are two XML Canonicalization specifications.    http://www.w3.org/TR/xml-c14n    and    http://www.w3.org/TR/xml-exc-c14n      These are produced by the XML Signature working group who wish to make it  possible to provide digital signatures for XML documents and XML document  subsets.    One solution would be to sign just the preprocessed document, but that would  mean that documents that are identical as XML would have different  signatures. XML Infoset defines a minimum set of things that may differ  between identical XML documents, including the character encoding, white  space in various place, attribute order, empty element tags vs a start tag  followed by an end tag etc.    The C14N route is based around first turning any XML document or document  subset into its canonical form, (which is the same for equivalent documents)  and then signing that.      Moreover, the XML C14N work, decided that character and entity references  would also be subject to canonicalization, and their use not be regarded as  part of the document to be signed. In contrast, namespace prefixes, which  are also in infoset, were determined to be part of the document, and  namespace prefix rewriting (i.e. the process of renaming namespace prefixes)  is *not* part of canonicalizing.    So two documents that:  - have the same infoset  - or differ only in their use of entity and character references    canonicalize the same.    Key aspects of canonicalization are given in the short section  http://www.w3.org/TR/xml-c14n#Terminology  e.g. "Empty elements are converted to start-end tag pairs"      C14N addresses document subsets both within the main spec at:  http://www.w3.org/TR/xml-c14n#DocSubsets    and within the exclusive spec (which only addresses document subsets).    It should be noted that within C14N document subsets are not assumed to be  contiguous.    The two C14N specs differ in the exact treatment given to namespaces.    C14N can be used to address the parseType="Literal" problem because:  - it allows us to clarify that two RDF/XML files that only differ in the  exact nature of XML in an xml literal, but whose infosets are the same, are  in fact the same.  - it does specify (a number of alternative ways) how to address the  namespace issue.  - it does provide an answer to what is an XML document subset, in that it  tells us if two such subsets are the same.      However, it does leave a number of things to be decided.    1: The exact treatment of namespaces (whether to use exclusive or inclusive  canonicalization).  2: The treatment of XML comments  3: In precisely what way we the RDF specs depend on the XML C14N specs.    There are also some limitiations with C14N identified at:  http://www.w3.org/TR/xml-c14n#Limitations    Moreover the exclusive form has additional limitations, to be described  later.    Jeremy        

          I suspect Emmanuel just needs to slot in the latest Jena release ...  (I understand the validator is now using the version 2 stream which is up to  date on all WG decisions)    Jeremy    > -----Original Message-----  > From: w3c-rdfcore-wg-request@w3.org  > [mailto:w3c-rdfcore-wg-request@w3.org]On Behalf Of Dave Beckett  > Sent: 11 August 2003 10:17  > To: Patrick Stickler  > Cc: ext Frank Manola; w3c-rdfcore-wg  > Subject: Re: W3C RDF Validator vs. tbl-03  >  >  >  >  >  > On Mon, 11 Aug 2003, Patrick Stickler wrote:  > > I recall the decision was "doesn't have to generate" not  > > "should not generate".  > >  > > So technically, the validator is conformant. Though someone  > > may still wish to change it to omit the triples in question.  >  > There is no fuzziness at all in what triples are generated  > from RDF/XML - that is one of the things we were revising for.  > parseType="Collection" must not generate them after our change.  >  > Applications that don't want to be conformant can do what they  > like, as always.  >  > Dave  >  >        

          I spent a little time trying to understand what position I18N took on the   exc-c14n last call draft, which included the design decision to discard   xml:lang, for which RDF Core is now getting so much grief.      In summary, the dropping of xml:lang when a XML fragment is being carried   within a larger XML document, does not appear to be a new issue, but one   that was considered and accepted by I18N two years ago.        Detail:    Misha forward the last call to I18N:  http://lists.w3.org/Archives/Member/w3c-i18n-ig/2001Nov/0043.html    There was some concern about the xml:lang issue  [[  ACTION: Martin to ask for a health warning re problem with Exclusive  Canonicalization, where xml:lang and perhaps namespaces get ignored when  signing a payload.  ]]  http://lists.w3.org/Archives/Member/w3c-i18n-ig/2002Feb/0020.html  (12th Feb)      This resulted in (as far as I can tell):  http://lists.w3.org/Archives/Public/w3c-ietf-xmldsig/2002AprJun/0065.html  (apr 21)    (There seems to have been some off-list traffic just before)    However, as far as I can tell, the end result was acceptable to I18N.    (The minutes of the next I18N telecon record the action as done)  http://lists.w3.org/Archives/Member/w3c-i18n-ig/2002Apr/0106.html          Jeremy        

            text/html attachment: gk.htm    text/html attachment: s.htm    text/html attachment: tdl.htm          

            Dan Connolly wrote:    > On Fri, 2003-02-28 at 06:14, Graham Klyne wrote:  >   >>At 10:04 PM 2/27/03 -0600, Dan Connolly wrote:  >>  >>>It's not exactly RFC2396's absolute URI plus optional fragment;  >>>that doesn't include http://example/Andrȷ ,  >>>which may be in the vocab of an RDF interpretation.  >>>This non-ascii stuff is the bit that's too new to  >>>import from any ratified spec.  >>>cf. TAG issue IRIEverywhere-27, cited from concepts section  >>>6.4 RDF URI References).      The williams issues are relevant here.    He doesn't like the term RDF URI Reference because:  1: it looks like RDF doing its own thing rather than following other   peoples' leads (despite the fact we were trying to follow charmod)  2: an HTTP URI reference starts http: ...    He likes the term IRI, we could import this term from XML Namespaces 1.1;  and it does not have "reference" in it but is very nearly what we use   except for the NFC stuff.    I think we should await input from I18N before nailing this one down.    Jeremy        

            Dan Connolly wrote:    > To my satsifaction, we do; as Brian pointed out:      Oh yes ...    that looks like enough to me too.    Jeremy        

            Brian McBride wrote:    > Jeremy Carroll wrote:  >   > [...]  >   >>  >> (Hmmm I had thought that the 'yes' text was going to be obviously   >> better, but it's not clear).  >   >   > Given that the benefit is not clear to you the proposer, and the obvious   > cost of the potential impact on other specs, do you still wish to propse   > the change of terminology?  Can we reduce this to one proposal?  >   > Brian  >     OK - tomorrow morning, I'll send a single proposal based on the plain   literal unchanged version.    Jeremy        

          Here is the new test    error001 ==> test017    Note that I have, for consistency, treated the empty path as "/".    <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"           xmlns:eg="http://example.org/"           xml:base="mailto:Jeremy_Carroll@hp.com">     <eg:type rdf:about="relfile" />    </rdf:RDF>    ==>    <mailto:/relfile> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type>  <http://example.org/type> .        Sorry for being slow on the uptake.    Jeremy          application/x-zip-compressed attachment: xmlbase.zip          

        Hi Pat    Only real comment:    ====    The appendices are A, B, and 3.    There is an early reference in section 0.2 to appendix A.  Unfortunately this is appendix A of an earlier draft that has been deleted.    ====    Generalities:    I have given the update a speed read.    In particular I have not attempted to read the proofs at all yet.  I am hoping it is acceptable to not do so, and to leave the "community" to  pick up any errors there.    If I have time before Friday I may give it a shot.    I really only looked at the bits in yellow.    All looks fine to me.  (I guess I mean you have addressed the issues I raised, thanks).        Jeremy        

        Attn all naughty bit suggests some part of URI space to be used for bNodes  when serializing.  Search for "NAUGHTY"      Hi Dave,    here is some serialization text possibly for sect 6 in your draft:    [[[[  <p>  There are two different approaches to serializing RDF.  </p>  <p>  The basic approach uses the basic RDF syntax from RDF Model &  Syntax([RDFMS]).  In this:  </p>  <ul>  <li>  All blank nodes are assigned arbitrary URIs.  </li>  <li>  Each resource is listed in turn as the subject of a top-level  <code>rdf:description</code> element, using an <code>rdf:about</code>  attribute.  <br/>  For each triple, with this resource as subject, an appropriate property  element production is  used, with either string content (possibly empty) or an  <code>rdf:resource</code> attribute specifying the  object of the triple.  </li>  </ul>  <p>  The basic serialization is recommended for applications in which the output  RDF/XML is  to be used only in further RDF processing.  </p>  <p>  Where the intent is for the output RDF/XML file to be read by people, the  basic serialization proves unsatisfactory.  </p>  <p>The basic serialization does not conform to more restricted sub-dialects  of RDF, such as RSS [RSS] or CC/PP [CC/PP]. Hence, it is not appropriate for  such applications, for which  dialect specific serializers are needed.  </p>  <p>  If more human readable output is required the following factors should be  considered:  </p>  <ul>  <li>There are many choices, with many RDF/XML documents corresponding to  identical  RDF graphs. Individual triples can be represented in numerous ways. High  quality RDF  serialization requires that these choices are considered by the serializing  code.  Some are more appropriate than others in an application  dependent fashion.  </li>  <li>The triples in the graph need to be considered in an appropriate order.  There are many choices of order, some being more appropriate than others in  an application  dependent fashion.  </li>  </ul>  <!-- NAUGHTY bit -->  <p>  Serializations tend to be more readable if they do not attach URI labels to  blank nodes.  However, it is necessary, for some graphs, to do so, in order to refer to a  blank node in  two parts of the RDF/XML document produced. This is typically necessary when  a blank  node is the object of two triples.  In such cases, RDF processors may use URIs beginning with  "http://www.w3.org/2001/12/RDF/bnode/".  </p>  <!-- end NAUGHTY bit -->  <p>  It is not possible to use the RDF/XML serialization for serializing an RDF  graph in  which any triple has a property label which cannot be expressed as a qname.  </p>  <p>An approach to serializing RDF/XML using the full grammar in a top-down  recursive descent fashion is discussed in [UNPARSING].  </p>  ]]]]    Additional references:  [[[[  [CC/PP]Composite Capability/Preference Profiles (CC/PP): Structure and  Vocabularies  W3C Working Draft 15 March 2001,  World Wide Web Consoritum   http://www.w3.org/TR/CCPP-struct-vocab/.  [RSS] RDF Site Summary (RSS) 1.0, Gabe Beged-Dov, Dan Brickley, Rael  Dornfest, Ian Davis, Leigh Dodds, Jonathan Eisenzopf, David Galbraith, R.V.  Guha, Ken MacLeod, Eric Miller, Aaron Swartz, Eric van der Vlist,  2000,  http://purl.org/rss/1.0/spec  [UNPARSING] Unparsing RDF/XML, Jeremy J. Carroll, HP Labs Technical Report  HPL-2001-294  http://www.hpl.hp.com/techreports/2001/HPL-2001-294.html  ]]]]  (note URL for tech-report doesn't work yet - could omit last part)    Jeremy        

        Issues:  + legal uses of rdf:Description  + obsoleting rdf-ns-prefix-confusion/test0007        Good news:    I now have a (not yet public) version of ARP that passes nearly all the test  cases from the April publication. This is driven from the Manifest file    Bad news:    the errors ...    The ones it doesn't attempt are:    (Manifest is unhelpful, tests themselves are probably OK)  nested-bag-IDs/test010a  nested-bag-IDs/test011a  nested-bag-IDs/test012a  nested-bag-IDs/test010b  nested-bag-IDs/test011b  nested-bag-IDs/test012b    Should be obsoleted:    rdf-ns-prefix-confusion/test0007    Plain wrong (IMO):  rdfms-rdf-names-use/test-013  rdfms-rdf-names-use/test-026    i.e. test-013 legal    <rdf:RDF   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"    >      <rdf:Description          rdf:about="http://example.org/node1">        <rdf:Description          rdf:resource="http://example.org/node2" />       </rdf:Description>    </rdf:RDF>    test-026 legal    <rdf:Description      rdf:about="http://example.org/node1"      rdf:Description="string" />    These are about rdf:Description being used as a property name.  I see rdf:Description as a syntactic word like rdf:ID or rdf:about, and it  is not and never can be the predicate of a triple. (Not withstanding my  proposal about the RDF Graph!).    Also I did not find the minute approving these test cases; the link from the  Test Cases WD takes us to the action to create them.    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Nov/0651.html    [[[       ACTION 2001-11-30#4 Dave Beckett: Create test cases covering reserved  use of rdf names in this proposal.    ]]]    (Of course I wouldn't raise a procedural question if I hadn't discovered  that I disagreed with the outcome!)    Other Manifest errors (Apr 29) include:   missing test:warning on    unrecognised-xml-attributes/test001  unrecognised-xml-attributes/test002    and possibly on some of the  rdfms-rdf-names-use/test-0XX      ARP is also happy with all the PENDING test cases in the April 29 zip.    I should get ARP running off the web site today, currently I am testing  against the zip; it will fail the charmod-uri tests still since I haven't  sorted that yet.    Jeremy        

          is this list working?        

        Brian dropped by and asked me what the key differences between S and TDL  were.    Here is a list:    ** A single triple:    <bob> <age> "30" .    In S "30" is a string, in TDL it is untyped.    ** Range constraints for this triple.    In S-B the range constraint is something like:    <age> <rdfs:range> <xsd:integer.lex> .    whereas in TDL (using the .map prefix that is not part of TDL) we would  have:    <age> <rdfs:range> <xsd:integer.map> .      ** The role of the map, the lexical space, the value space.    S makes strong distinctions between these.  TDL always uses the map as representing the datatype (and then does not use  the .map extenstion).      ** syntactic stylistic      The local idiom D and the local idiom S-A are different syntaxes, roughly  meaning the same thing. D has better compatibility with DAML.    ** interaction of multiple different lexicalizations with possibly multiply  different types.    S-A is strong    S-B is weak    TDL is in between.    (An example is when we have two integer dataypes one with binary  lexicalization and one with decimal lexicalization).    S-B allows "100" with both types as legal (despite two different values to  the application)    S-A allows "100" as legal and the syntax forces disambiguation of one type  or the other,    S-A also allows compatible lexicalizations [eg:binary "100" ] [ eg:deciaml  "4" ] on the same node.    TDL detects a type conflict and rejects a document trying to give "100"  both types.        Jeremy        

          I will review this once Pat indicates this is the change he is proposing.  I suggest we should also ask for feedback from Horrocks and Patel-Schneider  (OWL Semantics Editor), cc-ing webont.  [Herman does not speak for webont - in particular I note that at the last  webont call he was in a minority on a different semantics issue - nothing  wrong with that of course. It is conceivable that RDF Core might upset  WebOnt by doing what Herman says]    I am happy to raise this informally on webont, as part of my review.      Jeremy    > -----Original Message-----  > From: Brian McBride [mailto:bwm@hplb.hpl.hp.com]  > Sent: 08 January 2004 18:03  > To: Dan Connolly; pat hayes; Herman ter Horst; Eric Miller; Jeremy  > Carroll; Sandro Hawke  > Cc: rdf core  > Subject: revising the semantics PR document  >  >  > It looks like we need to make some minor revisions to the semantics doc.  >     DanC has asked for a WG decision to approve the change.  >  > Eric, Sandro, will a decision at a telecon on 16 Jan 2004 be timely from  > your point of view?  >  > I think what we need is a clear description of the proposed changes for  > review.  Pat, I see a proposal from you at:  >  > http://lists.w3.org/Archives/Public/www-rdf-comments/2004JanMar/th  > read.html  >  > Have you and Herman agreed to this?  I see Graham has reviewed it and is  > happy with it.  >  > If anyone has issues with approving this change, please raise them asap.  >  > Brian  >  >        

        Dated 13th December    http://lists.w3.org/Archives/Public/www-archive/2002Dec/att-0059/01-rc    Jeremy        

          Of the issue resolutions currently in the draft 1.67 I am only uneasy  with:           rdfms-not-id-and-resource-attr                 Action: The grammar has[will be] been modified to forbid the  use of an rdf:ID attribute             when a rdf:resource attribute is also given. This removes an  ambiguity of which             statement is reified but is relatively harmless since the  statement can be precisely reified             using the non-empty version of the property element with an  <rdf:Description> block     I prefer to go other way, to allow an rdf:ID on any propertyElt  production and to uniformly understand it as reifying the triple created  by that propertyElt. (Personally I don't see the ambiguity referred to  in your text).    Is the intent of your text to delete para 232, i.e. we forbid reading  the rdf:ID on some propertyElt's as something other than a reification?    Should your text (the intent) read:        ....          when a rdf:resource attribute is also *possible*. ...      Jeremy        

        [I am doing this offline from memory, I did not succeed in checking it  before sending]    containers test0004 involves the fourth expansion of the property element  production rule 6.12.    By the decision to drop all the special container rules, this expnasion then  applies to rdf:li. By paragraph 232 (which is so horrible its number!) this  fourth expansion is different from the others, in that it does not reify,  but the ID is the ID of the resource.    in my opinion para 232 is an error, and is addressed in the unresolved issue  FFFFFF    I did some archaelogy on this one, and as far as I could tell, this  paragraph dates from the early days before the first working group resolves  issues 4, 7 ,11 and they still had a certain amount of confusion about  referring to a resource and referring to the description of the resource. I  think it is a hard call whether to delete paragraph 232 or preserve it for  the sake of backwards compatibility.    > I guess my implementation will raise a "not supported"  > exception in that case; I don't see sufficient value  > to implement this.    test0005 is also difficult for some parser writers (e.g. me). It is fine if  you really are using an XSLT transform to process rdf:li, but if you're not  you need some fairly horrid special code for processing a corner case that  nobody in their right mind would rely on. ARP does it, but I personally am  very sympathetic to a not supported exception.    Jeremy        

        > Jeremy is suggesting - lets see if we can find a form of words that  > satisfies everyone.  I'm hoping that doesn't mean fudging the issue.    I would expect the WG to reject a form of words that satisfied everyone but  fudged the issue.    I hope *I* would not be satisified with a fudge.    I see the editorial task here as expressing the WG intent in such a way as  to avoid any unnecessary opposition.    I believe this intent is reasonably clear:    a) RDF has meaning that relates to the relate world.  b) This meaning is preserved under formal entailments.  c) This meaning should be socially enforceable in the same way as the  meaning of other languages that relate to the real world (e.g. English).  d) The document section should be normative.  e) The use of a word like "legal" is strongly preferred.    At this stage the only one of those that I think might be appropriate to  fudge is (e) if words like "socially enforceable" can be made to carry more  weight.    It may be beneficial to slightly fudge (b) by suggesting that contracts  underpinning multiparty systems that use RDF might specify which formal  system of entailments is intended (e.g. RDF entailments, RDFS entailments or  OWL entailments); I don't believe the WG ever reached closure on the  interaction between semantic extensions and social meaning.    Jeremy        

        (first sent to webont just as valid for RDFCore)    I have made two comments [2],[3] on this new WD [1] that the WG may wish to  endorse, or follow up on.    The relevant text is:  [[  3.1.2 Desiderata  3.1.2.2 Systematic treatment of fundamental facets (RQ-24)  Make the treatment of fundamental facets more systematic. Define canonical  forms for all types, and specify the rules for generating the canonical  form, given a value. Clarify the status of anySimpleType and define its  value space (if any). Clarify the assignment of types to nodes in the  absence of relevant schema components. Distinguish our identity relation  from the mathematical relation of quantitative equality.  ]]    and    [[  2.5.1 Desiderata  2.5.1.1 First class objects (RQ-23)  Define an algorithm for generating a URI for any construct in a schema (or,  possibly, in a schema document), thus making schema constructs first-class  objects in the Web. Minimally the algorithm should cover element( type)s,  attributes, simple types, complex types, and notations. Optionally it may  also cover other constructs such as named groups and items in enumerations  of legal values.  ]]    [1]  http://www.w3.org/TR/2003/WD-xmlschema-11-req-20030121/    [2]  http://lists.w3.org/Archives/Public/www-xml-schema-comments/2003JanMar/0025.html    [3]  http://lists.w3.org/Archives/Public/www-xml-schema-comments/2003JanMar/0026.html        

          I am clearly being incoherent at the moment ...    The strucute of the argument to do with clowns in the concepts doc, goes   something like:    X says something using Y's terms.  Because you know who Y is, you know what Y's terms mean because Y has told you.  Thus, if Y's meanings are not slanderous, but what X says together with Y's   definitions results in slander, then it is X you should blame.    This relies on the idea that there might be some authoritative definition   somewhere, otherwise we all are just using terms willy-nilly and if what I   say put together with what you say slanders someone else well then nobody's   fault really.    To have an authorative definition relies on an authority. If, like in   freenet, that authority is an anonymous citizen exercising their right to   free uninhibited speech then there may be a need to consider the wording   carefully.    If there really isn't an authority then ...    ?    I'll inline respond as well ...      Frank Manola wrote:    > Jeremy--  >   > Sorry, but you *still* need to explain what the problem is better.  For  > one thing, you need to explain the connection between being responsible  > for defining the meaning of URIs and being responsible for certain  > statements or other things those URIs might refer to.      >    If you are responsible for a URI then what you say about it has a different   extra weight to what anyone else says.      > A URI is a *name*  > for something, not the something itself.  If there's a slanderous  > statement made by a person X, say the statement "Joe is a bozo", person  > Y doesn't become responsible for that statement by giving it a name, say  > "the_Joe_is_a_bozo_statement", and saying, in effect, "that's the name I  > use when I refer to that slanderous statement made by X".  Similarly, I  > can use the name "the Monroe Doctrine" without, I hope, being mistaken  > for Monroe.    >      It is clear that any attempt to tie together rdfms-assumption with web   functionality has some of these sorts of difficulties.    Jeremy        

          I had a suggestion that we should expand the definition of "logically   complete", and perhaps require complete consistency checkers to provide   configurable resource limits. With such a change it would be possible to   add - "For any given input file there must be some settings of the resource   limits for which a complete consistency checker returns either Consistent   or Inconsistent (even if it is after the heat death of the universe)".    I agree with you about the crucial difference between complete and   incomplete reasoners - we have tried to set it up in that fashion.    Is your problem with the copyright statement that you feel uncomfortable   *giving* a contribution to the W3C - I have not given this much thought -   it was basically copied from the RDF Core process. If you can suggest a   copyright statement that would:  1) permit users to copy  2) permit use in the recommendation  3) keep you happy  I would run it past Dan Connolly to see if there were any procedural   problems with using it.  I would be relecutant to have the final document littered with differing   copyright statements - the WD has a copyright statement at the top which   covers each of the tests as well. These in turn have individual copyright   statements. The motive for section B.5 is simply to facilitate quality   control - I automatically check that those exact words are in every file.    We welcome contributions; if you have more than a handful it would make our   lives much easier if you use the OWL Test Case editor; this generates the   Manifest files, makes sure the filenaming conventions are followed etc.   etc. (and adds the copyright statement!)    For details see:  http://lists.w3.org/Archives/Public/www-webont-wg/2003Feb/0267.html    Jim indicated that you want to access only the lite tests ...    The code in Zipper.java in the test case editor should be quite easy to   modify to make a zip which was only the tests you want.    Jeremy    Bijan Parsia wrote:    > Some comments on: http://www.w3.org/TR/owl-test/ as of 17 February 2003.  >   > On the one hand (5.2):  >     """A complete OWL Lite consistency checker or a complete OWL DL   > consistency checker should not return Unknown on the relevant   > consistency or inconsistency tests.""" (non-normative?)  >   > on the other (4.4.2):  >     """Note: Complete OWL DL consistency checkers and Complete OWL Lite   > consistency checkers MAY return Unknown on an OWL DL document or OWL   > Lite document in the case where a resource limit has been exceeded."""   > (normative)  >   > But this permits  the trivial case of returning "Unknown" for every   > input. Take putting a timeout in. Just wait 30 seconds (or hours) and   > then return "Unknown: time limits exceeded".  Or allocate memory until   > you fill it all up and return unknown.  >   > More importantly, the difference between a complete and incomplete   > tableau reasoner (for example) in some cases *isn't* whether they'd run   > out of resources on the same problem on the same machine, but whether   > they in principle will terminate. This requires a proof of termination,   > not a test passing. Though, the obvious, non-pathological differences   > will be catchable with straightforward tests (e.g., by checking examples   > where blocking is critical).  >   > Section B.5 Copyright  >   >     This makes me very reluctant to submit tests, or suggest to (other   > non working group) people that they submit tests, especially without a   > licence condition. But perhaps that's ok :) OTOH, as I develop (and help   > people develop) reasoners, I expect to generate lots of test cases.   > Might be nice if this infrastructure (as it develops) can be shared or   > reused. For example, I've been culling cases from  various papers where   > the expression lacks finite models (to force termination   > challenges)...should I submit them?  >   > Cheers,  > Bijan Parsia.  >         

              Graham Klyne wrote:    >   > At 14:08 28/07/03 +0100, Jeremy Carroll wrote:  >   >   >> Someone (Brian) suggested:  >>  >>  >>>   _:a rdf:label "\u0007" .  >>>  >>>> entails?  >>>  >>>  >>>  _:a rdf:label _:v .  >>>  _:v rdf:type xsd:string .  >>  >>  >>  >> I think not.  >> (IIRC xsd:string is restricted to the characters matching the xml 1.0   >> Char production, and bel is not one of them).  >   >   > Hmmm:  how about:  >   >   _:a rdf:label "\u0007" .  >   > RDFS-entails?  >   >  _:a rdf:label _:v .  >  _:v rdf:type rdfs:Literal .  >       Yes that one is OK.        

        Sorry peter, I had missed this before replying on www-rdf-comments.    I agree with your analysis here, the statement that %-escaping of % is   irrelevant is untrue.    This does not impact my reply on www-rdf-comments.    Jeremy      Peter F. Patel-Schneider wrote:    > From: Jeremy Carroll <jjc@hplb.hpl.hp.com>  > Subject: % in URIs  > Date: Tue, 02 Sep 2003 18:04:15 +0100  >   > [...]  >   >   >>I am not yet convinced that this materially affects RDF since we *never*   >>require the escaping to actually be performed, it is merely a theoretical   >>exercise that defines a set of strings. I believe that the set of strings   >>is the same whether or not % is itself escaped.  >>  >>Jeremy  >>  >   > From reading RFC2396 I believe that this is not the case.  In particular,  > my understanding is that http://foo.bar/oijoi% is not a legal absolute URI  > with optional fragment identifier, nor is http://foo.bar/oijoi%xy  >   > From RDF2396:  >   >    Because the percent "%" character always has the reserved purpose of  >    being the escape indicator, it must be escaped as "%25" in order to be  >    used as data within a URI.  Implementers should be careful not to escape  >    or unescape the same string more than once, since unescaping an already  >    unescaped string might lead to misinterpreting a percent data character  >    as another escaped character, or vice versa in the case of escaping an  >    already escaped string.  >   > There is lots more on escaping in RDF2396.  The RDF escaping mechanism  > ignores most the subtleties involved.    >   > Peter F. Patel-Schneider  >   >         

        >   > As much as convincing DC folks to go back and separate  > creatorName from creator looks like pushing water  > up hill, I prefer that to kludging the RDF core treatment  > of literals.  >     Comments from the DC community?        

          > Suggestion: shall we use 'rdfg:' for "RDF Graph" rather than the more  > cryptic/arbitrary 'rdfx:'?    I'll use a latex macro, and then later, in a flush of ambition, we can  change it to rdf2:!      >  > --  >  >     rdfg:Graph  >        a rdfs:Class ;  >        rdfs:comment "An RDF graph (with intensional semantics)." .  >  >     rdfg:Authority  >        a rdfs:Class ;  >        rdfs:comment "An authority, or origin, of a graph." .  >  > We don't say more about what an rdfg:Authority actually is. We only  > (vaguely)  > define that such a class of entities exist which have a particular role  > with regards to trust.    "For example, a person or company."    >  >     rdfg:Signature  >        a rdfs:Class ;  >        rdfs:comment "A signature used to authenticate a graph." .  >  > Again, we don't say more about exactly what an rdfg:Signature is, only  > that it has a particular purpose in authentication of the statements  > and instances should be suitable for that purpose.    I was thinking more along the lines of a property rdfg:signature, and  possibly rdfg:signatureType (with some well-known values). I was also  thinking of putting references into: my earlier work on Sigs; a related  paper from HP colleagues; DanBri's point about foaf signatures. Maybe these  signaturetypes should be subclasses of rdfg:Signature?  Isn't a signature at the end of the day a byte-sequence, so having a  property  rdfg:signatureBytes with domain rdfg:Signature and range  xsd:hexEncodedByteSequence (I need to look up the correct name).    >  >     rdfg:sameAs  >        a rdf:Property ;  >        rdfs:comment  "The subject and object graphs are equivalent as  > defined by RDF Concepts." ;  >        rdfs:domain rdfg:Graph ;  >        rdfs:range rdfg:Graph .  >  > I think that some localname recognition with OWL would be useful here,  > even  > if the semantics is not identical. But something like rdfg:equivalentTo  > would  > also be OK.  rdfg:equivalentGraph is my pref for this one - it mirrors the OWL names  better.    >  >     rdfg:subsumes  >        a rdf:Property ;  >        rdfs:comment "The object graph is equivalent to a subset of the  > subject graph." ;  >        rdfs:domain rdfg:Graph ;  >        rdfs:range rdfg:Graph ;  >        owl:inverseProperty rdfg:subsumedBy .  >  >     rdfg:subsumedBy  >        a rdf:Property ;  >        rdfs:comment "The subject graph is equivalent to a subset of the  > object graph." ;  >        rdfs:domain rdfg:Graph ;  >        rdfs:range rdfg:Graph ;  >        owl:inverseProperty rdfg:subsumes .  >  > I expanded rdfx:subGraphOf into a pair of inverse properties, allowing  > one to  > relate two perfectly intersecting graphs from either perspective.  >  Save space and delete one - I slightly prefer subGraphOf to subsumes - it is  clearer what one is talking about.    >     rdfg:authority  >        a rdf:Property ;  >        rdfs:comment "The object is the authority, or origin, of the  > subject graph." ;  >        rdfs:domain rdfg:Graph ;  >        rdfs:range rdfg:Authority .  >  > This property simply associates an authority with a particular graph.  > It does  > not assert anything. This can be used to clearly indicate the origin of  > the  > graph without that origin/entity making any actual claims (e.g. the end  > result being akin to quoting, if not otherwise asserted by that  > authority  > elsewhere).    Not yet convinced here.    >  >     rdfg:assertedBy  >        a rdf:Property ;  >        rdfs:subPropertyOf rdfg:authority ;  >        rdfs:comment "The object is the asserting authority of the  > subject graph." ;  >        rdfs:domain rdfg:Graph ;  >        rdfs:range rdfg:Authority .  >  > Note that rdfg:assertedBy is a subproperty of rdfg:authority, so one can  > both associate the authority and explicitly assert with a single  > statement.  > Those who don't care about quoting or the distinction between authority  > and assertion can happily just use this property and ignore  > rdfg:assertion  > and the distinction it provides for...  >    I think we need to go more fine-grain here, more later.  But I agree with you about following rdf-mt in its used of  assert(ion)(al)(ed) etc.      >     rdfg:signature  >        a rdf:Property ;  >        rdfs:comment "The object is the signature to be used to  > authenticate the subject graph." ;  >        rdfs:domain rdfg:Graph ;  >        rdfs:range rdfg:Signature .  >  > Again, we don't mandate what the signature is (there may be multiple  > alternatives  > in use) only provide the means to associate a signature with the  > particular graph.  >    Oh yes that works better ...    > --  >  > The bootstrapping interpretation/test looks specifically for the  > properties rdfg:assertedBy and (optionally) rdfg:signature where the  > subject of those "literal" statements is the same URIref as that  > naming the graph in which they occur.    I think we should avoid mandating a particular bootstrapping phase, more  indicate a possible bootstrapping phase. The bootstrapping is done by an SW  agent, and its policies should be decided by its user rather than  architecturally. I believe we have agreement on that.    >  > Statements using any of the above vocabulary are fully valid and  > compatible with both the RDF and OWL MTs irrespective of the  > special bootstrapping interpretation/test necessary for determination  > of (terminal) assertion and authentication.  >    Yes bootstrapping is not very special.    > Eh?  >  > --  >  > Patrick Stickler  > Nokia, Finland  > patrick.stickler@nokia.com  >  >        

          Given our timescale we should be asking for webont review of our docs  tomorrow (i.e. before our telecon).    Which areas should we be asking for:    One's in my head are:  - datatyping  and  - semantic extensions, particularly the MUST/SHOULD/MAY language which RDF  Pat has used to constrain OWL Pat.    Jeremy        

        Brain:  > > Thanks for calling this out Dave.  I'd like to see a general policy that  > > proposals that change what M&S says, or the common interpretation of what it  > > says, are specifically highlighted.  > >  > > It would be easier to just say, we are not changing the current spec, but we  > > already have precedent, aboutEachPrefix, that we will change something if we  > > feel there are very strong reasons to do so.  > >  > > I haven't seen any such case made for this change.  Dave:  > I've no particular strong reason for making this change, rather than  > just neatness or consistency and as issue owner, I want to get it  > closed.  In this case it seems like even if it was not used much, we  > can keep it around in the syntax without too much trouble - solving  > it with better wording and specification.  >   > Anyone who has a very good reason for a requirement to change this,  > please can you give evidence, as Brian asks.  >       WARNING WARNING JEREMY IS EXPLODING  ... :)      I feel strongly about this.   The 'common interpretation' is not defensible.    The two resolutions Dave proposed are defensible.    here goes ....    [This concerns exclusively the interpretation of rdf:ID on propertyELt  productions].    *strong reasons*    1: The current spec is self contradictory.    2: The 'common interpretation' (by a few members of this WG) of this  differs from any plausible reading of the spec.    3: The current spec or the common interpretation both present  considerable burden to understanding the reification rules in RDF/XML,  and hence fundamentally limit the take-up of the use of reification.    4: The current spec is how it is because of an editorial oversight. This  is an honest-to-goodness error, and should be corrected.    5: There are a number of cases in the mail archives of both novices and  experts being confused by this issue (including DanC, and myself).    6: There is no record of any argument for it being like this. No one,  who has been aware of the contradiction between:    [[[ (Para 232)  r2 is the resource named by the resource attribute if present or a new  resource. If the ID attribute is given it is the identifier of this new  resource.   ]]]    and:    [[[ (Para 214)  The value of the ID attribute, if specified, is the identifier for the  resource that represents the reification of the statement.   ]]]    has ever articulated reasons for para 232, the best is the "backwards  compatibility" argument.    7: Whenever this is discussed in any mailing list no-one actually says  they use para 232; it is only a few parser writer (almost all  represented in the WG) who have any legacy to be backwardly compatible  about.      I will, in follow up messages, expand many of these points.  This is wrong.   It was always a mistake.   It was not the intent of M&S.  It has never been implemented.  There is no legacy.  It is a burden to implementators.  It is a burden to document writers (if any of them wish to use the  facilities provided?)    To remove Para 232 (by not creating text that repeats it) will be a  genuine clarification that comes about as part of our task of  rearticulating M&S.    It will be in keeping with the intent of the previous WG much more so  than the necessary clarification concerning unqualified attributes.    From our charter:  We should make limited    [[[  fixes, clarifications and improvements to the specification of RDF's  abstract model and XML syntax.  ]]]      and    [[[  it is the responsibility of this group to not let near-term deployment  considerations grossly increase the future costs (to implementors,  authors, users, etc.) of new features.  ]]]    Introspective use of metadata requires use of reification, this was a  core issue for the old WG and one they ensured was handled in the  syntax. They had one or two aborted attempts at articulating  reification, and by editorial accident, some text from one of these  (para 232) ended up in the final spec.    As it is, RDF applications to date have made less use of reification  than the original WG hoped for. If we wish to continue that hope then we  should clarify their intent: make reification easy, rather than leave  this horrendous corner case in.    This argues in favour of consistently reading rdf:ID as reification  rather than disallowing it in one case for spurious historical reasons.    Lance the boil.      Jeremy      PS: I am taking some risks in overstating my case - like asserting para  232 has never been used by a document writer in anger. Later, I will  assert that para 229 has never been implemented, I might be wrong, but  it will more fun if I stick my neck out.        

        Dan wrote:    >   > see the W3C charmod spec (and the HTML 4.01 spec,  > and the XLink spec, and a recent IURI internet draft) for official  > specification of this unicode-to-URI stuff.  >      Dan,    the charmod spec is currently a Last Call working draft.    If we want to punt this sort of issue to I18N WG by referring to charmod  is it allowed?    Or do we need to punt to something further along the standardization  process, or can we punt to a future document.    e.g. to the successor of charmod in the W3C track ...      I am thinking particularly about:        rdf:about=URI-reference      and      Unicode Normalization    Also:    will charmod finish soon (before us?).      Jeremy        

          maybe also whitespace in XSD      Jeremy    Dan Brickley wrote:    > I'm working on an agenda for tommorrow, will send it in an hour or so.  >   > Topics to cover include  >   >  I18N/RDF  >  XMLLiteral proposal from jjc  >  Reification vocab proposal from pat  >  Implementation report (ericm)  >  Process - next step? CR/LC2/PR/etc   >   > Anything else? Let me know...  >   >         

      >  > Do we want to reference sections 1-3 of Sergey's document  > at all, if Peter's SWOL specification gives us that machinery?  > (or does it?)  >    Yes keep Sergey's ref. as well as Peter's.    Peter's document is quite terse. The real debt (for me at least) is to a  conversation I had with him at webont f2f (which I guess we don't  reference).    Jeremy        

          Hi Graham,    I've been busy trying to    + address the outstanding editorial issues  + generally tidy our document up.      The results of my labours (so far) are at:    http://sealpc09.cnuce.cnr.it/jeremy/RDF-concepts/20021121/Overview.html    The detailed changelog at the bottom is probably the right place to start.    I might work some more on the clown example ...    Hope you find it an improvement.    I am going to tell Pat of its existence ....    Jeremy        

        I forgot to put a pointer to further limitations of exclusive  canonicalization:    http://www.w3.org/TR/2002/CR-xml-exc-c14n-20020212#sec-Limitations        

          I'll write proposals for both option 2 and option 4 tomorrow morning !    That way we can have the full menu to choose from at the telecon.    Option 4 (langauge tags go for all typed literals) does make it, at least   odd, using RDF with embedded xhtml, which I have always thought of as a   major use case. But Dave's right to point out that it is quite tidy. We   could probably drop the rdf-wrapper all together, since it is only there to   carry the lang-tag. (We would still need to advise pfps and reagle of the   changes to XMLLiteral) We also would need to highlight this to I18N-WG.    Option 2 (no change to XMLLiteral language tags deleted on other typed   literals) - I would be surprised if we did not see that as an improvement   on the current position.      Jeremy                  Dave Beckett wrote:    >>>>Brian McBride said:  >>>>  >>At 13:39 08/05/2003 +0100, Jeremy Carroll wrote:  >>  >>  >>  >>  >>>These are for the Option 1 and Option 3, I will keep those names.  >>>  >>>Both options:  >>>  >>>PROPOSE reopen  >>>  pfps-08 reagle-01 reagle-02  >>>  >>This looks like a larger change than I had realised.  >>  >   > Yes.  >   > For option 1, reverting XML Literals into a 3rd type of literal again.  > We should revert N-Triples to use XML"foo" with no language tag,  > and the typed literals form loses its language tag too  >   > For option 3, if I'm reading it right, the imaginary <rdf-wrapper>  > element now seems to have been made real according to the Option 3 words  > in http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2003May/0016.html   > That would be a mess. N-Triples would remove the language tag from  > the typed literals ie "foo"^^<datatypeuri>  >   >>Can someone clearly state what advantage is gained from this.  >>  >   > I'm not so clear on this :)   What problem are we solving?  >   > If language tags in typed literals (of all types) are a problem,  > then remove them.  This was option 4.  >   > The OWL tests Jeremy pointed out under Option 4 in  >   http://www.w3.org/2002/03owlt/editors-draft/draft/proposed-misc-200-xmlliteral  > are not normative so <shrug/>.   Ruby defines it's own markup elements  > for doing spans of languages.  > (also the answers are not legal N-Triples even with the OWL test  >  cases changes - a mistake I assume).  >   > I don't think RDF M&S ever promised very strongly (or clearly!) that  > xml:lang worked over rdf:parseType="Literal" so we would be  > relatively OK to do this.  The main text on this is:  >   > on parseType="Literal":  >   >   [[The value 'Literal' specifies that the element content is to be  >   treated as an RDF/XML literal; that is, the content must not be  >   interpreted by an RDF processor]]  >   > on xml:lang:  >   >   [[The xml:lang attribute may be used as defined by [XML] to  >   associate a language with the property value. There is no specific  >   data model representation for xml:lang (i.e., it adds no triples to  >   the data model); the language of a literal is considered by RDF to  >   be a part of the literal. An application may ignore language  >   tagging of a string. All RDF applications must specify whether or  >   not language tagging in literals is significant; that is, whether  >   or not language is considered when performing string matching or  >   other processing.  >   ]]  >   >   from http://www.w3.org/TR/REC-rdf-syntax/  >   > Combining those two might give that, but given the loophole that apps  > could ignore it anyway, in the former spec, ...  >   > I need some more information still.  >   > Dave  >         

          <snip />  >  > I'm presuming that this is a requirement on the output of an RDF  > parser, from which the lexical form is actually interned in a given  > system (graph) and not a requirement on a human being who may be  > creating XML literal lexical forms in an RDF/XML serialization  > using a plain text editor.    Correct.    >  > I.e., in the RDF/XML, any well formed XML is acceptable, right?    Correct.    >  > If this is a requirement on the human, then this is not IMO acceptable.  > We cannot require "normal" folks to grok XML canonicalization and  > restrict themselves to only creating XML literals accordingly.    Correct.    >  > It would be good if the syntax spec were clear on this point. It was  > not clear to me, even after several readings.    That's a bug - should be fixed.    I will first try to say why the text is clear and unambiguous, but I am  obviously on weak ground, given that it was not clear for you:      > New text:  > [[  > The string used as the lexical form of the XML Literal  > is the Exclusive XML Canonicalization [XML-XC14N])  > with comments and with empty <a href="  > http://www.w3.org/TR/2002/REC-xml-exc-c14n-20020718/#def-Inclu  > siveNamespaces  > -PrefixList  > ">  > InclusiveNamespaces PrefixList  > </a>  > of the  > literal text l, i.e. the entire element content  > of this property element.  > ]]    The "Exclusive XML Canonicalization" is a process relating the literal text  l to the lexical form whereas "exclusive canonical XML" is a class of text.  You appear to find a misreading in which the lexical form = the literal text  l and both are requried to be exclusive canonical XML.    Dave do you want to make editorial changes to the agreed text, or would you  like me to propose some variations. A very simple one might be to s/E/e/  s/C/c/ and then link "exclusive XML canonicalization" to the right part of  XML-XC14N.    Jeremy        

                  text/html attachment: RDF_Model_Theory.htm          

      I am trying to move RDF Core towards resolving this issue.  I am copying the I18N IG in the hope that someone will check two of the technical details for me. I highlight these as I go with ***.    As usual, this is an HTML e-mail in UTF-8.    Since test cases worked on charmod-literal, I'll try the same on this one.      The first cases show that we do not do % escaping as part of the RDF/XML => RDF graph mapping.  This is by showing that URIs with unicode characters occur in the n-triples.  I think this is also a proposed change to n-triple.    RDF/XML - test001  <rdf:RDF>   <!-- The ?? below is a single character #xE9 in NFC -->   <rdf:Description rdf:about="http://example.org/#Andr%c3%a9">      <eg:owes>2000</eg:owes>   </rdf:Description></rdf:RDF>   ============  N-triple  <http://example.org/#Andr\u00E9> <owes> "2000" . *** #xE9 is the unicode for ???      The next test shows that we are not prohibiting the use of % escaped URIs as matching the uriReference production.      RDF/XML - test002  <rdf:RDF>   <!-- The %C3%A9 below corresponds to ?? under the        %escaping algorithm for URIs.     -->   <rdf:Description rdf:about="http://example.org/#Andr%C3%A9">      <eg:owes>2000</eg:owes>   </rdf:Description></rdf:RDF>   ============  N-triple  <http://example.org/#Andr%C3%A9> <owes> "2000" .    *** %C3%A9 is the % escaped UTF-8 encoded version of ??     Then by non-entailment tests, we show that as far as the RDF model theory goes that the %escaped URI and the non-%escaped URI are different. (just like the model theory sees http://foo and http://foo as different).   Non-entailment test003  Neither test001 entails test002, nor test002 entails test001.  i.e. the URIs are different and can in the RDF Model Theory denote different resources    The next case is an error case, in which the URI is not in NFC.    error001  <rdf:RDF>   <!-- The e?? below is two characters an e followed by           #x301. It should be displayed identically to  ??. -->   <rdf:Description rdf:about="http://example.org/#Andre%cc%81">      <eg:owes>2000</eg:owes>   </rdf:Description></rdf:RDF>    My view is that this is an error mainly because we are not allowing non-NFC strings, and a URI is at some level a string. I think (but I am not sure) that that view is endorsed by charmod. e.g. I think that in the XML    <rdf:Description rdf:about="http://example.org/#Andr%c3%a9">    that the URI is seen by charmod first as a string (an XML attribute value) and then as a URI (matching the uriReference production in RDF/XML). As we have already discussed there seems to be a good consensus around strings being NFC.    I think for this reason that URIs in the RDF graph should be required to be also in NFC. I also think that the I18N issues from an RDF perspective suggest this, because of the risk of confusion and/or fraud, illustrated by this example.    Finally there are no test cases about any of the more advanced issues:    a.. bidi (e.g. mixing arabic or hebrew with english or german)     b.. components starting with combining characters     c.. IRIs as such  my sense is that there is no consensus yet around the more difficult issues to do with IRIs and it is not the place of RDF to be on the bleeding edge here. Really we need to see the IRI internet draft move forward before we can realistically even understand if there are issues to be addressed. The IRI draft appears to be further from consensus than charmod, not least because of incompatibilities between it and movement on internationalized hostnames. charmod has a SHOULD style dependency on IRIs. Given that charmod is not yet at REC I feel that the test cases already covered by this posting adequately address a SHOULD.    I note that there have been recent postings on RDF interest about bidi, and that one of the major users of DAML has increasing interest in  documents in arabic. I believe that not addressing bidi is likely to cause some problems. However, I don't see any choice. As I see it these problems may come up on rdf-interest, and after they do it  will be easier for the next WG to resolve them in RDF2.    We have already clarified that certain URIs are difficult to serialize in RDF/XML. It is conceivable to add to that set those URIs which have components (particular fragement IDs) starting in a combining character, but these are of a different status from the ones we've already listed, and I think the note we agreed about literals actually suffices. We may need to review this if charmod get to rec before us.    Reference.  The best text on URIs in a normative rec appears to be in XLink,  http://www.w3.org/TR/xlink/#link-locators  [[[    The value of the href attribute must be a URI reference as defined in [IETF RFC 2396], or must result in a URI reference after the escaping procedure described below is applied. The procedure is applied when passing the URI reference to a URI resolver.    Some characters are disallowed in URI references, even if they are allowed in XML; the disallowed characters include all non-ASCII characters, plus the excluded characters listed in Section 2.4 of [IETF RFC 2396], except for the number sign (#) and percent sign (%) and the square bracket characters re-allowed in [IETF RFC 2732]. Disallowed characters must be escaped as follows:      1.. Each disallowed character is converted to UTF-8 [IETF RFC 2279] as one or more bytes.      2.. Any bytes corresponding to a disallowed character are escaped with the URI escaping mechanism (that is, converted to %HH, where HH is the hexadecimal notation of the byte value).      3.. The original character is replaced by the resulting character sequence.    Because it is impractical for any application to check that a value is a URI reference, this specification follows the lead of [IETF RFC 2396] in this matter and imposes no such conformance testing requirement on XLink applications.    If the URI reference is relative, its absolute version must be computed by the method of [XML Base] before use.        ]]]    Since we never have to resolve URI refs we could probably get away with a non-normative reference to this section; the last point about xml:base might be worth copying into the syntax spec - we resolve relative refs before we do % escaping, (since we don't do % escaping!)    Jeremy        

          > I took this comment as a rhetorical question meaning, "why bother even   > getting into canonicalization if you have implementation variance?" and   > hence suggesting a fourth option, which you did not consider:  >   > D. Ignore XML canonicalization and treat XML literals as strings, ie the   > L2V mapping is the identity.  >   > Then the entire rdf:XMLliteral datatype machinery is just an elaborate   > way of encoding the old 'XML bit', which I thought was the original   > intent in any case. Introducing XML canonicalization seems to have been   > one those neat ideas that got slipped in without too much discussion and   > has turned out to be a tar-pit. I am particularly concerned that this   > ugly mess is now centrally included in the very core of RDF. I would   > hope that many 'cheap and cheerful' RDF engines wouldn't even want to   > know about XML, still less about XML canonicalization.    This really does not meet the requirements ...    XML parsers really really have variability, when building RDF/XML parsers   we have to work out how to deal with that.    So the simple webont examples where they want a single well-defined   denotation of some literal constructed with an rdf:parseType="Literal"   cannot be addressed simply by saying "use the original string".    In some real contexts there isn't a string to use (e.g. parsing a DOM tree).    We could have put all the work in the parser, and then the semantics could   just use the string - that may be your preference, but it's too late now.  In practice I would expect a webont impl to work that way. However, I also   believe in practice that there will be cheaper parsers for low footprint   environments which don't do this.    Jeremy        

        I think daml:collection parse type is probably a mistake.    1: There is an adequate (not perfect) syntax for collections in rdf, e.g.  <rdf:Bag>. daml:colleciton looks like N.I.H. in the face of this.    2: daml:collection with its lisp/prolog like construction is very biased  towards one groups of implementors at the expense of other types of  implementors.    3: the cons-cell list data model has no semantic justification.    Anyway daml:collection should be defined as a qname not a hard-coded string.    Jeremy      >        

          You did not understand one - due to time pressure I don't replay to   anything else:    pat hayes wrote:  >> Global search for the word labelled - it is always an error.  >   >   > Moving from UK English to US English fried my spelling circuitry, I'm   > afraid. My software (Eudora and Wurd) accepts both versions for   > labelling labeled nodes. But done.  >   >>    No the comment was not spelling - it was substantive. We do not have   labelling (except on arcs) any more.  Thus the word should essentially not appear in the doc.  Most occurrence seem to be simple deletions.    Jeremy        

        Martin:  > Jeremy, I think that the I18N IG has missed the the original  > examples. Could you repost them for us or send us a pointer?    In:  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Mar/0016.html    Pat wrote:  [[[  In the context of xsd:decimal, does   "10,03"-fi equal "10.03"-en ?  ]]]    In:  http://www.coginst.uwf.edu/users/phayes/simpledatatype23-02-2002.html    Pat wrote:  [[[  _:y ex:USdecimal "12.25" .  _:y ex:germandecimal "12,25" .  ]]]    (this example has been one that the RDF Core has looked at a lot).        

      > -----Original Message-----  > From: Dave Beckett [mailto:dave.beckett@bristol.ac.uk]  > Sent: 22 March 2002 10:45  > To: Jeremy Carroll  > Cc: w3c-rdfcore-wg  > Subject: Re: XML Base  >  >  > >>>Jeremy Carroll said:  >  > <snip/>  > > I am arguing a catch 22, if you want to delete these, it is because some  > > people disagree with them, which is why we need them. I am happy with  > > deleting the ones that nobody disagrees with.  > <snip/>  >  > The only one that wasn't approved was test017/error001 and that is  > because I think the algorithm for resolving the URI was wrong in the  > proposed test017.nt  >  > I think resolving  >   base URI "mailto:Jeremy_Carroll@hp.com"  >   with URI "relfile"  > will give  >   URI "mailto:relfile"  > not  >   URI "mailto:/refile"  >  > because mailto is a non-hierachical URI scheme (does not start  > mailto:/ so can be detected by apps).      I agree that test017 is wrong. Your analysis is better than mine was.    However I have reverted back to it being an error. (error001).    The history from my point of view is:    + I suggested it was an error because of non-hierarchical URI  + The wg asked me to reconsider  + I pointed to text in RFC 2396 that supported my position  + DaveB indicated implementation difficulty in distinguishing hierarchical  and non-hierarchical schemes  + I agreed with DaveB and suggested test017 as resolving that  + Graham pointed out that RFC 2396 gives an easy syntactic distinction  between hierarchical and non-hierarchical schemes (is the first : followed  by /?)  + I agreed with Graham and reverted to regarding this case as an error      Meanwhile ...    + DaveB expressed concern that we were doing something that was not our job  + I expressed limited agreement  + TAG discussion has started up about URIs  + Brian suggested deleting the relevant test cases  + I identified the test cases, and mildly opposed deleting them        ====    I think an outcome in which we do not *need* to provide test cases for URI  resolution is the ideal.  At least some of the test cases I posted are unclear, and hence require  clarification.    Brian's proposal may result in the clarity that we need without us stepping  beyond our competence.    Jeremy        

        Apologies for not having self-contained wording for the actions and  decisions.    In the minutes I have rephrased the actions and decisions as below.    Please note that decision 1 has a URL in it which did not appear in the  agenda or transcript but I hallucinated it after the event.    Jeremy    ------------      Actions:  ========    ACTION 2001-10-12#1:  Pat     Review domain and range test cases    ACTION 2001-10-12#2:  Art     Review domain and range test cases    ACTION 2001-10-12#3:  Jos     Change domain and range test cases to use example.org.    ACTION 2001-10-12#4:  Graham      Bring identity of anonymous resourcese back to the table for next week.    ACTION 2001-10-12#5:  Frank M.      Respond to Graham's text, see agenda 2001-10-12, item 12.    ACTION 2001-10-12#6:  Jos    Send interpretation properties URL to e-mail list.    ACTION 2001-10-12#7:  Sergey    Summarise rdfs-xml-schema-datatypes issue for next week's telecon      Decisions:  ==========    Decision 1:    The WG accepted Art's proposal    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Oct/0171.html    Decision 2:    The WG approved the rdfs-no-cycles-in-subClassOf test cases.    Decision 3:     The WG approved the rdfs-no-cycles-in-subPropertyOf test cases.    Other:  ======  There was no support in the teleconference for dropping parseType="Literal".        

          In Pat's impressive document I note the following:    As far as I can tell the following two graphs (which I represent in a  bastardized ntriple) entail one another:    G1:  <a> <b> <c>.      G2:  <a> <b> <c>.  _:x <b> <c>.      Have I understood this right?  If so, is this desired?    I am a little confused at the moment about it ...    reading _:x <b> <c>. as existentially quanitifed then it seems trivial that  G1 and G2 entail one another, whereas the interpolation lemma seems to be  false.    I might follow up on this later.    Jeremy        

            text/html attachment: m.html          

          I am happy with all your suggestions - I will produced updated text for   tomorrow's RDF Core telecon.    I guess the following proposal would cover the process record:    [[  PROPOSE: accept the definition of rdf:XMLLiteral value space from    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2003Jul/0452    and action concepts editors to integrate it in the editors draft, using   editorial discretion.  ]]      The detailed text will be ready by the telecon if people prefer to vote on   that.      Jeremy    Martin Duerst wrote:    >   > Hello Jeremy,  >   > As I already said in another context, this looks like a lot of  > good work and progress. Some more comments below.  >   >   > At 18:05 03/08/13 +0200, Jeremy Carroll wrote:  >   >   >> (Resend - forgot I18N first time)  >>  >>  >>  >> The main planks of Pat's text from  >>  >> http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2003Jul/0452  >>  >> seemed to get support at the RDF Core WG telecon on Friday, I was   >> actioned  >> to move the conversation forward, and ensure that Martin and I18N were   >> in on  >> it.  >> My understanding is that the main goal was to avoid any possibility of  >> confusing XMLLiteral with xsd:hexBinary as in Martin's test case.  >>  >> I also am trying to adequately address Patrick's concerns while changing  >> Pat's text as little as possible.  >>  >> Brian used the term "XML fragment" at the telecon, I am however sticking  >> with Pat's "XML value" because of the existence of  >>  >> http://www.w3.org/TR/xml-fragment  >>  >> which makes Brian's preferred term misleading.  >> I would be happy to consider other words for XML value.  >>  >> For completeness I also include stuff on the lexical space, since   >> there was  >> some concern that the wording is not about Unicde strings ... and the   >> word  >> "corresponding" ...  >>  >> I have numbered the notes for the sake of this e-mail, further discussion  >> below.  >>  >> Patrick - please indicate whether the last two notes (2,3) adequately  >> address your concerns. (3) ended up perhaps more geared towards some of  >> Martin's concerns.  >>  >> I ended up unclear as to whether note 2 was wanted by the WG or not.  >>  >> [[  >> The lexical space  >>   is the set of all strings which:  >>   + are well-balanced, self-contained XML data [XML];  >   >   > I think you can directly refer to production [43] of the  > XML specification (http://www.w3.org/TR/REC-xml#NT-content).  > This allows some stuff like CDATA sections that canonical  > XML will exclude, but otherwise is exactly what you need.  >   >   >>   + correspond  under [UTF-8] encoding to exclusive Canonical  >>     XML (with comments, with empty InclusiveNamespaces  >>     PrefixList ) [XML-XC14N];  >   >   > I think 'when encoded as [UTF-8]' would be slightly easier  > to understand than 'under [UTF-8] encoding'.  >   >   >>   + when embedded between an arbitrary XML start tag and an end tag  >>     correspond to a document conforming to XML Namespaces [XML-NS]  >>  >>  >> The value space is a set of entities, called XML values, which is:  >>   + disjoint from the lexical space  >>   + disjoint from the value space of any XML schema datatype   >> [XML-SCHEMA2]  >>   + disjoint from the set of Unicode character strings [Unicode]  >>   + in 1:1 correspondence with the lexical space.  >>  >>  >>  >> The lexical-to-value mapping  >>    is a one-one mapping from the lexical space onto the value space,  >>    i.e. it is both injective and surjective.  >>  >>  >>  >> Note (1): Not all lexical forms of this datatype are compliant with   >> XML 1.1  >> [XML 1.1]. If compliance with XML 1.1 is desired, then only those that   >> are  >> fully normalized according to XML 1.1 should be used.  >>  >> Note (2): XML values can be thought of as the [XML Infoset] or  >> the [XPath] nodeset corresponding to the lexical form, with an   >> appropriate  >> equality function.  >>  >> Note (3): RDF applications may use additional equivalence relations,   >> such as  >> that which relates an xsd:string with an rdf:XMLLiteral corresponding   >> to a  >> single text node of the same string.  >>  >> ]]  >>  >>  >> I seem to recall concern about putting too much into notes.  >   >   > Some people don't like notes. But they often help understand  > a spec better, and we all have made experiences about how not  > understanding a spec (or understanding it differently) has hurt us.  >   >   >> Either the stuff  >> is sufficiently important to go into the design, or it isn't.  >>  >> This may be sufficient to kill notes (2) and (3). I am reluctant to drop  >> note (1) since the RDF specs have largely followed charmod on NFC   >> which puts  >> us into a somewhat anomolous position between XML 1.0 and XML 1.1 ...  >   >   > I'm confused here. Graham said that RDF allowed control characters,  > but XML 1.1 doesn't, and I showed him that it did. But XML 1.0  > doesn't.  >   >   >> If the notes add clarity then it is probably best to keep them.  >   >   > I think both notes add clarity. From an i18n viewpoint, note (3)  > is definitely helpful. For XML people, note (2) will be helpful,  > although it may be better to change 'can' to 'may', i.e.  > "XML values may be thought of as...". But that's a minor detail.  >   >   > Regards,    Martin.  >         

          OK    I was unaware of that process - I'll try and create that today.    Jeremy    Art Barstow wrote:  >   > On Fri, Sep 14, 2001 at 02:07:10PM +0100, Brian McBride wrote:  > > What is the status on this one folks?  Looks like a good suggestion to me.  > >  > > Brian  > >  > > Jeremy Carroll wrote:  > > >  > > > I am happy with the test case  > > >   http://www.w3.org/2000/10/rdf-tests/rdfcore/amp-in-url/test001.rdf  > > >  > > > but suggest it could be complemented with the attached error case, which is  > > > bad XML.  >   > FYI - based on this note, I submitted a request to the sysadmin  > team to give Jeremy access to the test repository and Jeremy  > should now have the required account and permissions.        

        > > PS. One case which this might not handle well would be where the one  > > string means different things in different languages. Are there any  > > cases like that?  >  > "Chat", in French, is a cat. In English, it is an informal conversation.  >    I like "shopping".    In British English it involves going to the supermarket and getting food; in  italian you go to the posh shops and (at least think about) spend(ing) lots  of money on stylish clothes. They are really very distinct activities.    "shopping"/en-uk = "spesi"/it    I am not really quite sure hopw to say "shopping"/it in English.    Jeremy        

        (Patrick please send a URL for the XML datatyping examples to complete this  draft)  [My apologies for the delay in sending out the minutes. - Jeremy]    Agenda:  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Mar/0070.html  IRC Log: http://ilrt.org/discovery/chatlogs/rdfcore/2002-03-08      Executive Summary  =================    No non-procedural decisions.  Actions    ACTION 2002-03-08#1 bwm Suggest dates 17,18th June by e-mail.    ACTION 2002-03-08#2 frankm Put first Primer WD in front of WG early next  week    ACTION 2002-03-08#3 DaveB Propose an updated ntriple format for literal.    ACTION 2002-03-08#4 jjc Produce XSLT test case which fails to copy  namespace declarations.    ACTION 2002-03-08#5 DaveB review xml:base positive cases    ACTION 2002-03-08#6 jjc Convert xml:base -ve to +ve cases on Monday    ACTION 2002-03-08#7 Jos Review xml:base +ve cases    1: Allocate scribe    Jeremy was scribe, with assistance from Eric and Graham.    2: Roll Call    Regrets: Dan Connolly, Sergey Melnik  Present: Dan Brickley, Brian McBride (chair), Eric Miller, Dave Beckett,  Jeremy Carroll, Ron Daniel, Jos DeRoo, Jan Grant, Graham Klyne, Frank  Manola, Steve Petschulat, Patrick Stickler, Aaron Swartz, Mike Dean    3: Review Agenda    Jeremy wished to invite observer for next week.      4: Next telecon 10am Boston time, 15 Mar 2002      4A: Invite to Mark Butler    Jeremy will invite Mark Butler of HP Labs to observe next week's telecon.  No objections.    5: Review Minutes of 2002-02-22 telecon    See:    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Feb/0656.html    Approved.      6: Review Minutes of 25/26 Feb 2002 Face to Face    See:    http://www.w3.org/2001/sw/RDFCore/20020225-f2f/    An action on Jeremy to review error1 of xml:base as well as error2 and  error3 was omitted.  Minutes approved subject to adding that action.    7: Confirm Status of Completed Actions    ACTION: 2001-11-30#3 Jan Grant  Get access to test case areas of W3C site    ACTION: 2002-01-11#1 bwm  persue CVS access for Jan with EM    see:    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Jan/0255.html    ACTION: 2002-02-15#1 EricM  Find details of phone access during F2F    Approved no objections.    8: June F2F meeting    Location Bristol.    ACTION 2002-03-08#1 bwm Suggest dates 17,18th June by e-mail.    9: Status of Primer WD    http://www.w3.org/2001/09/rdfprimer/rdf-primer-20020308.html    Desire to publish as WD, including editorial comments.    ACTION 2002-03-08#2 frankm Put first Primer WD in front of WG early next  week    10: Clarifying F2F Literals Decision  There are two kinds of literals and each is a pair      See:    http://www.w3.org/2001/sw/RDFCore/20020225-f2f/#d-2002-02-26-1    Patrick noted that in Schema there is one sort of literal, and having two  syntactic forms for literals may be confusing.    ACTION 2002-03-08#3 DaveB Propose an updated ntriple format for literal.      11: Model Theory    Postponed.      12: Datatypes  Action: 2002-02-26#8  PatrickS  Create XML examples for datatypes doc    This action has been completed:    Missing URL    The following text of the agenda was not discussed:  [[[  Issues with the current proposal:      * The lack of XML examples (Patrick Stickler to provide)      * Jeremy's entailment is a problem      * Octal is not an XML Schema datatype      * XML Schema datatypes do not support different language representations    See:    http://www.w3.org/2001/sw/RDFCore/20020225-f2f/#d-2002-02-26-3  ]]]    Brian proposed this issue:    Its too complex; the doublet idiom was not completely removed.    The relevant text is in section 5:  [[[   ex:age rdfs:drange xsd:number  Jimmy ex:age _:x .  _:x rdfs:dlex "35" .  ]]]    No decision was taken, discussion to continue on e-mail.    13: Issue rdfms-xml-literal-namespaces  Action: 2002-02-26#5  jjc  Produce proposal for use of canonicalization for parseType literals  See:    http://www.w3.org/2000/03/rdf-tracking/#rdfms-xml-literal-namespaces    Round-tripping, xsi:type="xsd:decimal", XSLT were discussed.    ACTION 2002-03-08#4 jjc Prod  uce XSLT test case which fails to copy namespace declarations.    15: XML Base Test Cases  Reviewing these needs to be complete  See:    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Feb/att-0516/01-xmlba  se.zip    ACTION 2002-03-08#5 DaveB review xml:base positive cases  ACTION 2002-03-08#6 jjc Convert xml:base -ve to +ve cases on Monday  ACTION 2002-03-08#7 Jos Review xml:base +ve cases    14: IRI's    Are the fraud examples compelling?  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Mar/0027.html    In short discussion curtailed by meeting close the answer was "no".    Meeting closed.        

          >   > For element e and the literal l.  >   > l is an XML Infoset of XML Information items and is not transformed by  > the  mapping  to  the  syntax  data  model. l (rdf:parseType="Literal"  > content) is mapped to an [1]XML literal in the RDF graph.  >   > This  mapping  from  the XML information items in l to the XML literal  > Unicode  string  x is done as follows, or by any method that gives the  > same result:  >   * Use  l  to construct an XPath[XPATH] [2]node-set (a [3]document  >     subset)  >   * Apply   [4]Exclusive  XML  Canonicalization  [XML-XC14N])  with  >     comments  and with empty [5]InclusiveNamespaces PrefixList to this  >     node-set to give a sequence of octets s  >   * This sequence of octets s can be considered to be a UTF-8 encoding  >     of some Unicode string x (sequence of Unicode characteres)  >   * The Unicode string x is used as the lexical form of l  >   > Then  o := typed-literal(literal-value := x, literal-datatype :=  > http://www.w3.org/1999/02/22-rdf-syntax-ns#XMLLiteral    )   and   the  > following statement is added to the graph:  >   > e.parent.subject.string-value <e.URI> o.string-value .  >        Yes that spells it out. I am happy with this.    Jeremy        

        >  > As I understand it, passing a N.E.T. means proving that the entailment  > does not hold in the given logic (DL, Full, Lite).  Calling it  > incomplete at least says it's not a "Fail", and the output link can  > give details about how thorough the search for a decision was (even  > though finding one would have indicated a failure).  Or you can just  > skip them, since you know it'll never pass.    I think there is distinct value in reporting an incomplete here as opposed  to being silent.    The plausibility of the logical correctness of the tests is enhanced by the  number of reasonable thorough systems that do not fail these tests.    Jeremy        

          Sorry, my wife has trumped the WG for 1st Nov (public holiday in Italy).    I was expecting to pick up actions to do with reviewing the docs that are  ready for review, and editorial changes and/or getting concepts passed  pubrules. (I note Graham did the publication action last time; so I guess  it's my turn - not that I would be offended to have less work!).    I will be happy to accept in advance actions that the WG wishes to assign me  (I will be dissapointed if such a blank cheque does not result in abuse!  e.g.  ACTION: jjc Rewrite Abstract Syntax on datatyping to the complete  satisfaction of all WG members, and all other interested parties.    )    Jeremy        

        I believe that we, RDF Core, should post a comment on this.    The issue is that our needs (use of a URI to identify) are  not adequately addressed.    My belief of the industry practice is relfected in XML Namespaces  where no canonicalization of URIs is performed. And namespaces  are identified by the exact spelling of URIs, including spelling  differences which are obviously insignificant according to   RFC 2396.    I think that we should comment that the IRI draft should clarify  and bless such a practice for IRIs.    (This issue is intertwined with comments on charmod, which has  a SHOULD link to this iri spec. In my view, that SHOULD link  has been the most problematic part for RDF Core's use of  charmod.)    Jeremy    > -----Original Message-----  > From: w3c-rdfcore-wg-request@w3.org  > [mailto:w3c-rdfcore-wg-request@w3.org]On Behalf Of Brian McBride  > Sent: 24 April 2002 09:38  > To: RDF Core  > Subject: Fwd: I-D ACTION:draft-duerst-iri-00.txt  >   >   >   > >Resent-Date: Tue, 23 Apr 2002 20:41:22 -0400 (EDT)  > >From: Misha.Wolf@reuters.com  > >Date: Wed, 24 Apr 2002 01:45:06 +0100  > >To: chairs@w3.org  > >X-Mailer: Lotus Notes Release 5.0.2b (Intl) 16 December 1999  > >X-MIMETrack: Serialize by Router on EUNGW2/LON/GB/Reuters(Release 5.0.6a  > >  |January 17, 2001) at 24/04/2002 01:34:44 AM  > >Subject: Fwd: I-D ACTION:draft-duerst-iri-00.txt  > >Resent-From: chairs@w3.org  > >X-Mailing-List: <chairs@w3.org> archive/latest/1904  > >X-Loop: chairs@w3.org  > >Sender: chairs-request@w3.org  > >Resent-Sender: chairs-request@w3.org  > >List-Id: <chairs.w3.org>  > >List-Help: <http://www.w3.org/Mail/>  > >List-Unsubscribe: <mailto:chairs-request@w3.org?subject=unsubscribe>  > >X-MailScanner: Found to be clean  > >  > >The I18N WG has taken on the responsibility for shepherding the  > >Internationalized Resource Identifiers (IRI) specification to IETF/W3C  > >Last Call and beyond, to an IETF Proposed Standard.  The version  > >announced below, draft-duerst-iri-00.txt, is intended to be the last  > >version prior to Last Call and replaces draft-masinter-url-i18n-08.txt.  > >Please send any comments to www-i18n-comments@w3.org.  > >  > >Thanks,  > >Misha Wolf  > >I18N WG Chair  > >  > >  > > > To: IETF-Announce: ;  > > > From: Internet-Drafts@ietf.org  > > > Subject: I-D ACTION:draft-duerst-iri-00.txt  > > > Date: Tue, 23 Apr 2002 07:15:11 -0400  > >  > > > A New Internet-Draft is available from the on-line Internet-Drafts  > > > directories.  > > >  > > >  > > >          Title           : Internationalized Resource Identifiers (IRI)  > > >          Author(s)       : M. Duerst, M. Suignard  > > >          Filename        : draft-duerst-iri-00.txt  > > >          Pages           : 24  > > >          Date            : 19-Apr-02  > > >  > > > This document defines a new protocol element, the Internationalized  > > > Resource Identifier (IRI), as a complement to the URI [RFC2396].  An  > > > IRI is a sequence of characters from the Universal Character Set  > > > [ISO10646].  A mapping from IRIs to URIs is defined, which means that  > > > IRIs can be used instead of URIs where appropriate to identify  > > > resources.  > > >  > > > The approach of defining a new protocol element was chosen, instead  > > > of extending or changing the definition of URIs, to allow a clear  > > > distinction and to avoid incompatibilities with existing software.  > > >  > > > A URL for this Internet-Draft is:  > > > http://www.ietf.org/internet-drafts/draft-duerst-iri-00.txt  > >  > > > Internet-Drafts are also available by anonymous FTP. Login with the   > > username  > > > "anonymous" and a password of your e-mail address. After logging in,  > > > type "cd internet-drafts" and then  > > >          "get draft-duerst-iri-00.txt".  > > >  > > > A list of Internet-Drafts directories can be found in  > > > http://www.ietf.org/shadow.html  > > > or ftp://ftp.ietf.org/ietf/1shadow-sites.txt  > >  > >  > >  > >  > >  > >------------------------------------------------------------- ---  > >         Visit our Internet site at http://www.reuters.com  > >  > >Any views expressed in this message are those of  the  individual  > >sender,  except  where  the sender specifically states them to be  > >the views of Reuters Ltd.  >   >         

          Hi Eric    I took an action to start work on an HP endorsement.    I take this to be for the move to PR (whenever that is).    Do you have some boiler plate that I could take and modify to make a draft   - I think it will take two to three weeks from start to finish, since I   need to get buy-in at various levels.    Jeremy        

      >  > Though I'd very much like your comments to my question in  > my MT commments to Pat, that insofar as the actual denoted  > values are concerned, I wonder if either TDL or S can  > ensure entailment, since RDF is stuck with non-canonical  > lexical forms. C.f. the last comment in  >    My ideal outcome for the datatyping discussion is something like we agree on  TDL or S-P (perhaps with an S-A idiom but S-P semantics) and then Pat works  his model theoretic magic so that the literal strings somehow vanish from  the model theory.    I, never having got passed the apprentice stage, can't weave such wonders.    Jeremy        

          My responses to Brian's issue list.  Note none of my "can't live with" issues made it to the list, I hope Brian  can correct this.    B1: property bloat in S  =======================    I can live with this.  I haven't yet discussed this with my colleague who is going to do the  implementation. If he can't live with it, I will change my position.    B2: multiple lexical representations  ====================================  I like this, I do find it a strength in S.    B3: log:implies  ===============  Since this is DanC's private implementation anything he says about it is  more likely to be correct than anything I say.  I think this is better addressed under B4.    B4: TDL breaks existing code  ============================  False.  If you want complete backward compatibility then under TDL it is possible  - use an empty set of datatypes  - always refer to the literal string not the value part of the pair  representation.    If you want datatyping in existing code then some parts of existing code  break in any proposal.  TDL differs from S in the following sense:  - TDL differentiates between the (untyped) lexicalization and the (typed)  value.  - S-B does not give access to the typed value.  Hence a TDL oriented API will have potentially distinct methods to access  the lexicialization and the typed value. Since old APIs will have one method  to access the string label, any old code will need to be reviewed as to  which is more appropriate.  For migration purposes mapping the old string label method onto the new  lexical form method will suffice, and code will not break.  It is not clear to me how S (particularly idiom B) helps improve existing  (or new) code.    B5: Storage  =============  This is a red herring that has been adequately addressed in my view.  If anyone seriously wants an account of how to do "tidy" TDL storage with  "untidy" access methods I will add that to my queue.  Sergey, do you withdraw this objection?        Jeremy        

      > RDF C14N Max or Min  > ===================  > Should the new RDF specs try to maximally or minimally specify  > the behaviour  > of RDF processors w.r.t. rdf:parseType="Literal"  >  >    An issue that I began to bring up in the message on equality was are we  trying to bless as much as possible the current behaviour of RDF  implementations, or are we trying to specify as tightly as possible  'correct' behaviour (hence breaking all current implementations).    The trade off is that a maximal specification will:  - break all existing systems  - be harder to implement  - provide a better foundation for interoperability    A minimal specification will  - almost bless some existing implementations  - not commit to decisions that we are not yet in a position to know the  answer to.  - provide sufficient interoperability for some test cases and perhaps for  the model theory    I think both cases are fairly difficult to understand, because C14N provides  a barrier.  Whether it is easier or more obscure to push that difficulty into the  equality algorithm I don't think I can judge.    My take on what is a maximal and minimal solution is as follows:                                 Min        Max  Comments                     No         Yes  Excl/Incl                    Excl       either  NamespacePrefixList          No         Yes  SyntaxOrEquality             Equality   Syntax    Although almost any combination of features is plausible.        

      > RDF C14N InclusiveNamespaces  > ============================  > Discussion of this aspect of C14N exclusive.      Under exclusive canonicalization it is possible to specify an  InclusiveNamespace-PrefixList.  http://www.w3.org/TR/xml-exc-c14n#def-InclusiveNamespaces-PrefixList    This lists namespaces that are treated like under inclusive c14n.    If we choose to use exclusive c14n, we can either:  - set this parameter always to null.  or  - provide a syntax for modifying this parameter (e.g. modifying the  attribute value "Literal" of rdf:parseType).  or  - permit applications to set this parameter outside our specs      Of these, I discuss the first two here. The last one is discussed in the  "RDF C14N XML Literal Equality"  message that I will write next.    M&S allows for future groups (e.g. us) to extend the rdf:parseType syntax.  A possible extension is that we could allow the word "Literal" to be  followed by a space separated list of namespace prefixes, e.g. "Literal  xsd".    Hence the example from the earlier message:    <rdf:Description    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"    xmlns:xsd="http://www.w3.org/2001/XMLSchema"    xml:lang="en"    xmlns:eg="http://example.org/">    <eg:bar rdf:parseType="Literal">      <foo xsi:type="xsd:decimal">10.09</foo>    </eg:bar>  </rdf:Description>    Under exclusive C14N with empty InclusiveNamespace-PrefixList the literal  value is:  '\n    <foo xmlns="" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  xsi:type="xsd:decimal">10.09</foo>\n  '    If the author modified the document to:      <rdf:Description    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"    xmlns:xsd="http://www.w3.org/2001/XMLSchema"    xml:lang="en"    xmlns:eg="http://example.org/">    <eg:bar rdf:parseType="Literal xsd">      <foo xsi:type="xsd:decimal">10.09</foo>    </eg:bar>  </rdf:Description>      then the literal value would be (still not getting attribute order right).    '\n    <foo xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema"  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  xsi:type="xsd:decimal">10.09</foo>\n  '      which does not leave the xsd namespace unbound.    Note, that under exclusive C14N there is no other way of forcing the  namespace declaration in the canonical value, other than significant  modification to the XML (e.g. adding a spurious xsd:foo attribute to visibly  use the namespace). In particular, the addition of an explicit namespace  declaration 'xmlns:xsd="http://www.w3.org/2001/XMLSchema"' on the node where  we want it to appear does not impact the XPath nodeset, and does not impact  the canonical value.      Jeremy        

          This is a very nice idea.  Brian can I have two minutes at the telecon to see what we do about it   procedurally.    Jeremy      Peter F. Patel-Schneider wrote:    > From: pat hayes <phayes@ai.uwf.edu>  > Subject: Re: pfps-08 last call comment on typed literals  > Date: Thu, 3 Apr 2003 17:42:12 -0600  >   > [...]  >   >   >>>I think that the best way to go would be to remove rdf:XMLLiteral  >>>entirely.  It is a bastard amalgam of syntax and semantics that provides  >>>far greater pain than benefit.  >>>  >>Yeh, well, the world isn't perfect. Whatareyagonnado?  >>  >   > Complain!  Maybe even object.  >   >   >>>If, however, it is not possible to remove rdf:XMLLiteral, then why not  >>>separate its syntactic and semantic components?  Simply make it be the case  >>>that the processing of rdf:XMLLiteral in the RDF/XML does all the  >>>non-standard stuff in the translation to triples (much like rdf:nodeid  >>>does).  >>>  >>We have done except for the lang tag business.  >>  >   > So finish the job!  :-)  >   >   >>>  So the translation of  >>><subject>  >>>  <predicate parsetype="rdf:XMLLiteral">  >>>    [some text]  >>>  </predicate>  >>></subject>  >>>into a triple would be something like  >>>subject predicate "[some other text]"^^rdf:XMLDocument .  >>>where [some other text] included all the junk involved with rdf:XMLLiteral,  >>>including the language tag stuff.  >>>  >>Jeremy is the one to ask. Jeremy, can we do this?? Note that this   >>would then mean that we could GET RID OF LANG TAGS IN THE GRAPH   >>ALTOGETHER. Just thought I'd mention it in passing.  >>  >>Pat  >>  >>  >>> This would allow rdf:XMLDocument to be a  >>>standard datatype.  You could even use rdf:XMLLiteral instead of  >>>rdf:XMLDocument if you really needed to, but I wouldn't recommend it.  >>>  >>>  >>>> Pat  >>>>  >>>peter  >>>  >   > peter  >         

          See (member only)  http://lists.w3.org/Archives/Member/w3c-archive/2003Apr/0047.html  for the full message.      From: Martin Durst  -----(Edited) Original Message-----  ...    Jeremy:  >  >I wanted to express some urgency on the request concerning IRIs and NFC.    ...  >  >It would be very helpful to RDFCore if we can have a simple yes/no to the  >question "Should RDF restrict its use of IRIs to NFC?", ideally before our  >telecon tomorrow (approx 21 hours from now).      ...    I think making no mention for NFC in IRIs is better, because otherwise  you may get into conflicts with the IRI spec if it is tweaked. (I don't  expect any big changes regarding NFC in IRIs, but tweaks might happen.)    On the question of NFC for RDF overall, as you personally know, we have  backed up a bit from the position that everybody MUST check and reject.  Check and reject for NFC is now just a SHOULD.    What is definitely still true, in all cases, is that 'applications'  (such as RDF) MUST NOT normalize stuff themselves.    Hope this helps,   Martin.        

            For the telecon this afternoon here are the other two proposals.  I will send two further messages, one listing the defects as I see them for  each proposal, the second suggesting a mini-agenda for this issue.  > Option 2:  > Literals can have both a type and a language tag if and only if  > the type is  > rdf:XMLLiteral, otherwise unchanged.      PROPOSE    Concepts is changed to say that a literal can only have both a datatype  and a language tag when the datatype is rdf:XMLLiteral.    Other editors to make consequential changes.      > Option 4:  > Language tag is simply dropped from all typed literals including  > rdf:XMLLiteral  >  >    PROPOSE    Concepts is changed to say that a literal can have either a datatype or a  language tag and not both.    rdf:XMLLiteral datatype is changed to have the identity as its lexical  value mapping (no wrapping), with consequential change to the value space of  rdf:XMLLiteral.    Other editors to make consequential changes.        [Note Option 4, IMO, requires notification of pfps(08) and reagle(01,02)]        

            Dan Connolly wrote:    >>** Failures - could fix:  >>NegativeEntailmentTest xmlsch-02/Manifest.rdf#whitespace-facet-2 - FAIL  >>NegativeEntailmentTest xmlsch-02/Manifest.rdf#whitespace-facet-1 - FAIL  >>  These test non-mutual entailment of a valid literal with an invalid   >>  literal that differs only by whitespace. Unfortunately our XSD   >>  handling library is happy with the whitespace and doesn't   >>  treat " 3 " as an invalid int.   >>  This could be fixed if that is indeed how XSD is supposed to work,  >>  though the current behaviour seems more useful in practice.  >>  >   > Would somebody please turn that into a question of clarification  > for the XML Schema folks?        Hmmm xmlsch-02 was raised by XML Schema folks to check that we had   understood where the whitespace handling happens.    It appears that the Xerces implementors (who Dave defers to) do it   different from in the spec. (Probably more usefully)    >   >   >   >>** Failure - will fix:  >>PositiveEntailmentTest datatypes/Manifest.rdf#language-and-xml-literal - FAIL  >>  This is the xml:lang on xml:Literals issue. To be fixed.  >>  >>** Pass:  >>  > [...]  >   >     Jeremy        

        Dan Connolly wrote:  > pat hayes wrote:  > | <comment> When considering RDFS  we will require interpretations  > | to have extra structure. </comment>  >   > I'd rather not take that approach. I'd rather that the model  > theory were a model theory for all of RDF, no more, and no less.  > I don't want to give the impression that folks should tinker  > with the core model theory when they introduce new vocabulary.  >   > New vocabularies should just be specified as constraints  > on the core interpretation structure, not changes to it.  >   > | in particujlar, the notion of a 'class', so we will need to  > | assume that the universe of  > | interpretations contains classes as elements.  >   > Why? It seems to me that IEXT(rdf:type) completely captures  > the notion of 'class'. Anything we want to say about 'class'  > can be said by way of IEXT(rdf:type), no?  >   > | 5. A subset IC of IR, containing classes  >   > | 6.  A mapping ICEXT  from IC to  the powerset of (IR union LV) ,  > | ie the set of subsets of elements  > | of IR or  XL.  >   > ICEXT(c) is just the set { x: <x,c> \in IEXT(rdf:type) }, no?  > an IC is (at least) the set { y: exists x where <x,y> \in IEXT(rdf:type)  > }  > right?  >   > yup... you say as much later in the document:  >   > | >> <x,y> is in IEXT(I(rdf:type)) iff x is in ICEXT(y)  >   >     I was initially expecting Dan's approach, but I think that it rapidly   would get untidy. Even "the set { x: <x,c> \in IEXT(rdf:type) }" seems   more obscure than Pat's way.    It also seems important to be able to talk about the base graph model  separately from schema performance. I see it as completely legitimate to  have an Ntriple document that does not conform to RDF schema; and it  does conform to something simpler (i.e. the model in the first half of  Pat's document).    I think the two points of view should be joined at a higher level.    Taking Pat's document as defining an RDF M&S interpretation (I,IEXT)   and an RDF Schema interpretation (I, IEXT, ICEXT ) [omitting reification   and containers for now].   I would go for something like:-        "A graph conforms to RDF Schema if every RDF M&S interpretation       of the graph can be extended to an RDF Schema interpretation."      We can then link this in with schema definitions by noting that a graph  g conforms to a specific schema defined by a graph s if g union s  conforms to RDF Schema.    I agree with Sergey that we need to leave a wide open back door. This  back door is used in reification, containers and daml.   It could say that there may be schemas which are not defined by graphs,  but these are expected to define interpretations that extend RDF Schema  interpretations, and a graph conforms to such a schema if every RDF M&S  interpretation of the graph can be extended to such a schema satisfying  interpretation.      Jeremy        

                  text/html attachment: RDF_Datatyping.htm          

          A very minor point:    Pat Hayes wrote:  > It seems to identify 'access' with 'identify', for example where it says  >   > "A URI must be assigned to a resource in order for agents to be able to   > refer to the resource. It follows that a resource should be assigned a   > URI if a third party might reasonably want to link to it, make or refute   > assertions about it, retrieve or cache a representation of it, include   > all or part of it by reference into another representation, annotate it,   > or perform other operations on it."  >     The quoted paragraph is untrue (the word "must").  OWL permits reference to uniquely identified resources without them   having a URI. (through the use of functional and inverse functional   properties)  Suggest a minimal rewording of insert "easily"  i.e.  "A URI must be assigned to a resource in order for agents to be able to    easily refer to the resource. It follows that a resource should be   assigned a  URI if a third party might reasonably want to link to it,   make or refute assertions about it, retrieve or cache a representation   of it, include  all or part of it by reference into another   representation, annotate it, or perform other operations on it."    Although my preference would be to take Pat's comments seriously which   may require greater rewording.        >> Where does it say that all resources have a unique identifier?  >   >   > Sorry about that last one, I phrased it badly. I know the document does   > not say that resources have a unique URI, ie that URIs cannot converge   > in identification; in fact it explicitly denies it. What I should have   > said is that the idea that resources must be identified by an   > unambiguous URI has no rational basis, etc.. As I have explained in   > earlier emails, with examples, it is not necessary to have an identifier   > for something in order to refer to it.    OWL's use of Functional and InverseFunctional Properties is a simple   example of this, I can flesh this out if it is helpful.    Jeremy        

          This is the first of too many messages about the two issues to do with  rdf:parseType="Literal" and XML Canonicalization.    Last week, the RDF Core WG agreed to use XML C14N as the basis for  addressing two of its outstanding issues:  http://www.w3.org/2000/03/rdf-tracking/#rdfms-literal-is-xml-structure  http://www.w3.org/2000/03/rdf-tracking/#rdfms-xml-literal-namespaces      On this basis, I had a worthwhile conversation with John Boyer at the  plenary, and I am now trying to take the issues through to conclusion,  partly on the basis of John's input.    I am cross-posting to both groups, and using RDF as the first words of the  subject line on all messages. I hope this will allow the people who are not  interested in this application of XML Canonicalization to ignore the  relevant threads.    This message will give an overview of the other messages, and an overview of  the choice space.    RDF & XML Literals: Intro  =========================    An introduction to the issue for people unfamiliar with RDF.  Also identifies the problems with the current position as specified by the  RDF Model & Syntax Specification  http://www.w3.org/TR/1999/REC-rdf-syntax-19990222/  Also introduces the issues:  http://www.w3.org/2000/03/rdf-tracking/#rdfms-literal-is-xml-structure  http://www.w3.org/2000/03/rdf-tracking/#rdfms-xml-literal-namespaces    RDF XML Canonicalization Intro  ==============================  Intended for the RDF group, summarising C14N and XML subsets.    RDF C14N Comments  (A)  =================  Discussion of XML comments in C14N, and xml-literals in RDF.    RDF C14N Inclusive or Exclusive (B)  ===============================  Discussion of the differences between the two C14N specs.    RDF C14N InclusiveNamespaces (C)  ============================  Discussion of this aspect of C14N exclusive.    RDF C14N XML Literal Equality (D)  =============================  Should C14N be used to describe the processing of rdf:parseType="Literal" or  only in the definition of XML Literal equality.    RDF C14N Max or Min (E)  ===================  Should the new RDF specs try to maximally or minimally specify the behaviour  of RDF processors w.r.t. rdf:parseType="Literal"    RDF C14N sketch of text  =======================  An idea of what text in our new specs might look like.  This will also indicate my preferred resolution.    RDF C14N proposed resolution  ============================  For consideration by the chair for a forthcoming telecon.      The intent is that the issues labelled (A) - (E) are all binary. (A) - (D)  have only one internal constraint, that the InclusiveNameSpaces are only  significant if we use exclusive canonicalization. Hence (A)-(D) described 12  possible positions, none of which is completely stupid or incoherent.    (E) is intended as a binary choice at a higher level, that, if we can decide  on that, will help us to make a philosophically consistent cut through  issues (A), (B) & (D).    That is, I see a choice space with 12 options. Deciding on (E) first will  mark two or three of these twelve options as preferred, and hence make the  subsequent choices easier.    I will try and write these messages today, but some might hand over until  tomorrow.    Jeremy        

            > -----Original Message-----  > From: Jos De_Roo [mailto:jos.deroo.jd@belgium.agfa.com]  > Sent: 12 September 2002 16:24  > To: Jeremy Carroll  > Cc: ext Brian McBride; Patrick Stickler; RDF Core  > Subject: RE: Proposal for abstract syntax representation of inline  > literals (was Re: weekly call for agenda items)  >   >   > [...]  >   > > I suggest an abstract syntax along the lines of:  > >  > > An RDF Literal Node can be labelled with one of:  > >  > > - an RDF String Literal (as now)  > > - an RDF XML Literal  (as now)  > > - a value from the value space of a datatype.  >   > so they are selfdenoting (as now)    What any literal denotes is a question for Pat not for me!    (or at least is not on-topic in this thread)    Jeremy        

            Patrick.Stickler@nokia.com wrote:    >   >>10: Denotation of rdf:XMLLiteral  >>[[  >>PROPOSE: accept the definition of rdf:XMLLiteral value   >>space from  >>  >>http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2003Jul/0452  >>  >>and action concepts editors to integrate it in the   >>editors draft, using   >>editorial discretion.  >>]]  >>  >   > I don't understand this proposal, since the WG has already  > discussed the definition in   >   > http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2003Jul/0452  >   > during last telecon, identified problems with it, and tasked  > Jeremy to write up a revised version.  >   > The issues identified during the last telecon are not IMO editorial  > issues.  >       Sorry - we seem to be at cross-purposes - are you happy with:  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2003Aug/0185    which is a minor edit of    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2003Aug/0153    about which you said:  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2003Aug/0160    "I'm satisfied with this definition."      If that's OK let's change to that message being the one quoted in the   proposal. I don't think we should get into an argument about how big a   difference is editorial!    vis -    [[  PROPOSE: accept the definition of rdf:XMLLiteral from    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2003Aug/0185    and action concepts editors to integrate it in the           editors draft, using  editorial discretion.  ]]    Obviously, if you at any stage think I have overreached editorial   discretion then I would welcome correction.    Jeremy        

        I don't believe we do have.    I am happy to prepare a few; and would try to avoid over-stretching any  XC14N issues.    Jeremy    > -----Original Message-----  > From: w3c-rdfcore-wg-request@w3.org  > [mailto:w3c-rdfcore-wg-request@w3.org]On Behalf Of Brian McBride  > Sent: 21 March 2002 21:43  > To: RDF Core  > Subject: test cases for Issue rdfms-xml-literal-namespaces  >  >  > Do we have any test cases for this issue.  Surely I wasn't so dumb as to  > close it without test cases.   I think I was :(  >  > Brian  >  >        

          I have two comments on section 6.3 of    http://gbiv.com/protocols/uri/rev-2002/draft-fielding-uri-rfc2396bis-03.html  #canonical-form    1) suggest add the following additional rule:    + For URIs following the generic syntax produce an abs_path of "/" in  preference to omitting the abs_path   (this might need an additional example earlier in the doc  http://example.com  vs http://example.com/ )      2) may it be helpful to explicitly extend the rule:    "Only perform percent-escaping where it is essential. "    to considerations where the URI is being transported in a way that  anticipates IRIs e.g. XML system identifiers - and to discourage %-escaping  of non-ASCII chars in such circumstances.    (I note that XML Namespaces 1.1 is explicit about this:    "Because of the risk of confusion between IRIs that would be equivalent if  derefenced, the use of %-escaped characters in namespace names is strongly  discouraged."    http://www.w3.org/TR/2003/PR-xml-names11-20031105/    )    Jeremy        

          In the April 2002 draft    The model theory had if-then intensional semantics on subClassOf  subPropertyOf, whereas various entailment rules depended on the  missing -only-if (rdfs5, rdfs7 and rdfs8)  http://www.w3.org/TR/2002/WD-rdf-mt-20020429/    While there was some discussion of domain and range before summer 2002, the  next step was:      http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Sep/0169    [[  Recent attempts (in collaboration with Peter and Ian) to reconcile  the RDF(S) MT with the emerging OWL MT have suggested that it would  be good to make a technical alteration to the semantic conditions for  RDFS.  ]]  [[  (To emphasize, this change makes the MT *more* conventional  rather than less, ie this is the standard way to do it)  ]]      Graham seem to win the day with this comment:    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Sep/0296  [[  Returning to Pat's proposed change [1], I think I can see that the IFF is  appropriate for rdfs:subClassOf and rdfs:subPropertyOf, because they are  directly related to expectations of class membership.  I'm not so convinced  the same considerations apply to rdfs:range and rdfs:domain.  ]]      We finally got to discuss it at the October 25 telecon  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Oct/0386.html    and the crucial comment seemed to be connolly:  [[  waiting for decisions? the WG is *not* in the critical path  any more; there are no pending issues.  the WG has no open issues and proposes editors just proceed  ]]      and Pat then implemented Graham's position.    Jeremy        

          Peter has made a comment  http://lists.w3.org/Archives/Public/www-rdf-comments/2003OctDec/0123.html    [[  I do suggest, however, that there be some indication in RDF Concepts that  applications that wish to generate RDF URI references that contain non  US-ASCII characters not escape these characters.  See Section 6 of  http://www.textuality.com/tag/uri-comp-4 for a similar indication.  (This  text may have been incorporated into RFC2396bis.)  ]]    I suggest adding another note, as in the following proposed reply.    ===============    Hi Peter,    I am happy to add yet another note at the end of section 6.4 RDF URI  References    http://www.w3.org/TR/2003/WD-rdf-concepts-20031010/#section-Graph-URIref    reading    [[  Note: Two different RDF URI references, one of which uses %-escape sequences  may  encode to the same URI reference. These are not equal. To minimize the risk  of this,  when generating RDF URI references it is prefered to avoid using the  %-escape form.  ]]        

        Natasha Noy wrote:    >   >   > People seem to have agreed that doing a pattern on n-ary (reified)    > relations would be a useful thing to have. Alan Rector and I actually    > had a chance to work it out and you can see the first draft  of our    > effort at  > http://lists.w3.org/Archives/Public/www-archive/2004May/att-0003/n-   > aryRelations.html  >   > It's nowhere near as complicated or as controversial (we hope) as the    > Classes as Values one. In fact, it's rather simple, almost too simple    > to be a pattern.     Simple design patterns are better than complicated ones. I think this   looks useful.    > On the other hand, it seems to be on a topic that many    > newcomers to OWL have questions on.  >   > As usual, please feel free to poke holes in it and all feedback is    > welcome.  >     Two comments:    1) I think it would be worth showing this design pattern also just with   RDFS, and hence broadening the scope of this note to  [[  In OWL *and RDF*, a property is a binary relation: it links two   individuals or an individual and a value. How do we represent relations   among more than two individuals?  ]]  (basically this would use global range and domain constraints to achieve   some of the effect)    2) I winced somewhat at the use of the words "reify" and "reified"  RDF reification is, to me at least, a bit of a mess, and use of these   words will make the RDF literate reader think of RDF reification. I   realise that the use in this note is appropriate, and in some ways not   actually different from RDF reification of statements. However, I think   there is potential for confusion "What has all this got to do with   reification?" - for me the best fix would be to use a different term in   this note.    > Thanks in advance,  >   > Natasha and Alan  >     Jeremy        

        Here's the problem text:    [[  A D-interpretation which also satisfies the following condition is called   an interpretation which is datatyped with respect to D:    if I(aaa) is in ICEXT(I(rdfs:Datatype)) then <aaa, I(aaa)> is in D    This condition recognizes membership in the class rdfs:Datatype as a   sufficient condition for being a datatype, providing a simple form of   'declaration' for a datatype in RDFS. Thus, a graph which entails a triple   of the form    <ex:somedatatype> rdf:type rdfs:Datatype .    can be understood as asserting that "ex:somedatatype" denotes a datatype   which is mapped from this URIref by the datatype map of any satisfying   interpretation. Such an assertion does not in itself provide the   information necessary to check that a graph actually satisfies the other   semantic conditions, however. We will say that such a datatype URIref is   recognized by the graph. The semantic conditions for rdfs-interpretations   require the built-in datatype URIref 'rdf:XMLLiteral' to be recognized.  ]]    I suspect occams razor can be applied liberally.      Here is the entailment proof:    xsd:int rdf:type rdf:Datatype .    is true in no { <rdf:XMLLiteral, XMLLiteral> } interpretations    thus    by reduction ad absurdum    xsd:int rdf:type rdf:Datatype .  { <rdf:XMLLiteral, XMLLiteral> }-entails  nonsense nonsense nonsense .    Jeremy      Brian McBride wrote:    > At 11:10 16/05/2003 +0100, Graham Klyne wrote:  >   >> Hmm, yes, it seems problematic.  >   >   > Can someone decode the cryptic problem statement and show where the dumb   > entailment comes from.  I haven't spotted it yet, but looking through   > the semantics spec I noticed:  >   >   > rdfD 4  >   >   ddd rdf:type rdfs:Datatype .  >   eee rdf:type rdfs:Datatype .  > entails  >   ddd rdfs:subClassOf eee .  >   > Seems to me that implies that the values spaces of xsd:string and   > xsd:decimal are identical.  >   > I presume I'm missing something.  >   > Brian  >   >>  In particular, it seems to violate:  >>  >> [[  >> General monotonicity lemma. Suppose that S, S' are sets of RDF graphs   >> with every member of S a subset of some member of S'. Suppose that Y   >> indicates a semantic extension of  X, S X-entails E, and S and E   >> satisfy any syntactic restrictions of Y. Then S' Y-entails E.  >>  >> In particular, if D' is a datatype map and D a subset of D' then if S   >> D-entails E it also S D'-entails E, provided that S and E both   >> recognize all the datatype urirefs in the domain of D'.  >> ]]  >> -- http://www.w3.org/2001/sw/RDFCore/TR/WD-rdf-mt-20030117/#dtype_interp  >>  >> There is also some wording nearby about entailments of inconsistent  >>  >> Imposing a syntactic constraint on a D-interpretation allowing  >>   x rdf:type rdfs:Datatype .  >> only if I(x) in D might help, since that would render the antcedent of   >> Peter's  first entailment syntactically invalid.  >>  >> [[  >> 1/      xsd:int rdf:type rdfs:Datatype .  >>                 {<rdf:XMLLiteral,XMLLiteral>}-entails  >>         rdf:XMLLiteral xsd:string rdf:type .  >>  >> 2/      xsd:int rdf:type rdfs:Datatype .  >>                 DOES NOT {<rdf:XMLLiteral,XMLLiteral>,  >>                 <rdf:int,int>}-entail  >>         xsd:string rdf:XMLLiteral rdf:type .  >> ]]  >> -- http://lists.w3.org/Archives/Public/www-webont-wg/2003May/0276.html  >>  >>  >> But there's still a question of such statements in non datatyped   >> interpretations.  I think that's not a problem because there's no   >> constraint there that:  >>   x rdf:type rdfs:Datatype .  >> is false in all such interpretations, so the first entailment would   >> not hold.  >>  >> #g  >> --   >>  >> At 11:19 16/05/03 +0300, Jeremy Carroll wrote:  >>  >>  >>> On another list, it has been claimed that the current RDF MT editors   >>> draft has  >>> non-monotonic datatyping.  >>> If this is the case then it should be fixed.  >>>  >>> I will try and review this claim before the telecon today, I suggest   >>> others  >>> might like to as well.  >>>  >>> The claim is that when foo is not a supported datatype then  >>>  >>> foo rdf:type rdfs:Datatype .  >>>  >>> is inconsistent, and hence entails everything.  >>>  >>> Thus, supporting an additional datatype foo, negates previously valid  >>> entailments, and hence causes a datatyped system to layer   >>> non-monotonically  >>> on top of a datatyped system.  >>>  >>> I personally find this a credible critique that should be taken   >>> seriously.  >>> We may need to leave open any semantics issues affected :(  >>>  >>> The (cryptic) examples given in  >>> http://lists.w3.org/Archives/Public/www-webont-wg/2003May/0276.html  >>>  >>> concern the minimal datatype system consisting of only   >>> rdf:XMLLiteral, and so  >>> xsd:int plays the role of foo above.  >>>  >>> I note that this comment is based on the shadow space draft rather   >>> than Pat's  >>> master copy - we may hope that magic has happened.  >>>  >>> Jeremy  >>  >>  >> -------------------  >> Graham Klyne  >> <GK@NineByNine.org>  >> PGP: 0FAA 69FF C083 000B A2E9  A131 01B9 1C7A DBCA CB5E  >   >         

      DanC:  > These proposals are sufficiently long and complex that I'm  > pretty sure it would be more straightforward to code  > first and describe the code after the fact.      I think it is clear that I am going to need to break this up into smaller  chunks.    The vast majority is intended as just an (optimistic) description of current  practice, and clarification of M&S.    An example of what I mean "optimistic" is the lang tag thing. In M&S  language tags are part of the literal, in RFC1766 and RFC3066 lang-tag  comparison is case insensitive. That doesn't mean that those few RDF  implementations that support lang tags actually do the comparison case  insensitively. But I think the implementators would accept that they had  made a mistake.    The unicode normalization stuff is an exception to that "description of  current practice", except that charmod which inspires it has been  deliberately written so that code that is designed to work with the US-ASCII  subset of Unicode is OK.    The other exception to "current practice" is canonicalization as the  preferred treatment of rdf:parseType="Literal". There the description of the  code (use XML Canonicalization) is much more straightforward than the code  itself, and it is helpful to have a statement of strong interest from the WG  before coding it.    Jeremy        

        Draft:   - for www-rdf-interest         www-webont-wg         uri         w3c-i18n-ig         xml-names-editor@w3.org    The RDF Core WG has decided [1] that the URI ref labels used in an RDF graph are in Unicode rather than US-ASCII.  These are seen as "original character sequences" in the terminology of RFC 2396 (see [10]).     This is motivated by the clarity in XML Erratum 26 [2] (and equally in XLink section 5.4) that the %-escaping algorithm that is used for mapping international characters into US-ASCII is "performed only when absolutely necessary and as late as possible in a processing chain".     In the terms of the text from xlink [3] the labels on the RDF graph  "must be a URI reference as defined in [IETF RFC 2396], or must result in a URI reference after the escaping procedure [...] is applied."    Moreover, the WG decided, guided by charmod [4] that such labels should conform with Unicode Normal Form C.    For those unfamiliar with the RDF graph but familiar with XML Namespaces, the analogous decision would be that the identifier of an XML Namespaces "must be a URI reference as defined in [IETF RFC 2396], or must result in a URI reference after the escaping procedure [...] is applied." and that the escaping procedure is *not* applied before considering whether two such identiers are identical.    The decision was with dissent, and RDF Core WG welcomes feedback both positive and negative to www-rdf-comments@w3.org. We expect to review this decision in the light of the feedback.    We note that the current WD of Namespaces in XML 1.1 [5] does *not* follow the text from xlink or erratum 26, and would particularly value feedback from both the XML Names editors and I18N IG on this issue.    The test cases agreed to represent this issue are found in [6], and [7]    Detailed rationale:  - the normative dependency of M&S on XML Erratum 26, see  [8]  - the possibility of URI fraud with non NFC international URIs see [9]  - a test case that is unclear under M&S.  - an XML Namespace test case that is similar.    See appendix below.      An alternative would be specifying %-escaping before forming the graph. This is in line with common practice in the RDF community.  The test case below indicates that clarity would require specifying the case of % escaping. So that clarification  would involve adding to the well-known % escaping algorithm of RFC 2396.  Within the RDF/XML serialization the URI fraud issue would be addressed by requiring the XML to be fully normalized.   This would not address the security issue in non-XML uses of RDF, in which any reverse %-encoding (necessary for legibility in I18N environments) may introduce the problematic cases.          Jeremy Carroll  HP Rep on RDF Core  Issue owner      References    [1]  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Apr/0474.html  [2]  http://www.w3.org/XML/xml-V10-2e-errata#E26  [3]  http://www.w3.org/TR/2001/REC-xlink-20010627/#link-locators  [4]  http://www.w3.org/TR/2002/WD-charmod-20020430   [5]  http://www.w3.org/TR/2002/WD-xml-names11-20020403/  [6]  http://www.w3.org/2000/10/rdf-tests/rdfcore/rdf-charmod-uris  [7]  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Apr/0116.html  [8]  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Mar/0012.html  [9]  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Mar/0027.html  [10]  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002May/0008.html      More test cases    RDF/XML    <rdf:RDF      xmlns:eg="http://example.org/#">    <eg:Andr?? rdf:about="http://example.org/#x">      <eg:foo rdf:resource="http://example.org/#Andr%c3%a9"/>      <eg:bar rdf:resource="http://example.org/#Andr%C3%A9"/>    </eg:Andr??>  </rdf:RDF>    Is the label on the typed node the same as the label on the <eg:foo> object or the <eg:bar> object,  (or are they the same).      XML Names    <eg xmlns:a="http://example.org/#Andr%c3%a9"      xmlns:b="http://example.org/#Andr%C3%A9"     xmlns:c="http://example.org/#Andr%c3%a9     a:a="a" b:a="b" c:a="a" />    If this is not well formed, why? (under the current spec and the latest WD because ?? is not US ASCII?)   What about the three other cases formed by deleting one of the last three attributes.        

        While having some sympathy with Patrick here, I note that a new scheme that   is URIs not URLs neatly sidesteps the car/document problems.    An info URI identifies a concept not a document about that concept.  A similar http URL would be taken as identifying either or both depending   on who you talk to.      Jeremy    Hammond, Tony (ELSLON) wrote:    >>Why define and manage the URI space outside the scope of the core Web  >>and SW machinery?  >>  >   >   > Hi Patrick:  >   > I have to query the question you put above. IMO the "info" URI scheme fits  > full square within the core Web and SW machinery as articulated in the  > latest Web Architecture Draft:  >   > Architecture of the World Wide Web  > W3C Working Draft 27 June 2003  >   > http://www.w3.org/TR/webarch/  >   > The domain of URI is more extensive than HTTP alone. I would assert that the  > actual domain of URI is the Web.        

          I need to go and recover my bicycle from the bicycle pound where it was  taken after I had parked it "irregularly". Unfortunately, they open one hour  before the telecon, and I am not convinced I will get back in time.    Jeremy        

        >  > Does  >  >    <a> <b> "foo"@"lang1"^^dtype .  > entail  >    <a> <b> "foo"@"lang2"^^dtype .  >  > for all dtype except the two built in ones for M&S style literals?    answer: no.  (on the current doc)    It would be easy to make the small step back to say    answer: yes    for when the entail is dtype aware.    If we wanted to keep the elegance of everything is typed, and answer no for  rdf-entailment (with no knowledge of dtype) I suspect we are making life a  touch more difficult for Pat, and the two built in datatypes would need to  get special treatment in the MT. I doubt it would be too difficult.    Jeremy        

            Jeremy Carroll wrote:    > Here's the problem text:  >   > [[  > A D-interpretation which also satisfies the following condition is   > called an interpretation which is datatyped with respect to D:  >   > if I(aaa) is in ICEXT(I(rdfs:Datatype)) then <aaa, I(aaa)> is in D  >   > This condition recognizes membership in the class rdfs:Datatype as a   > sufficient condition for being a datatype,         Suggest:    s/sufficient/necessary/ and consequential changes    would do.    Jeremy        

        ewallace@cme.nist.gov wrote:    > "Uschold, Michael F" <michael.f.uschold@boeing.com> wrote:  >   >>On document length...  >>  >>To the extent that we have spen the time producing useful content, I think   >>it would be a shame to cut it out just to keep documents short. Perhaps   >>better is to structure the documents so that there is a good exec summary,   >>and for those that wish to dig deeper, extra details may be provided.  Much   >>easier in a Web document, but possible for flat documents too, with extra   >>work. There could two or even three levels of depth for those who really   >>want the gory details. Much more work to produce - a question of balance   >>and priorities and what authors feel inspired to do.  >   >   > I agree with this.  Don't delete information, just make it easier to find.  > A standard structure for these notes would certainly help with this.  >   > -Evan  >     Length limits often are a good discipline for being concise and getting   to the point. (I am not sufficiently informed to have an opinion on the   specific note in question)    Jeremy        

        Aaron: please read this message.    Jan:  > Please go ahead.    I have added:    test016.rdf  test016.nt  test017.rdf  test017.nt    in    http://www.w3.org/2000/10/rdf-tests/rdfcore/rdfms-empty-property-elements/    I have added:    test3.rdf  test3.nt    in    http://www.w3.org/2000/10/rdf-tests/rdfcore/rdfms-difference-between-ID-and-  about/    I have modifed the Manifest.rdf file in both of these directories (was that  the right thing to do). They include the new tests. I also added a  test:issue and a test:description to the PENDING test2.rdf in  rdfms-difference-between-ID-and-about.    I also modified test2.rdf and test2.nt in  rdfms-difference-between-ID-and-about to conform with the WG decisions on  non-Ascii characters in URIs.    I have modified the file Overview.html in  rdfms-difference-between-ID-and-about since I have just noticed that it does  not give access to the new tests when navigating by directory. I also  deleted the heading "Resolution" in this file, since it is misleading; the  actual resolution appears to be: "The new syntax WD resolves this issue."  see  http://lists.w3.org/Archives/Public/www-rdf-comments/2001OctDec/0385.html    Jeremy        

          Points:    1: There should be three miscellaneous tests    rdfms-nested-bagIDs/test010 thru 12    not six parser tests.    Every parser will fail one of 10=>10a or 10=>10b.    2: has this one been approved?    http://www.w3.org/2000/10/rdf-tests/rdfcore/rdfms-uri-substructure/error001  .nt    It's another miscellaneous one.        I am happy with publication, with or without changes addressing the above  points, and with or without changes addressing the IRI issue.    Jeremy        

            Dave Beckett wrote:      > You don't need to write in the third person ("the editor").    I thought that was a preference from the style police ... problems with translating first and second person phrases?        Jeremy        

            Looking at them, I am not much interested in these, (oh I haven't seen the graph  data model yet).    However I note their test 75:    http://www.w3.org/TR/2002/WD-soap12-testcollection-20020626#T75    This has a relative URI being resolved against xml:base, we could ask what the  correct behaviour is if we replace the relative URI with a same document  reference ...    e.g.  <?xml version='1.0' ?>  <env:Envelope xmlns:env="http://www.w3.org/2002/06/soap-envelope">   <env:Header>    <test:echoResolvedRef xmlns:test="http://example.org/ts-tests"          env:role="http://www.w3.org/2002/06/soap-envelope/role/next"          env:mustUnderstand="1">      <test:RelativeReference xml:base="http://example.org/today.xml"            xlink:href="#frag"            xmlns:xlink="http://www.w3.org/1999/xlink" />    </test:echoResolvedRef>   </env:Header>   <env:Body>   </env:Body>  </env:Envelope>    I would guess ...    <?xml version='1.0' ?>  <env:Envelope xmlns:env="http://www.w3.org/2002/06/soap-envelope">   <env:Header>    <test:responseResolvedRef xmlns:test="http://example.org/ts-tests">      http://example.org/today.xml#frag    </test:resonseResolvedRef>   </env:Header>   <env:Body>   </env:Body>  </env:Envelope>        (Wickedly)    Jeremy        

          Looking at the latest editors draft.    Jeremy:    >>  >> That version suffers the following defects vis-a-vis simple completeness  >>  >> <eg:a> <eg:b> <eg:a> .  >>  >> entails  >>  >> _:a <eg:b> _:b .  >>  >> but this cannot be shown.  >>  >> Similarly  >>  >> _:a <eg:b> _:a .  >>  >> entails  >>  >> _:a <eg:b> _:b .  >>  >>  >> but this cannot be shown.      Pat:    >   >   > Right, it doesnt claim to be complete for simple entailment, only a   > complete rendering down of vocabulary entailment to simple entailment.   > To check simple entailment you have to refer to the relevant section and   > it tells you to use the interpolation lemma.  >       Why do you prefer the wording in the editors draft over the wording in    >>  >> However your wording in msg  >>  >> http://lists.w3.org/Archives/Public/www-rdf-comments/2003AprJun/0202  >>  >> is, I believe, satisfactory.  >>          Although I agree your statements of the RDF RDFS entailment lemmas is   robust against this issue.      Jeremy        

          I think I agree with Patrick on this one.    The last call WDs show a URI denoting a datatype but not part of the  datatype denoted.    This appears to be in conformance with XSD.    In the absence of a compelling example showing how that is broken, we should  not change it.    Jeremy        

          I note there were no actions or decisions on the xmlsch-02 issue - is that a  mistake?    Anyone want to draft a note for inclusion in concepts about this?    >  > AOB: xmlsch-02  >  >   In general, implementors are doing something other than the specs  >   dictate wrt whitespace treatment of XSD literals: partly due to  >   the behaviour of supporting XML libraries.  >  >   jjc felt that wording that gave implementations room to do WS  >   processing ("be liberal in what you accept...") was appropriate.  >        

        Latest editors draft            application/pdf attachment: tr.pdf          

        I feel Patrick has raised some legimate issues here.    Principally, I understand his message as a vote in the "cannot live with"  category against S; with a coherent explanantion of why: backward  compatibility.    An additional aspect that has come up on WOW is that S is not consistent  with standard XML usage in which strings are implicitly type converted as  necessary e.g.    <record>    <name>Fred</name>    <age>40</age>  </record>    I, too, feel much more confortable with P, with some additional typing  mechanism, such as that suggested by Patrick.    > I.e.:  >  >      SUBJ PRED _:OBJ .  >      _:OBJ rdf:value "LIT" .  >      _:OBJ rdf:type TYPE .  >  > and/or  >  >      SUBJ PRED "LIT" .  >      PRED rdfs:range TYPE .    I am increasingly concerned about how many changes we feel entitled to make  under our charter. I agree with Patrick that S is explicitly out of scope  according to our current charter. I am concerned that the chair is taking an  increasingly broad view of what changes we may make.    However, I have not strongly objected to S, and continue to not do so, on  the understanding  that we were explicitly permitting our datatyping  discussions to go out of charter. i.e. I believe our intent was to make the  *right* decision on datatyping, and then, if that decision was not one we  could make within our charter we would seek a modification of our charter.    I do not think that S is the right decision, but, apparantly unlike Patrick,  I think I can live with it.    Jeremy        

        I'll try and post an updated version of my triples doc sometime later  tonight.    It will have a more chatty intro than the current version.    Jeremy        

        >  > If its really this kind of binary decision, I strongly vote in favor of  > preserving comments.  I have a knee-jerk reaction to deleting any  > information, and I believe this is what would be expected by content  > produces that take time to include comments.  >    While I am yet to finish, and it's not quite that binary; I will note at  this point that preserving comments will break most current implementations,  which discard comments.    Jeremy        

        Jeremy:  > >+ equivalence of RDF graphs is NP complete  Pat:  > Presume you mean semantic equivalence, ie A equivalent B means: A  > entails B and B entails A (?)    Yes.      Jeremy:  > >So the "graphs are sets?!" thread was triggered by my observation that an  > >ntriple file with two identical triples  > >  > >A:  > >  > ><uri> <pred> <uri2> .  > ><uri> <pred> <uri2> .  > >  > >was equivalent to one with only one:  > >  > >B:  > >  > ><uri> <pred> <uri2> .    Pat:  > They are certainly equivalent in the sense that each entails the  > other. I thought what we were discussing was whether we even want to  > allow the first one as a well-formed graph.  >    It *is* a well-formed N-Triples file.      Jeremy:  > >  > >I am unclear as to whether these are theoretical difficulties that can  > >safely be ignored; or real practical difficulties that should be  > addressed  > >by fundamental changes to the model theory.    Pat:  >  > I don't think that they are too surprising, and that we shouldnt  > *worry* about them. There is no way to get past them in any case by  > changing the model theory; we would have to abandon anonymous nodes  > altogether in order to get rid of the subgraph-isomorphism property.  > Even if we used Ntriples documents with bNodes, there is always the  > possibility of permuting the bNode labels, and that gives us the  > leeway to encode graph isomorphism.      I will need to think about this some more - may there be some other  understanding of anonymous nodes that has better worst case tractability?    An example of such an understanding would be that an anonymous node stands  for a one-time use gensym URI; and each time you read a file you get a  different one. It makes it hard to use anonymous nodes, but they then are a  purely syntactic macro and at the higher levels everything is more  tractable. I *do not* advocate this - it is bonkers since a file does not  even equal itself in any useful sense!    Jeremy        

          The relevant Jena developers are out next week,  we may be able to send some reports today and tomorrow.  We are unlikely to give an integrated report - and it may well be of the   sort like "we passed all the parser tests".    Jeremy    Eric Miller wrote:    >   > Working group member developers,  >   > We are in the process of assessing RDF implementation for drafting a   > directors decision and we need your help.  >   > Please run your code base against the test cases [1] and report your   > finding to w3c-rdf-comments as soon as possible. We need this in the   > next week.  Please include in your finding the toolkit name and   > description. Describing your toolkits in RDF gets you bonus points :) [2]  >   > Please feel free to forward this request to other developers who are   > working on RDF toolkits.  >   > thanks for all of your help,  >   > --eric  >   > [1] http://www.w3.org/2000/10/rdf-tests/rdfcore/  > [2] http://www.w3.org/2001/sw/EO/usecases/tools  >         

      Martin:  > >What are your `other contexts'? I guess you mean non-RDF contexts by the  > >(I hope) all-inclusive `when interpreting an RDF graph  > >according to the RDF model theory'. I am anxious to make the point that  > >the same transitive equivalence criteria are used throughout RDF  > >construction and querying (and hence in the construction of queries in  > >any query language).  >    The word "interpreting" is used as "interpreting according to the RDF model  theory". Model theory in general uses the word 'interpretation' as a very  narrowly defined technical term. The note was using the word "interpreting"  in that narrow context and *not* an all-inclusive way.    Jeremy        

            Frank Manola wrote:      > There are lots of other possible (and similarly innocuous) problems.  I   > just put the new boilerplate into Primer (mostly copied from the latest   > Concepts), and it now complains about the fact that the word "last call"   > appears, but there's no ending date (however, it says you can ignore it).  >   > --Frank  >   >       Oh yes - I had forgotten that one - that just has to be ignored.    Jeremy        

        I attach two PDF files, the A3 version has the desired 2D layout, the A4  version is presumably more printable.    In a chat before the teleconference with Dave Beckett he argued, fairly  convincingly:  + we shouldn't impose another formalism on our target developer  community.    It may be more realistic to assume XSLT for example.     + he also found my working from the EBNF rules as somewhat disingeneous.    If we are saying that they are syntactically flawed (which is the  motivation for an infoset approach), it then seems strange to motivate  our triple production on top of them.    (I hope I haven't misrepresented DaveB).      I am trying to argue in favour of a formal declarative spec for triple  production; without going to extremes (e.g. xml:lang can be added using  English text)    Jeremy        application/pdf attachment: rdf_and_lfg_A3.pdf    application/pdf attachment: rdf_and_lfg.pdf          

          Integrating text from Martin and Graham  (see particularly second bullet point UTF-8)    [[    The lexical space     is the set of all strings:     + which are well-balanced, self-contained  <a href="http://www.w3.org/TR/2000/REC-xml-20001006#NT-content">  XML content</a> [XML];     + for which encoding as [UTF-8] yields exclusive Canonical       XML (with comments, with empty InclusiveNamespaces       PrefixList ) [XML-XC14N];     + for which embedding between an arbitrary XML start tag       and an end tag yields a document conforming to XML       Namespaces [XML-NS]      The value space is a set of entities, called XML values, which is:     + disjoint from the lexical space     + disjoint from the value space of any XML schema datatype [XML-SCHEMA2]     + disjoint from the set of Unicode character strings [Unicode]     + in 1:1 correspondence with the lexical space.        The lexical-to-value mapping      is a one-one mapping from the lexical space onto the value space,      i.e. it is both injective and surjective.        Note: Not all lexical forms of this datatype are compliant with XML 1.1  [XML 1.1]. If compliance with XML 1.1 is desired, then only those that are  fully normalized according to XML 1.1 should be used.    Note: XML values can be thought of as the [XML Infoset] or  the [XPath] nodeset corresponding to the lexical form, with an appropriate  equality function.    Note: RDF applications may use additional equivalence relations, such as  that which relates an xsd:string with an rdf:XMLLiteral corresponding to a  single text node of the same string.        ]]        Graham I think the discussion of the 1-1 mapping is sufficient for the   equality between the XML values.  We could modify last point in value space to     + in 1:1 correspondence with the lexical space. (This correspondence   preserves equality).    but I think it is redundant.      Jeremy        

        I was too quick to second DanC's proposal.    The linkage that was clear to Pat between the weasle-words and dark triples,  was also clear to me.    For Dan's sake here is the explanation.    A dark triple is just another name for an unasserted triple. In the Model  Theory such a possibility has always been present; but since no mechanism  (syntactic or otherwise) for creating a dark triple has ever been present in  RDF the Model Theory section has been there for future extension. Since  WebOnt has formally asked for dark triples, it would be an odd response to  remove them.    WebOnt has had difficulty in clarifying WebOnt's need for dark triples.  Currently the two groups are attempting to clarify what problem we are  trying to solve, and whether dark triples actually does solve it, and  whether dark triples is the consensus solution.    My view is that we either should be serious about dark triples, in which  case there should be a mechanism for creating them; they should be in the  MT; and webont should use them for layering; or we should leave them out.  The latter is just like all the other nice to have features that we might  like in RDF2 and might be useful for something or other and that we have  left out of our clarification of M&S.    Thus I guess that the right order to go in is:  1: webont to clarify its needs sufficiently for informed consensus  2: consensus to be reached about using dark triples or not in webont  3: RDFCore following that consensus and either extending or deleting our  current treatment of dark triples    Double or quits?    Jeremy      > -----Original Message-----  > From: w3c-rdfcore-wg-request@w3.org  > [mailto:w3c-rdfcore-wg-request@w3.org]On Behalf Of Dan Connolly  > Sent: 19 April 2002 03:46  > To: Pat Hayes  > Cc: w3c-rdfcore-wg@w3.org  > Subject: Re: "asserted triple" weasle-words must go [was: best way to  > write triples?]  >  >  > On Thu, 2002-04-18 at 19:33, Pat Hayes wrote:  > [...]  > > >The most straightforward thing to do is to strike that text.  > > >That's my preference.  > >  > > OK, Im getting tired of this debate and also beginning to think that  > > might be the easiest way to go.  >  >  > huh? which debate? I just made one simple request.  >  >  > > That will help to drive another nail  > > into RDF's coffin, which might in the long run be the best thing for  > > the world in general in any case.  >  > ?????  >  > > And it might an interesting  > > experiment for one WG to simply tell another WG to shove its request  >  > ??? What request? Is this somehow related to  >  >  "It was also agreed to ask RDF Core for dark triples"  >   --  > http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Apr/0096.html  >  > If so, I don't see how.  >  > > That might at least produce some interesting stuff in the  > > coordination group email archive.  >  > ???  >  > > >Otherwise, let's see some test cases for what it means.  > >  > > Well, if you insist, but the MT makes the pretty clear, doesn't it?  >  > no, not at all.  >  > > Dark triples mean exactly nothing in the MT. They have no RDF  > > entailments. I could make up a test case if you really want one, but  > > it wouldnt be very interesting.  >  > Then why is it being requested?  >  > > >One option is to resurrect the magic-namespace from M&S 1.0.  > > >  > > >----  > > >When an RDF processor encounters an XML element or attribute name that  > > >is declared to be from a namespace whose name begins with the string  > > >"http://www.w3.org/TR/REC-rdf-syntax" and the processor does not  > > >recognize the semantics of that name then the processor is required to  > > >skip (i.e., generate no tuples for) the entire XML element  > >  > > No, that would not work.  >  > Well, that's news. JimH said the WebOnt WG didn't need to  > suggest a dark triples solution because all the options  > under discussion in RDF Core were acceptable.  >  > > The whole point is to have triples but not  > > have them asserted. The point is not to make them vanish, just to  > > have no *semantic* import.  >  > Maybe it's clear to everybody else how that works.  > Sorry, I don't get it.  >  >  > --  > Dan Connolly, W3C http://www.w3.org/People/Connolly/  >  >  >        

        Can't we split responsibility here.    RDF Core provides:  - rdf:parseType="collection"  - rdf:List, rdf:first, rdf:rest, rdf:nil    WOWG   - provides functionality (i.e. uniqueness)      Consider      <rdf:RDF>    <rdf:Description rdf:about="#foo" rdf:parseType="collection">    </rdf:Description>      <rdf:Description rdf:about="#foo" rdf:parseType="collection">      <rdf:Description rdf:about="#bar"/>    </rdf:Description>  </rdf:RDF>    #foo is a non-standard collection with lengths of both 0 and 1.    This could be legal RDF and ill-formed at the ontology level.    Jeremy           > -----Original Message-----  > From: w3c-rdfcore-wg-request@w3.org  > [mailto:w3c-rdfcore-wg-request@w3.org]On Behalf Of Dan Connolly  > Sent: 24 April 2002 04:39  > To: Pat Hayes  > Cc: w3c-rdfcore-wg@w3.org  > Subject: Re: addressing requirements around daml:collection  > (rdfms-seq-representation)  >   >   > On Tue, 2002-04-23 at 17:41, Pat Hayes wrote:  > [...]  > > >By 'ala daml:collection' I meant: including  > > >the fact that first/rest are functional.  > > >  > >   > > Oh, I see.  But then that is a much bigger change/extension to RDF   > > than it seems, since now RDF has a way to encode functional   > > properties.  >   > It's a big change, yes. I'm not sure I'm comfortable with it.  >   > The longhand-OK option is acceptable to me, but I dunno  > if it'll fly in the WebOnt WG and community.  >   > The other options, i.e. techniques for enhancing  > the <rdf:li> style collections to express closed  > lists (a) have to be at least as powerful as first/rest  > in order to get the job done (I think?), and (b) look uglier.  >   > > That goes beyond just adding a different kind of   > > container. I would like to explore what the other implications of   > > that might be.  >   > --   > Dan Connolly, W3C http://www.w3.org/People/Connolly/  >   >   >         

            On the semantics issues, which I don't honestly expect we will reach, can I  suggest we also add rdf:List semantics into the pile of things to discuss,  see:    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Oct/0081.html    I would like us to reach consensus on list semantics before the next MT WD.    I also have a Webont action that I can't progress until RDFCore makes a  decision here.    Jeremy      [[[  12: possible semantic bugs  concerning domain and range Jos has asked for this on the  agenda      See:    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Sep/0288.html      13: Proposed technical changes to RDFS model theory      See:    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Sep/0169.html  ]]]        

      >               Idiom P in this MT requires the range of a  > property to be a literal-value pair. But that is wrong, for P. If I  > want to say that the range of a property is xsd:integer, I mean to  > say that the range is whatever xsd says integers are, ie the value,  > not a literal-value pair. One hundred and twenty-three is an integer;  > the pair <'123',123> is not an integer (according to XSD).    Short version:    P and S-B have rdfs:range as referring to the value space.  S-A has rdfs:range as referring to the lexical space.  My proposal explores the third possibility of having rdfs:range as referring  to the map.    I don't think there are any a priori reasons that rule that out. It is our  model theory and we are free to choose what parts of the world get modelled  where. Since rdf:type is found in the model I find it more natural to do the  datatyping work in the model.    Longer version:  omitted.    Jeremy        

          DaveB:  > I don't do any of the #literal-* issues; they are for the model.    I am expecting #literal-is-xml-structure to have a foot in both camps.    Jeremy        

        My copy of this test has the line  _:j88096 <http://example.org/prop1> :j88097 .    (with those numbers even)  I believe this to be correct.  I assume that this has been 'fixed' incorrectly since I got this copy.    Jeremy      Dave Beckett wrote:    > We just had a comment on this test case on the rdf comments list:  >   http://lists.w3.org/Archives/Public/www-rdf-comments/2003JanMar/0043.html  > and this means an approved test case needs to be corrected to match  > the rdf/xml grammar.  >   > This result:  >   http://www.w3.org/2000/10/rdf-tests/rdfcore/rdfms-not-id-and-resource-attr/test003.nt  >   > needs the following change:  >   > 15c15  > < _:j88096 <http://example.org/prop1> "" .  > ---  >   >>_:j88096 <http://example.org/prop1> :j88097 .  >>  >   > to match http://www.w3.org/TR/rdf-syntax-grammar/#emptyPropertyElt  > where when both rdf:ID and rdf:bagID are both present, the statement  > value is a blank node (the "Otherwise" clause) not an empty literal.  >   > The good news:  >   > [[P.s.Using SWI-Prolog from the CVS snapshot it processes the rest of  > the test-suite properly now.]]  >   > So that makes nearly 4 full implementations of the parser test cases  > (detailed evidence for this will have to be collected).  >   > Dave  >   >         

      > rdf-charmod-literals: Does the treatment of literals conform to charmod ?    > We need an owner to check this.      While I would prefer not to own this, our earlier analysis did arrive at a  conclusion.    My earlier analysis was (again) in the (still too long):      http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Sep/0378.html    [[[  [1a]  The Unicode String in an RDF Literal is normalized according  to Unicode Normalization Form C [NFC, NFC-Corrigendum], using  a framework of early uniform normalization.  ]]]    This amounts to:  - all RDF syntaxes are constrained to only permit Unicode strings that are  normalized.  - So that a graph with a node labelled with a Unicode string with a  character c followed by a non-spacing cedilla character in it is not an RDF  graph.  - RDF/XML syntax includes this restriction on literals  - N-Triple syntax includes this restriction.  - implementations that read documents in non-unicode characeter sets (e.g.  many XML implementations) need to use a normalizing transcoder when  converting into Unicode.    "Early uniform normalization" is simply another way of saying that. Early  uniform normalization means that it is the original document's author's  responsiblity to not create non-normalized strings.    I could provide some test cases of ill-formed RDF/XML under this proposal.    My understanding of how this differs from requiring an RDF/XML document to  be fully normalized XML is as follows:    A] Fully normalized XML permits the sequence character c, XML comment,  non-spacing cedilla.    This proposal prohibits that sequence.    B] Within an XML comment fully normalized XML prohibits the sequence  character c, non-spacing cedilla. This proposal does not prohibit this.      I think [A] is a defect with the current concept of fully normalized XML.  Either there should be more acknowledgement that XML documents are read in  different ways depending on quite what sort of XML document it is, or  minimally it should be required that all string values within the XPath node  set are normalized.    I think [B] could be added as an additional requirement on RDF/XML, i.e.  that the XML as XML is fully normalized as per charmod.      I do not believe that this presents implementators with too much work.    The thorough implementator will need:  - normalizing transcoders.    These should be off-the-shelf components, since in a while all W3C specs  will require their use. (Are any available?)    - ability to detect Unicode strings that are not NFC.    I thought I had seen some fairly simply open source code to do this.  Anyone have a pointer?        The DPH (less thorough implementor) can:  - ignore the whole issue if they are only interested in a US market, and get  reasonably interoperability.  [This, as I understand it, is one of the goals of early uniform  normalization].        Jeremy        

            Brian McBride wrote:    > At 18:16 06/03/2003 +0000, Jeremy Carroll wrote:  >   >   >> Brian, please prioritize discussion of this issue since  >> it is critical path for WebOnt.  >>  >> Proposal to close reagle-01, reagle-02.  >>  >> Summary:  >>  Use exc-c14n without comments throughout.  >>  Suggest that parser should (but not SHOULD) canonicalize.  >   >   > I thought we were defining the syntax and semantics of a langauge, and   > assuming a processing model.  >   > If this will solve the webont problem, then can we say nothing at all?    > They just have to make sure they use a canonicalising parser?  >   > Brian  >       The actual changes I propose that suggest that parser should canonicalize are:    1: adding test(s) that are based on that asusmption (We have not included   tests in the test suite that require C14N).  2: adding following note to concepts:  [[  Note: For systems which reason about RDF graphs  it is suggested that the canonicalization be  performed on XML input. The internal representation  and non-XML external representations should be  in canonical form.  ]]    There is some webont resistance to the cost of c14n, and the added   complexities they perceive. It has not helped that Pat felt a need to spell   out the L2V mapping of rdf:XMLLiteral in the semantics doc.    By spelling out the obvious implementation we may make it clearer that   webont implementors just do a string compare.    This text does not preclude other implementations even for reasoning systems.    Jeremy        

          > Item 18: Schedule  >   > http://www.w3.org/2001/sw/RDFCore/#microschedule  >   >    As per Eric's request, all editors to work from the PUBLISHED  >    docuements (to ensure html tidyness is in place)  >   >    Links should be to the TR document, not the editors' working drafts.  >   >    If you create an anchor, don't remove it.  >   >    Pubrules citation requirements were discussed. [Scribe won't attempt  >    to minute from the IRC as the trascript is somewhat sparse - can  >    somone follow up to this with the rule regarding citation?]  >       I intend to remove all gensym anchors from concepts.  They are like:     #xtocid4807  and they are difficult to maintain.    Jeremy        

      >Is the RDF usage scenario that you  > will want to be serializing subsets of an XML document and that  > you expect  > to move those subsets between documents?    Yes.    For example, news feeds using RSS (built on top of RDF), may have the same  xml literal being written into an original document, read by a processor,  written out again in a new context, read by another processor, written out  again in yet another context ....      My reading is that the C14N Inclusive would result in namespace pollution,  in which the xml fragment would gradually pick up more and more irrelevant  namespaces as it progressed through such a processing chain.    Jeremy        

          About section 3 and some of the references ...      >   > 3  >   > (Syntax doc will point to 3.1*, 3.2* and remove the appropriate sections)  >   > 3.1  >   RDF URIrefs are compatible with, but aren't based on, W3C XML  >   Schema (WXS) anyURI.  If we define RDF in terms of WXS, that adds new  >   normative references and we haven't done that yet.      Correct this is not intended to normatively depend on WXS but to be   compatible with, I will check the text.      >   > 3.2.2  >   Explain where <tag> came from.  Something like, this is not a new  >   element but used to show how an XML literal is any legal XML  >   element content and can be used "as if" enclosed in a  >   <tag>...</tag>      Yes this bit needs a bit of polishing.      > 3.2.2.1  >   odd numbering, only sub-section.  Maybe add 3.2.3 Equality of  >   Literals and add equality of strings(+lang), xml(+lang)  >   sub-sections of that/      I'll consider.      >   > 3.4 Triples  >   need to point here from earlier where triple was first mentioned  >   > 3.5 RDF graph  >   "collection of RDF triples"?   Must be something more precise than  >   that?      That's precise.      >   >   The Note: maybe should be in the body text and a <ul> list?      I didn't want to make heavy weather out of this; really only interesting   for mathematicians.      >   > 3.7  >   This list is correct at the moment, but I would ask it point  >   to a syntax doc section or list, since the list may change  >   (for example the proposed rdf:node)      I think we are planning to drop this list all together if the WG is   minded to say that this URIrefs are legal but cannot be serialized.    In which case that point should be made in the serialization section of   the syntax doc.      >     >   To be completed.  >   >   We aren't normative on charmod.  or c14n?      We are certainly normative on xc14n (xml literal resolution).    I'll consider the charmod status, you might be right.    Jeremy        

        >   >   > oops...  > jena.rdfcopy seems to be too happy with error001 as well  >   >     A known bug ;( ?        

          Some style issues:    - I think all references to the WG should be deleted, except as a  non-normative appendix which may be a list of names of those who have  contributed.     (e.g. delete 1st para of section 3, and the TODO item)    - I think the original grammar should be a link not a quotation.    - I think section 3 should be a non-normative appendix, leaving the XML  Infoset approach as normative. (Obviously at the moment everything is  non-normative!)    A typo:    In the table in section 3  " rdf:parseType="Literal\"" should read  " rdf:parseType=\"Literal\""    Jeremy        

          A suggestion from an HP conference organizer is:    [[  Hullaballoos on Whiteladies Road for your evening meal on  Monday 7th Oct.  [Julie] contacted them and they can do a table for 25,  prices  are: 2 course ?13.30 or 3 course at ?16.30  ]]    Jeremy      > -----Original Message-----  > From: Libby Miller [mailto:Libby.Miller@bristol.ac.uk]  > Sent: 11 September 2002 18:18  > To: Jeremy Carroll  > Cc: www-archive; julie_lanfear; sb; libby.miller; david_trastour; danbri  > Subject: RE: F2F social arrangements  >  >  >  > crud, sorry Jeremy. I did ask at work but didn't get many responses, in  > fact this was the only one:  >  > [[  > Grillbar on a sunday if you like meet they can cater for lots of  > people but they draw the line at RDF conversations......there is a  > warning on the door  ;)  > I heard that jamesons dont like DAML    :)  > ]]  >  > I don't know where the grillbar is though...jamesons is ok - and they  > have a cheap menu, but it's french and the portions are small.  >  > http://www.whatsonbristol.co.uk/reviews/grillbar.html  >  > I expect I could look at the hotel.  >  > below are some previous restaurant recommendations of restaurants from  > when I asked where to take my parents...  >  > near ILRT there's also Browns, which is quite big, though I've never  > been there; Azuma japanese restaurant which I like; oh, for Sunday night  > we could go to the ILRT favourite the Hope and Anchor on Jacobs wells  > road, which does rather nice food, though I'd have to check if they  > serve food on sunday evenings (I just checked - they do until 9.30 pm),  > and if the weather is poor it's not very big.  >  > see also  > http://www.whatsonbristol.co.uk/reviews/restaurant_reviews.html  >  > [[  > coccobello's is v good in Colston St (based in the bottom of Colston  > Tower).....they do pizza, main italian meals + plus they have a wet  > board (fish) (I chose the monkfish which was v good)  >  > see review:  >  > http://www.whatsonbristol.co.uk/reviews/coccobello.html  >  > however its not a BYO.....  >  > ---  >  > How about Budokan?  It's not BYO but it's not too expensive.  >  > Jamesons, opposite the BRI, is good but may be a bit pricey (and not BYI)  >  > ---  >  > lovely montpelier of course!  >  > bell's diner, or the indian place  >  > ---  >  > there is Taste of Morocco at the top of pig sty hill - although I guess  > that is about ten minutes walk up the gloucester road.  >  > ---  >  > Red Snapper on Chandos Rd, Fish, NOT BYO  >  > ---  >  > Just been last week to Juniper in Cotham (so just about walkable).  > Very good, not BYO, slightly pricey (10-12 pound for a main course),  > but definately worth it.  > ]]  >  >  >  >        

      > Although it is agreed that support for the P+ idiom is beyond  > the scope of our charter (presumably ;-) I have found the  > elegance of the combination of P and P+ to be difficult to  > dismiss, and wonder if we might not consider bending the charter  > regarding the single point of P+ support.    I find the pictures very compelling, but nevertheless oppose this.  The problem is the knock on impact.  This is not just bending our charter, it's driving a coach-and-horses  through it - in that the syntactic changes in RDF/XML that will be required  are, (guessing) quite substantial; creating a significant backward  compatibility issue.    I think the PD proposal has nearly as much elegance, and certainly would  permit a later migration to P+, while being probably the most in-charter  proposal on the table.    Jeremy        

          Graham wrote:  >So my questions are:  >(a) is the proposed rewording (below) any clearer?  >(b) should I work in the example -- I'm thinking an edited version might  >appear as a new section 2.3.5, illustrating what has gone before.    I hope it's not disloyal to say that I prefer Pat's example to your text ...  I rather like (I think Brian's idea of) including Pat's example as a test  case rather than as an example in the WD.    Jeremy        

          This message is intended for both jena-devel and w3c-rdfcore-wg.    RDF Datatyping  ==============  The RDF datatyping proposals involve:    - local datatyping    - global datatyping    Local datatyping involves immediate triples to indicate a lexical form and a  datatype to use to map that lexical form.    Global datatyping depends on the schema to find the datatype.    It is currently unclear as to whether the datatyping will be tidy or untidy.  This message will address both possibilities.      Jena 2 Graph API  ================    Jena 2 is currently in experimental stages.    A key characteristic is that as well as having graphs which are actual triple  stores, there are virtual graphs which are derived from other graphs using some  rules (e.g. RDFS closure rules).  Virtual graphs have an API very much like a store, but there is no suggestion  that any triple returned has not been created on the fly. Virtual graphs can be  infinite.    Richer interfaces (Models) are implemented over Graph to give extra  functionality but no extra triples.      Local Datatyping  ================    Local datatyping would be exposed as extra methods on the richer model  interface. This may be exposed on the Statement class e.g.    Object Statement.getDatatypeValue()    returns    The value of the object of the triple as a java object according to the local  datatyping rules.    If the particular triple does not conform to the local datatyping idiom then  null is returned.    If the particular triple conforms inconsistently to the local datatyping idiom  then a RDFInconsistentException is thrown.    e.g.    t = <a> <p> _:b .      _:b <xsd:int> "10" .    t.getDatatypeValue() returns a java.lang.Integer object with value 10.    t = <a> <p> "10" .    t.getDatatypeValue() returns null    [[ Choice here: with tidy datatyping we may wish to return the java.lang.String  "10", any language tag would explicitly be dropped. With untidy datatyping then  this must be null. ]]    t = <a> <p> _:b .      _:b <xsd:int> "10" .      _:b <xsd:int> "11" .    t.getDatatypeValue() throws an exception.          Untidy Global Datatyping  ========================    Global datatyping is implemented as a graph to graph mapping.    Graph g1 = ...;    Graph g2 = new DatatypedGraph(g1);    This graph to graph mapping expresses the global datatyping as triples following  the local datatyping conventions.    This would follow the convention of simpledatatypes2 that a lexical node *is* a  shorthand for a bNode with a dlex arc leading to the lexical value.    i.e. if   <a> <r> "10" .     is in g1  then   <a> <r> _:b .   _:b <dlex> "10" .  are in g2.    (and <a> <r> "10" is not in g2).    Also the additional closure rules of simpledatatypes2 would be applied.    If    <a> <r> _:b .    _:b <dlex> string .    <r> <drange> datatype .  are in g2 then also    _b datatype string .  is in g2.      Actually accessing the values would then be achieved as for the local  datatyping; which provides the API.    Tidy Global Datatyping  ======================    In the tidy case the triples would remain unchanged but their interpretation is  extended to take into account the global datatype.    Hence if    t = <a> <r> "10" .  and    <r> <drange> <xsd:int> .    then  t.getDatatypeValue() would return the java.lang.Integer object as before.    If      t = <a> <r> "10" .    <r> <drange> <xsd:int> .    <r> <drange> <xsd:string> .    then  t.getDatatypeValue() throws an exception.          Nonmonotonicity  ===============    Both approaches have aspects that appear non-monotonic.  In the untidy approach, the graph to graph mapping replaces each triple with a  simple literal object with two triples and a bNode. This replacement, while  intended to be semantically neutral, at least appears like a deletion at the  syntactic level, and, it could be argued that this is non-monotonic.      The tidy case is thrown by an example like:    t = <a> <r> "10" .      <foo> <subPropertyOf> <drange> .      <r> <foo> <xsd:int> .      Here, taking the datatype over the RDF graph only we would get the string "10";  taking the RDFS closure and then taking the global datatyping we would get the  Integer 10.        Jeremy        

        I had a request for examples. Here are some.      Examples:    Suppose we have two http servers, one using UTF-8 the other using   iso-8859-1 called    utf8.example.org and iso-8859-1.example.org    each has files called      simple    braces{}    percent%    Duerst                (where ue represents u umlaut)    Duerst/percent%    Duerst/braces{}    Then the following table gives the URI, the IRI, and the partially   escaped IRI (PE IRI) of the files     The PE IRI is suitable for contexts where the unwise characters may   not be used.    utf8.example.org    URI         http://utf8.example.org/simple   IRI         http://utf8.example.org/simple   PE IRI      http://utf8.example.org/simple    URI         http://utf8.example.org/braces%7B%7D  IRI         http://utf8.example.org/braces{}  PE IRI      http://utf8.example.org/braces%7B%7D    URI         http://utf8.example.org/percent%25  IRI         http://utf8.example.org/percent%25  PE IRI      http://utf8.example.org/percent%25    URI         http://utf8.example.org/D%C3%BCrst  IRI         http://utf8.example.org/D#C3#BCrst  PE IRI      http://utf8.example.org/D#C3#BCrst    where #C3#BC is the two bytes with those values.    Note: both the IRI and the PE IRI may be encoded in other     character encodings, in which case the #C3#BC should be replaced    by the representation of u umlaut in such an encoding.    UCS-based encodings must use a NFC representation of u umlaut    (i.e. that u umlaut unicode character) and not an abnormal    form such as a u and an umlaut. Non UCS-based encodings    do not have this restriction.    URI         http://utf8.example.org/D%C3%BCrst/percent%25  IRI         http://utf8.example.org/D#C3#BCrst/percent%25  PE IRI      http://utf8.example.org/D#C3#BCrst/percent%25    URI         http://utf8.example.org/D%C3%BCrst/braces%7B%7D  IRI         http://utf8.example.org/D#C3#BCrst/braces{}  PE IRI      http://utf8.example.org/D#C3#BCrst/braces%7B%7D        iso-8859-1.example.org    URI         http://iso-8859-1.example.org/simple   IRI         http://iso-8859-1.example.org/simple   PE IRI      http://iso-8859-1.example.org/simple    URI         http://iso-8859-1.example.org/braces%7B%7D  IRI         http://iso-8859-1.example.org/braces{}  PE IRI      http://iso-8859-1.example.org/braces%7B%7D    URI         http://iso-8859-1.example.org/percent%25  IRI         http://iso-8859-1.example.org/percent%25  PE IRI      http://iso-8859-1.example.org/percent%25    URI         http://iso-8859-1.example.org/D%FCrst  IRI         http://iso-8859-1.example.org/D%FCrst  PE IRI      http://iso-8859-1.example.org/D%FCrst    note #FC is the representation of u umlaut in iso-8859-1    since the IRI is UTF-8 based this must be escaped in all    representations of the URI. We also note that the    decode algorithm for creating a human readable form of the IRI    fails. The server decode algorithm for the URI (which uses    the server specified encoding of iso-8859-1) succeeds.      URI         http://iso-8859-1.example.org/D%FCrst/percent%25  IRI         http://iso-8859-1.example.org/D%FCrst/percent%25  PE IRI      http://iso-8859-1.example.org/D%FCrst/percent%25    URI         http://iso-8859-1.example.org/D%FCrst/braces%7B%7D  IRI         http://iso-8859-1.example.org/D%FCrst/braces{}  PE IRI      http://iso-8859-1.example.org/D%FCrst/braces%7B%7D      Note: the characters { and } only do not need escaping since     the encoding of them under ISO-8859-1 and UTF-8 are identical.    Any instance of an IRI may be replaced by a (partially) encoded    IRI, because the encoding algorithm is idempotent.      With all of these, the IRI encoding algorithm produces the URI (whether   applied to the URI, the IRI or the PE IRI). With all of the UTF-8 based  examples the IRI-decoding algorithm, whether applied to the URI, the   IRI or the PE IRI produce the IRI.    Hence, no layer of software needs to specify of its input which one of  URI, IRI or PE IRI, in order to be able to produce a URI output.        

          > >1:[[  > >  > >eg:prop rdfs:range eg:A .  > >eg:A rdfs:subClassOf eg:B .  > >  > >entails  > >  > >eg:prop rdfs:range eg:B .  > >]]  >  Brian:  > Wierd!    I think I had better explain it in English, by means of the example Jos gave  of rdfs:Resource.    The informal meaning of  eg:prop rdfs:range eg:A .    is that "any object of an eg:prop triple is of type eg:A".    We happen to know that     "any object of an eg:prop triple is of type rdfs:Resource".    (ignoring Literals for now)    that is we know a priori that    eg:prop rdfs:range rdfs:Resource .    -----    To get to the actual entailment, we are given:      > >eg:prop rdfs:range eg:A .  > >eg:A rdfs:subClassOf eg:B .    i.e.  "any object of an eg:prop triple is of type eg:A"  "any object of type eg:A is of tpe eg:B"    therefore    "any object of an eg:prop triple is of type eg:B"    that is    eg:prop rdfs:range eg:B .    ---    or:    eg:bananaTrifleContains rdfs:range eg:banana .  eg:banana rdfs:subClassOf eg:fruit .    entails    eg:bananaTrifleContains rdfs:range eg:fruit .    the conclusion is always true if the premises are true, unless the  conclusion is seen as having intensional force.      ====    This is an example of a wider issue that has come up in webont, which is:  "Are properties of properties understood extensionally or intensionally?"    Decoding that, in this example, is being a range of a property something  which a class has because certain class membership relationships hold  (extensional), or is something which a class has because somebody said so  (intensional).    If you take the extensional view, then you should support the "Jeremy  entailment", if you take the intensional view then you should oppose it.    As I said before the name reflects authorship not belief.  This is a genuine question, and both points of view are legitimate.    The relationship with WebOnt is that the majority on webont would like to  treat all properties of properties in the same way (either all extensionally  or all intensionally). Which is the preferred way is yet to be decided.    If RDF Core either don't care or are split without strong opinions, then a  way of deciding would be to follow the webont pref.    If RDF Core care, then that is a significant input into the WebOnt decision  on the other properties of properties. (eg. owl:TransitiveProperty).    Jeremy        

        I first noticed the lack of support for 10,03-de in XML Schema Datatypes  (which is a Recommendation).    Jeremy    > -----Original Message-----  > From: A. Vine [mailto:andrea.vine@sun.com]  > Sent: 01 March 2002 18:56  > To: Jeremy Carroll  > Cc: Pat Hayes; Patrick Stickler; w3c-rdfcore-wg@w3.org;  > w3c-i18n-ig@w3.org  > Subject: Re: xml:lang [was Re: Outstanding Issues ]  >  >  > Wow, this surprises me as well.  Is this part of one of the W3C  > guidelines or  > one of the XML specs?  >  > Jeremy Carroll wrote:  > >  > > i.e. software running in a german locale should display and  > accept 10,03 as  > > a number a little more than ten. However, when communicating that number  > > with other software (even in the same locale, and even in a  > markup document  > > that may have human readers) it should use the US form of the number.  > >  > > It surprised me.  > >  > > But in my book the I18N people get to decide this.  > > Looks like this example is out of scope.  > >  > > Jeremy  >  >        

        >  Jan:  > >I've just begun hacking around with an intermediate form that relies on  > >the fact that in RDF/XML, the only anonymous nodes that can be involved  > >in a statement are the most recent two encountered, modulo the pushing  > >and popping of subelements (ie, it follows the nesting of elements).  >    Hmmm, reification,  bagID? Of course, with custom pushing and popping your  statement is vacuous, so I am reading it as meaning the natural pushing and  poppping.    Jeremy        

          Graham:    [[[  To test my understanding:       _:a ex:prop1 _:b .     _:a ex:prop2 _:b .     _:c ex:prop3 _:a .    could then be:    <rdf:Description rdf:node="_:a">     <ex:prop1 rdf:node="_:b" />     <ex:prop2 rdf:node="_:b" />  </rdf:Description>  <rdf:Description rdf:node="_:c">     <ex:prop3 rdf:node="_:a" />  </rdf:Description>    ]]]    Yes, or more simply    <rdf:Description >     <ex:prop3 >      <ex:prop1 rdf:node="_:b" />      <ex:prop2 rdf:node="_:b" />     </ex:prop3>  </rdf:Description>    since the _:b one is the only one that is difficult.    Jeremy    -----Original Message-----  From: w3c-rdfcore-wg-request@w3.org  [mailto:w3c-rdfcore-wg-request@w3.org]On Behalf Of Graham Klyne  Sent: 17 July 2002 00:44  Subject: Re: rdfms-syntax-incomplete        I'm agnostic about whether we should do this, but if we do the approach  seems mostly OK to me.  I think it's better than the _:x form of 'URI'  because this provides a very clear syntactic marker in the XML.    To test my understanding:       _:a ex:prop1 _:b .     _:a ex:prop2 _:b .     _:c ex:prop3 _:a .    could then be:    <rdf:Description rdf:node="_:a">     <ex:prop1 rdf:node="_:b" />     <ex:prop2 rdf:node="_:b" />  </rdf:Description>  <rdf:Description rdf:node="_:c">     <ex:prop3 rdf:node="_:a" />  </rdf:Description>    ?    Two comments:    (1) I think we'd need to be careful about what constitutes "file scope" --  not all RDF is contained in files.  I think we could specify a document  scope for web resources (a complete representation that you get when  dereferencing a URI), which covers files via the file: uri scheme, then  note that applications that obtain RDF in different ways must specify the  scope of any node identifiers used.  (e.g. CC/PP protocol.)    (2) I think we'd need to say something about combining graphs with these  node identifiers;  i.e. that renaming must be performed.    (3) Say explicitly that within a scope, any node identifier can be changed  throughout to any other identifier not used in that scope without changing  the semantics.    #g  --    At 07:48 PM 7/16/02 +0100, Jeremy Carroll wrote:      >Proposal in brief:  >  >- use attribute rdf:node to associate node identifiers with blank nodes.  >- file scoped identifier.  >- any XML string is legal blank node identifier.  >  >Full resolution:  >- reopen issue rdfms-syntax-incomplete  >- add an attribute rdf:node to the RDF/XML syntax.  >- modify the syntax to permit rdf:node in place of rdf:about.  >- such a use associates the value of the attribute as a file scoped  >identifier for the blank node  >- modify the syntax to permit rdf:node in place of rdf:resource.  >- such a use associates the value of the attribute as a file scoped  >identifier for the blank node  >- any two blank nodes arising from the same RDF/XML file with the same  >identifier are the same blank node  >- action syntax editor to update the document to reflect this  >- rdf:node is not permitted as an element name in RDF/XML  >- action jjc to produce test cases  >- action daveb to update rdfms-names-use to reflect rdf:node  >- close issue  >  >  >======  >  >The chair was keen that we avoid too much discussion. I would like to  >highlight the choicepoints.  >  >+ use of attribute rather than pseudoURI  >  >One possibility was to use "_:label" in place of urirefs on the rdf:about  >and rdf:resource attributes. People said they did not like this idea. It  >would have less clarity but greater backward compatibility.    I think this way is safer.    >+ use of file scope rather than global scode node identifiers  >  >The scope of the identifiers is the same as the scope of identifiers in  >N-triples, i.e. the file. Some use cases point to a need for global scope  >blank node identifiers (e.g. talking about a node within a graph for later  >updates to the graph). This seems to me to be a separate issue, and  >addressing it would constitute a greater change to RDF. (global scope  means  >world-wide, like uris).    I think I prefer your way (being explicit about the scope), it makes it  clearer that node identifiers are different than URIs.    >+ use of one attributes for both subject and object position rather than  >two.  >  >The current syntax uses two attributes for URI refs. rdf:about on typed  >nodes and descriptions and rdf:resource on property elements. Since these  >two contexts are distinct there is no ambiguity in using the same attribute  >name for both. It may be less confusing to have rdf:aboutNodeIdentifier and  >rdf:resourceNodeIdentifier for the two different roles.    Eitherv way works for me.    Two identifiers might be more obvious, with a clearer relationship to  existing label attribute roles.    >+ choice of a short attribute name  >  >rdf:node seemed about the shortest clear name for the attribute.    We could discuss this endlessly.  I think short names are good, but not  essential.    #g      -------------------  Graham Klyne  <GK@NineByNine.org>        

        Sorry my e-mail on this topic got out before it was meant to.  I insert/correct the references etc    > containers test0004 involves the fourth expansion of the property element  > production rule 6.12.       [6.12] propertyElt    ::= [ omit ]                        | '<' propName idRefAttr? bagIdAttr? propAttr* '/>'    > By the decision to drop all the special container rules, this expnasion  then  > applies to rdf:li. By paragraph 232 (which is so horrible its number!)  this  > fourth expansion is different from the others, in that it does not reify,  > but the ID is the ID of the resource.  http://lists.w3.org/Archives/Public/www-archive/2001Jun/att-0021/00-part#232    > in my opinion para 232 is an error, and is addressed in the unresolved  issue  > FFFFFF    No, it isn't. None of the issues would allow us to drop para 232 if we  wanted to. We would need to start a new issue first.    > I did some archaelogy on this one, and as far as I could tell, this  > paragraph dates from the early days before the first working group  resolves  > issues 4, 7 ,11 and they still had a certain amount of confusion about  > referring to a resource and referring to the description of the resource.  I  > think it is a hard call whether to delete paragraph 232 or preserve it for  > the sake of backwards compatibility.    I have probably got those issues numbers wrong, and need to go over the  member archives to get the references. I will do that early september if  there is interest.      Dan Connolly wrote:  > > I guess my implementation will raise a "not supported"  > > exception in that case; I don't see sufficient value  > > to implement this.    > test0005 is also difficult for some parser writers (e.g. me). It is fine  if  > you really are using an XSLT transform to process rdf:li, but if you're  not  > you need some fairly horrid special code for processing a corner case that  > nobody in their right mind would rely on. ARP does it, but I personally am  > very sympathetic to a not supported exception.    Jeremy        

      > S-B is critical for anybody who wants to write  ><dc:date>2000-12-23</dc:date>  > and wants tools to flag an inconsistency when they write  ><dc:date>not the lexical form of any date</dc:date>    Well, if we only had S-B that is all that datatyping will do.  Relating the string "2000-12-23" to the day that was my  brother's 35th  birthday happens (untidily) within the application and not within RDF.    Other ways that the same effect can be achieved include:  - using P  - using TDL global idiom  - using Pat's flash bermuda triangle model theory with all bells and  whistles  - using the syntactic transform that behind the scenes sticks in an extra  rdf:value arc.    All of these have what I perceive as an advantage of actually doing some  model theory concerning dates.    This is why I haven't yet given in on tidyness. I could settle for tidyness  if we are using the syntactic transform, but if, as I think is likely, some  account of datatyping and DC + PRISM + RSS + ... is needed then we will need  one of the above (S-B included).    As I see it the WG has responsibilities both to:    - the metadata community, who don't do inference, and don't need a model  theory, and don't much care about underlying semantics of a bit of RDF (for  whom not having a model theory for datatyping is likely to be acceptable)  and to    - the logic community, who have been impressed with the MT so far, and who  I fear would be disappointed at a datatyping solution that is outside the  MT.      Jeremy        

        Summary: 'out of scope' too strong - but I would prioritize XSD.  Summary2: I support xsi:type    Jeremy:  >>  >> I don't think there are any killers here.  >> In particularly I disagree with Patrick when he raises non-XSD types -   >> simply out of scope as far as I am concerned.  >     Frank:    > I guess I don't understand this "out of scope" comment.  You may not   > care about referring to non-XSD types (I do), but considering them was   >  certainly "in scope" as far as making the "rdf:datatype" decision was   > concerned.  If you'd like to revisit the "what datatypes we're prepared   > to reference" question,       No, you're right I wasn't trying to revisit any decisions here; it's more   which is the tail and which is the dog.    I believe that Patrick already has implementations that use non-XSD types.  I certainly don't want to (maliciously) make those not compliant with RDF;   but they are 'non-standard' in the sense that the overall datatype   quadruple is one of Patrick's creation (not a standard's doc) using methods   that do not appear in a standard's doc.    I think the central usage that should motivate the main thrust of our   design decisions should be a standard one, and the only standard we have   considered (in any depth) is xsd. If we don't like the datatypes on offer   there we should be working with the XML schema group to improve them.    XSD provides a standard collection of built-in types and a standard way of   creating user-derived types. It isn't perfect; and won't do everything.    Hence providing a mechanism that permits Patrick's non XSD types seems OK   to me, as long as it does not distort the XSD usage. My opinion is that the   use of rdf:datatype as opposed to xsi:type will be (rightly) perceived by   the XML world as (another) outbreak of NIH from the RDF world. If we were   determined, we could choose to make xsi:type work - possibly we should,   possibly we should defer to the tag who own the qname/uri issue.    Making xsi:type work for RDF might create some problems when using RDF   datatypes which are not XSD datatypes; for me it is more important to align   with the needs of the (large) XML world, rather than those of the (small)   RDF world.    Jeremy        

            > Would that meant that the 'correct' thing for WEBONT to do would be to  > define owl:subClassOf as a subproperty of rdfs:subClassOf?      superproperty        

        Can I suggest an ammendment to the manifest:    replace (globally - twice?)    illegal Normal Form C literal  with    literal not in Normal Form C    Jeremy    > -----Original Message-----  > From: w3c-rdfcore-wg-request@w3.org  > [mailto:w3c-rdfcore-wg-request@w3.org]On Behalf Of Dave Beckett  > Sent: 24 April 2002 12:20  > To: Jan Grant  > Cc: w3c-rdfcore-wg@w3.org  > Subject: Test cases added for rdfms-charmod-literals  >   >   >   > I've added the tests for this issue that have already been approved:  >   >   [[7:  charmod-literal issue closed]]  >   >   -- http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Apr/0056.html  >   >   > and I added them in the new manifest format to  >   > http://www.w3.org/2000/10/rdf-tests/rdfcore/rdfms-charmod-literal/  >   > Jan: please check if I got this right  >   > Dave  >   >         

          Do you have any other ideas, Dan?  Those of us who would prefer a different term, need to propose one if we   want to be able to persuade others.    Jeremy      Dan Brickley wrote:    >   > Guus Schreiber wrote:  >   >   >> Reification is the proper term. For example, it is also used in UML   >> books to describe association classes.  >> I would suggest to put in a NOTE in the text to indicate that the term   >> is used in the general sense and does ot refer to RDF reification.  >   >   > Reification would be the proper term normally. It is unfortunate that   > the RDF spec uses up such a useful word, and particularly unfortunate   > that RDF reification isn't a particularly useful representational   > mechanism. I would advise against using the word 'reification' (even   > with a NOTE) to describe "non-RDF" reification in an RDF context. Even   > writing that last sentence tied me in knots, since non-RDF-reification   > (eg. the n-ary conventions) is of course something we do in RDF. The   > word is gone, taken from us... to use it is to encourage its continued   > use, and not everyone will be as careful as us to include a disclaimer   > NOTE. I guess I'm not arguing that we must completely avoid its use (eg.   > in footnotes, parentheses, discussion of relation to UML etc.), just to   > minimise references to 'reification' wherever possible.  >   > Dan  >   >   >         

        Revised wording taking Patrick's comments into account.  Hopefully we may consider this text, this afternoon.    a) consider MAY or SHOULD    b)    Jeremy Carroll wrote:    > The proposal is to delete the current note, and add the following:  >   > [[  > Implementation Note: (normative)   > In [XML-SCHEMA1], white space normalization occurs during validation according   > to the value of the whiteSpace facet. The lexical-to-value mapping used in   > RDF datatyping occurs after this, so that in RDF datatyping the whiteSpace   > facet formally has no effect. However, in line with the principle of being  > liberal with what is accepted and strict with what is produced:  >   > + During input processing of XML Schema Datatypes within RDF, software  > SHOULD apply the appropriate whitespace normalization immediatly before  > the lexical to value mapping, and MAY produce a warning if any whitespace  > is changed in this normalization.   >      > + Software generating RDF data SHOULD produce lexical forms   > which do not require whitespace processing.    >   > (The keywords MAY and SHOULD are defined in [RFC ????])  > ]]  >         

          I have now reviewed charmod.    I attach a summary of the things we would need to consider to conform with  charmod.  I do not propose we address these in our specs, but postpone this issue to  RDF 2.    Here is my proposed comment on charmod.  Given that they use some web based system for recording issues the actual  form of any issues we raise may differ, but I suggest we discuss this text.    Upto and including the first paragraph of the body of the message looks  like an e-mail, with the last two paragraphs each adding one issue to their  issue list.    =========    The RDF Core WG has feedback concerning the following sections  of charmod:    1. Introduction  2. Conformance  3.4 Strings  3.5 Reference Processing Model  4. Early Uniform Normalization  6. String Identity Matching  8. Characeter Encoding in URI References  9. Referencing the Unicode Standard  A.2 Other References  C. Composing Characters  D. Resources for Normalization      {{ the other sections are not relevant to RDF }}      Dave, please review section 9.    http://www.w3.org/TR/charmod#sec-RefUnicode      For the sections 1,2, 3.4, 4, 6, 9, C. D.  RDF Core fully endorses the last call working draft.  We have found earlier drafts helpful in identifying how best to meet our  responsibilities to RDF users world wide. While the current RDF drafts do  not fully conform with  all the requirements of these sections, we believe  that in a further revision of RDF it will be valuable to address all the  remaining ones.    {{ i.e. the issues in the attached list, excluding the IRI ones }}    For the section 3.5 we note that the language is somewhat offputting for us  as specification developers given that our specification explicitly does  not have a processing model. We have no particular suggestions about this,  nor would we object if the I18N WG chose not to address this issue.      Our main concern is with section 8 (and the IRI reference in A.2),  partciularly the requirement that specs "SHOULD use Internationalized  Resource Identifiers (IRI) [I-D IRI]".  The IRI draft is only a draft, the reference to it is not normative, and  the strength of this SHOULD dependency appears excessive ("not optional").  In particular, the IRI draft does not  adequately address IRI equality (not merely functional equivalence in  retrieval).  Moreover, the bidi section presents a learning curve which developers are  unlikely to want to climb before IRI has consensus around it; We have found  the text in Xlink section 5.4 and XML Erratum 26 adequately clear for some  of the IRI questions, particularly those  that are most pressing for RDF and believe that charmod should merely:  - reiterate such text;  - reiterate the early uniform normalization model for the iris when  regarded as unicode strings  -  note that section 8 will be superseded by IRI-draft when it becomes a  recommendation.    ===============    I am independently raising some very minor editorial issues.    Jeremy                text/html attachment: charcomments.html          

          Brian    may I suggest a process for the reification discussion.    We now have some idea of the entailments we are discussing.    I think it is important that we do not vote on these inidividually, and  potentially end up with a self-contradictory set of statements (logic is not  democratic).    I think we should instead try to group sets of answer to the entailments in  two (or maybe three) consistent positions and then have a straight vote to  decide between them.    e.g.    A Stating reading, for the use-case of provenance, having the following  entailments hold:  ???  and having the following entailments not hold:  ???      OR    A Statement reading, for maximum consistency with para 162 and 163 of M&S,  having the following entailments hold:  ???  and having the following entailments not hold:  ???      OR    [...]        My own position is having no entailments hold, which I currently think of as  the Stating position.    In summary, I think we should have a statings versus statements show-down,  using the entailments to help clarify what each position means.        Jeremy        

          I am having a lot of difficulty in understanding the problems that Pat and   Patrick see with bootstrapping, and needing to distinguish asserting (by   the publisher) from affirming (by anyone). I don't see why bootstrapping   stands outside the normal MT.    Here is my understanding of a SemWeb agent A007    A007 has access to a set of named graphs.  (e.g. from a SemWeb Crawler where each name is a URL and each graph is   given by the RDF/XML at that URL, or from some Trix files or whatever).      A007 has access to a set of named graphs.  e.g.    using some of Patrick's example, or Chris's example, ...    > :X  > {  >   :X trix:assertedBy ex:Bob .    >   :X trix:signature "..." .          -> verifiable signature   > for :X+ex:Bob  > }  >   > :Y  > {     >   :X trix:assertedBy ex:Jane .    >   :Y trix:asserted "true"^^xsd:boolean .      -> authoritative assertion   > of :Y  >   :Y trix:assertedBy ex:Jane .           >   :Y trix:signature "..." .                   -> verifiable signature   > for :Y+ex:Jane  > }  >   > :Z  > {  >   :X trix:asserted "false"^^xsd:boolean .     -> third-party   > non-assertion of :X  >   :Z trix:asserted "true"^^xsd:boolean .      -> authoritative assertion   > of :Z  >   :Z trix:assertedBy ex:Bill .                -> authority for :Z  >   :Z trix:signature "..." .                   -> verifiable signature   > for :Z+ex:Bill  > }  >     etc.    I would ideally want the trix:asserted predicate to be say trix:affirmed,  and have an agent URL as its object.    We also want to have signatures in there, which as patrick points out are   functions of agents+graphs    We also may want to have verification chains of agent identities (including   their public keys, as already available as part of Public Key infrastructure)    We may also want to have some verifiable relationships between URLs and   agents, indicating ability to publish. To some extent this information is   already public - registries of who owns which domain name linked with   public key registries. To some extent this is simply more meta-information.    In keeping with Chris's view, just how much of this A007 chooses to use is   A007's business, and not fundamental.    So    Assume A007 has a policy of trust anything for which he can identify a   party to sue. (I think this is implicit in Pat's view of publication).    The algorithm used by A007 may work like this:    1) Non deterministic choose a named graph g from the input    2) Hypothesise g provisional adding it to A007's knowledge base KB    3) If g trix:affirmedBy UUU (is a consequence of KB) where UUU is an   identifiable party, and all the signatures are good (a signature by UUU   affirming g, and a trusted chain of signatures, from some root body such as   verisign or microsoft, affirming the public key and identity of UUU), then   the hypotesis is good and we confirm g in the knowledge base.      Otherwise fail, and go back to 1, for a different choice of g.    4) If knowledge base is contradictory then someone is lying and A007   engages lawyers, otherwise repeat from 1, to add more graphs to the   knowledge base    5) Terminate when no more graphs can be added.      (Sorry algorithm is somewhat unpolished)  Note - the only way that graphs have any meaning is in step 3, which uses   RDF MT.  Also note - actually having signed graphs in there is not going to happen   by accident.    A more conservative A008 can require at step 3 that the agent UUU has   publication rights over the URL naming g. (And that these publication   rights are known, signed and verified).    The whole things gets off the ground by the usual public key trick of   having some well-known facts, like the public key of verisign.      I also believe that, in practice, most SemWeb applications can be less   paranoid, and could use a policy of say, believe anything your friends say,   where your friends are as defined in your own local foaf file. Also the dig   sig stuff is only relevant if handling financially relevant material; and   even then not very - just knowing that the URL were appropriate is   typically enough (e.g. I jsut spent ?100 at www.ryanair.com, with only DNS   to convince me that I as really dealing with the same people who have   previously carried me on an aeroplane - possible target of fraud, in   practice fraudsters find easier or bigger targets)    In this framework asserting some RDF is simply about how much trouble you   are prepared to go to in order to convince your reader.    If the RDF is not intended as commerically relevant, the answer is probably   very little, so just adding a single triple saying you affirm it, is enough   for a minimalist trusting algorithm.  If the RDF is adevertising a webservice with Ts&Cs then we wheel out the   PKI machinery, and make sure that a paranoid customer can check everything.    So every act of publishing is an assertion, but we can make more forceful   assertions or less forceful ones depending on how we do it. I guess it is   useful to have some way of explicitly marking a graph as false (seems a bt   strong) or unaffirmed by the author (my preference). Notice that the   algorithm above works fine to permit third party affirmation even with   author denial, and the third party is liable not the author.    Jeremy        

      Summary: warm fuzzies agreeing with much of Graham's analysis.  Status:  skippable.    Jeremy:  > >TDL allows clarity about this distinction, and allows query  > researchers to  > >explore both possibilities.  Graham:  > So does S.  In the case of S, the method used (value or literal) is  > explicit in the vocabulary used.  (For me this is an observation, not a  > show-stopper either way.)      This is nice it gives one possibly factor in deciding for S or TDL.    - S expects/requires the document author to determine whether the value or  literal is used.  - TDL expects/requires the RDF processing to determine whether to operate on  the value or literal.      Jeremy:  > >Thus, S-B maintains a theoretical purity by pushing all typing  > problems into  > >the application layer.  Graham:  > Yes, this is true.  And I do think that early deployment of RDF into  > applications will require this kind of approach, in some form or  > another.  Applications that take datatyping and generic inference more  > seriously should probably not use this idiom.  >  > Idiom B allows RDF to be presented to developers as a kind of  > stylized XML  > -- at worst, mostly harmless and a painless way to accommodate the more  > advanced technology geeks like me.  >  > (This is a re-run of an argument I've made previously about  > deployability,  > in another context.  In a sense, idiom B could be our Trojan Horse for  > getting RDF compatible formats into XML applications.)  >    I suppose I see idiom B as more than this.  I think idiom B has been, and will remain, the basic most widely used RDF  idiom. Hence I am deeply concerned to actually *do* RDF datatyping for this  idiom rather than punt it into the application space. This may be a key  difference between our positions.      > >So, S-B is seriously flawed in that it does not assist the application  > >developer to avoid logical errors associated with datatyping.  >  > OR: S-B is powerful, because it allows the datatyping issues to be  > deferred, avoiding having to burden the developer with the  > logical details  > of datatyping.    OK there's more than one way to perceive it.    >  >  > >=====  > [...]  > >So TDL assists the application developer in being logically correct.  >  > I think you've argued convincingly that TDL has certain advantages, *if*  > TDL can be deployed in a way that is broadly compatible with  > existing practice.  >  > However, I don't think you've successfully argued that these  > considerations  > make S unworkable.    OK - I am increasingly convinced that any one issue with S by itself is not  a complete showstopper; but I find the weight of issues compelling.    Jeremy        

        > > Last para 2.2, keep in main body of doc.  >   >   > Do you mean the reference to RDF/XML, or the material on QNames?  >     The para I scribbled a tick against reads:    [[ RDF defines a specific XML ... more detail in Section 3. ]]    Jeremy        

          I am having trouble recreating your bugs.    I have just done an almost clean install in the following fashion.    (Using an old version of tomcat with Java 1.4.?)    1: downloaded into clean CVS a load of WWW  WWW/2002/03owlt  WWW/2001/sw/WebOnt  WWW/2002/07/owl.txt  WWW/2000/10/rdf-tests/rdfcore    2: changed WWW directory in CachedURL to point to new dir    3: downloaded new jdk 1.4.1 from sun and recompiled the sources in the  editors-draft directory    4: made a symbolic link from 03owlt/editors-draft to tomcat/webapps/wowg    5: started tomcat    And it seems to work.    The bug below looks like you've got an old version of jena on the class  path.    The server I have got up and running is  http://sealpc09.cnuce.cnr.it:8080/wowg/jsp/main.jsp    With the local directory fix it works much faster.    Jeremy        > -----Original Message-----  > From: Jos De_Roo [mailto:jos.deroo.jd@belgium.agfa.com]  > Sent: 19 December 2002 15:47  > To: jjc@hpl.hp.com  > Cc: www-archive@w3.org  > Subject: TEST: WebOnt testcases  >  >  > Hi Jeremy,  >  > using http://www.w3.org/2002/03owlt/editors-draft/WEB-INF/lib/jena2.jar  > with OUT N3  > we get for http://www.w3.org/2002/03owlt/cardinality/premises005  >  >  > [[[  > http://jena.hpl.hp.com/arp/not/a/real/uri/[28:9]: {W103} Creating  > statement  > for unknown RDF property: 'rdf:datatype'.  > http://jena.hpl.hp.com/arp/not/a/real/uri/[28:9]: {E201} Syntax error when  > processing "1".  > Encountered "1" Was expecting one of:  >     XML comment  >     processing instruction  >     end element tag  >     property attributes  >     attribute rdf:type  >  > @prefix daml:   <http://www.daml.org/2001/03/daml+oil#> .  > @prefix rdf:    <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .  > @prefix log:    <http://www.w3.org/2000/10/swap/log#> .  > @prefix rdfs:   <http://www.w3.org/2000/01/rdf-schema#> .  > @prefix :       <#> .  >  > <http://www.w3.org/2002/03owlt/cardinality/premises005#c>  >       a     <http://www.w3.org/2002/07/owl#Restriction> ;  >       <http://www.w3.org/2002/07/owl#cardinality>  >             [ rdf:datatype  >  > "http://www.w3.org/2001/XMLSchema#nonNegativeInteger" ]  > ;  >       <http://www.w3.org/2002/07/owl#onProperty>  >             <http://www.w3.org/2002/03owlt/cardinality/premises005#p> .  > ]]]  >  >  > is there a workaround?  > haven't checked WebTriples.java though...  >  > -- ,  > Jos De Roo, AGFA http://www.agfa.com/w3c/jdroo/  >  >  > PS for the servlet problem, I found some additional logging in tomcat  >  > [[[  > 2002-12-19 12:48:13 Parse Fatal Error at line 551 column 44: The string "  > --" is not permitted within comments.  > org.xml.sax.SAXParseException: The string "--" is not permitted within  > comments.  >            at  > org.apache.xerces.util.ErrorHandlerWrapper.createSAXParseException(Unknown  > Source)  >            at  > org.apache.xerces.util.ErrorHandlerWrapper.fatalError(Unknown  > Source)  >            at org.apache.xerces.impl.XMLErrorReporter.reportError(Unknown  > Source)  >            at org.apache.xerces.impl.XMLErrorReporter.reportError(Unknown  > Source)  >            at org.apache.xerces.impl.XMLScanner.reportFatalError(Unknown  > Source)  >            at  > org.apache.xerces.impl.XMLScanner.scanComment(Unknown Source)  >            at org.apache.xerces.impl.XMLDTDScannerImpl.scanComment(Unknown  > Source)  >            at org.apache.xerces.impl.XMLDTDScannerImpl.scanDecls(Unknown  > Source)  >            at  > org.apache.xerces.impl.XMLDTDScannerImpl.scanDTDExternalSubset(Unknown  > Source)  >            at  > org.apache.xerces.impl.XMLDocumentScannerImpl$DTDDispatcher.dispat  > ch(Unknown  >  > Source)  >            at  > org.apache.xerces.impl.XMLDocumentFragmentScannerImpl.scanDocument(Unknown  > Source)  >            at org.apache.xerces.parsers.DTDConfiguration.parse(Unknown  > Source)  >            at org.apache.xerces.parsers.DTDConfiguration.parse(Unknown  > Source)  >            at org.apache.xerces.parsers.XMLParser.parse(Unknown Source)  >            at org.apache.xerces.parsers.AbstractSAXParser.parse(Unknown  > Source)  >            at javax.xml.parsers.SAXParser.parse(Unknown Source)  >            at javax.xml.parsers.SAXParser.parse(Unknown Source)  >            at org.apache.struts.digester.Digester.parse(Digester.java:755)  >            at  > org.apache.struts.action.ActionServlet.initServlet(ActionServlet.j  > ava:1434)  >            at  > org.apache.struts.action.ActionServlet.init(ActionServlet.java:474)  >            at  > org.apache.webapp.admin.ApplicationServlet.init(ApplicationServlet  > .java:152)  >  >            at javax.servlet.GenericServlet.init(GenericServlet.java:256)  >            at  > org.apache.catalina.core.StandardWrapper.loadServlet(StandardWrapp  > er.java:924)  >  >            at  > org.apache.catalina.core.StandardWrapper.load(StandardWrapper.java:813)  >            at  > org.apache.catalina.core.StandardContext.loadOnStartup(StandardCon  > text.java:3342)  >  >            at  > org.apache.catalina.core.StandardContext.start(StandardContext.java:3534)  >            at  > org.apache.catalina.core.ContainerBase.addChildInternal(ContainerB  > ase.java:821)  >  >            at  > org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:807)  >            at  > org.apache.catalina.core.StandardHost.addChild(StandardHost.java:579)  >            at  > org.apache.catalina.core.StandardHostDeployer.addChild(StandardHos  tDeployer.java:529)  >  >            at java.lang.reflect.Method.invoke(Native Method)  >            at  > org.apache.commons.beanutils.MethodUtils.invokeMethod(MethodUtils.  > java:228)  >            at  > org.apache.commons.digester.SetNextRule.end(SetNextRule.java:260)  >            at  > org.apache.commons.digester.Digester.endElement(Digester.java:1036)  >            at  > org.apache.xerces.parsers.AbstractSAXParser.endElement(Unknown Source)  >            at  > org.apache.xerces.impl.XMLDocumentFragmentScannerImpl.scanEndEleme  > nt(Unknown  >  > Source)  >            at  > org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$FragmentCont  entDispatcher.dispatch(Unknown  >  > Source)  >            at  > org.apache.xerces.impl.XMLDocumentFragmentScannerImpl.scanDocument(Unknown  > Source)  >            at org.apache.xerces.parsers.DTDConfiguration.parse(Unknown  > Source)  >            at org.apache.xerces.parsers.DTDConfiguration.parse(Unknown  > Source)  >            at org.apache.xerces.parsers.XMLParser.parse(Unknown Source)  >            at org.apache.xerces.parsers.AbstractSAXParser.parse(Unknown  > Source)  >            at  > org.apache.commons.digester.Digester.parse(Digester.java:1514)  >            at  > org.apache.catalina.core.StandardHostDeployer.install(StandardHost  > Deployer.java:335)  >  >            at  > org.apache.catalina.core.StandardHost.install(StandardHost.java:803)  >            at  > org.apache.catalina.startup.HostConfig.deployDescriptors(HostConfi  > g.java:452)  >  >            at  > org.apache.catalina.startup.HostConfig.deployApps(HostConfig.java:409)  >            at  > org.apache.catalina.startup.HostConfig.start(HostConfig.java:879)  >            at  > org.apache.catalina.startup.HostConfig.lifecycleEvent(HostConfig.java:368)  >            at  > org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(Lifec  ycleSupport.java:166)  >  >            at  > org.apache.catalina.core.ContainerBase.start(ContainerBase.java:1196)  >            at  > org.apache.catalina.core.StandardHost.start(StandardHost.java:738)  >            at  > org.apache.catalina.core.ContainerBase.start(ContainerBase.java:1188)  >            at  > org.apache.catalina.core.StandardEngine.start(StandardEngine.java:347)  >            at  > org.apache.catalina.core.StandardService.start(StandardService.java:497)  >            at  > org.apache.catalina.core.StandardServer.start(StandardServer.java:2191)  >            at  > org.apache.catalina.startup.Catalina.start(Catalina.java:510)  >            at  > org.apache.catalina.startup.Catalina.execute(Catalina.java:400)  >            at  > org.apache.catalina.startup.Catalina.process(Catalina.java:180)  >            at java.lang.reflect.Method.invoke(Native Method)  >            at  > org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:203)  > ]]]  >  >        

            Lofton Henderson wrote:    > I know Karl has proposed (previous message in this thread) that the   > test-driven development of OWL specifications means, by definition, that   > you pass the checkpoint we're talking about.  >   > Without addressing at that view, I'd like to look at this from a   > different angle, starting with a clarification.  Again, these are my own   > views, as the QAWG has not yet taken up the question(s) you raise.  (But   > will do so in a near-future telecon.)  >   > At 09:07 PM 1/6/04 +0000, Jeremy Carroll wrote:  >   >> [...]  >> Test GL:  >> >> [[  >> >> Checkpoint 1.3. Analyze the structure of the specification, partition  >> >> it as appropriate, and determine and document the testing approach to  >> >> be used for the test suite as a whole and for each partition.  >> >> [Priority 1]  >> >> ]]  >>  >> This checkpoint defines method - the testing approach is determined as   >> a result of analysing the specification.  >> That might not be what the QAWG intends but that is what the current   >> WD and editors draft both say.  >   >   > We have been trying to move away from defining the method or process,   > which was prevalent in the earliest drafts.  Instead, we are trying to   > state the requirements in terms of testable characteristics of the test   > suite (TS).  >   > Note that the normative content of CP1.3 is not in the statement quoted   > above, but rather it is contained in the Conformance Requirements section:   >   >     "The scope, goal, and purpose of the test suite as a whole, and  >     where appropriate of each logical 'partition' of the test suite, and  >     the mapping between such partitions and sections of the  > specification, must be identified and documented"  >   > [Note.  This WG-only draft is raw, and "must" should be read as "MUST"   > -- i.e., that's a normative must above.]        That's much better - I still disagree with it :), but that seems more a   matter of opinion.    I would not object to such text. (I might have misunderstood the editor's   draft division between normative and informative)    >   > So we've improved the ConfReqs -- the only normative part of the   > checkpoint -- so they can now be read as testable conditions on a   > conforming conformance test suite.  [We should continue to align the   > CPs' statements, so they don't misleadingly suggest "process", and we   > should fiddle with the wording of the Rationale, for same reason.]  >   > You then said...  >   >> (So while the checkpoint above could be written more declaratively e.g.  >> "There should be a systematic relationship between the organization of   >> the test suite and the sections of the specification", this would   >> still have been a problem for RDF Core, in my view. Such a change,   >> while an improvement, does not go far enough to get my support).  >   >   > This is getting close to the ConfReqs for CP1.3, which are the normative   > parts of the checkpoint.  Except notice that CP1.3 ConfReqs only   > requires that the relationship be documented, whatever it is, whereas   > your proposed rewording seems to require a systematic relationship.    > (Since you said, "still a problem", I'm assuming that you're thinking   > that we intend to require that the structures be parallel, isomorphic,   > or something like that.  IMO, CP1.3 does not require that, but   > encourages its consideration by requiring documentation.)  >   > IMO, for the OWL TS to pass CP1.3 would be trivial, if indeed it doesn't   > already pass (as Karl claims) -- it would be a small addition (not even   > necessarily Normative), to the OWL TS document.  Maybe it's even already   > there?  (I read the document, but don't remember all the details).   >       I agree it would have been low cost for both SW WGs to have conformed with   that text, as long as 'partition' is understood as high-level partition   rather than low-level. (I think that's the intent - later text seems to go   for the detailed relationship between tests and test assertions).    In fact "each *high-level* logical 'partition'" might be appropriate text,   with informative examples of high-level.    I look forward to the next WD of the test work.      Jeremy        

          tbl:    >>> 2. The meaning of the statement is defined by the definition  >>> of the predicate, as applying to the subject and object identified by   >>> the  >>> definition of the subject and object terms.  >>>     >>  >>    Danbri:      >> This for me is the crux: do we mean the machine oriented 'definition'  >> in RDFS or OWL or N3, or some more rounded/scruffy/social notion of   >> definition.  >>        I find Bijan's observation compelling  [[  But there's no vague, much less precise, definition of "defining   information". And I'm a logical reasoner, will this information be opaque   to me? (Well, if in German, yes, but *all* human reasoners?)  [...]  So it's formal meaning isn't fixed IN ANY WAY by the "authority"? And the   social meaning?  ]]    Two points:  - "whatevers available" is simply not clear enough.  - RDF has decided to avoid the notion of definition for the formal   semantics, we shouldn't then have it in the informal semantics.    For me, either of these is fatal. This cat has had its nine lives.    Jeremy        

        Hi    From RDFCore's point of view I think the most important thing that happened  at WebOnt F2F was agreement that OWL will be based on RDF.    The meaning of an OWL document will be carried by the RDF graph.    Any RDF/XML serialization of such a graph will be an OWL document (i.e. no  syntactic restrictions).    It was also agreed to ask RDF Core for dark triples; I guess that will come  up at the coordination group.    I didn't give the initial feedback about end markers and collections because  the agenda didn't permit adequately.  hence I ask that we drop action  2002-04-05#12:  jjc to discuss at webont f2f the end-marker    A key thing that happened (less RDF Core centric) is that webont moved from  exploring the space, to beginning on an issue driven review of DAML+OIL.  Thus we may expect OWL to look much more like DAML+OIL than earlier  discussions suggested.    Jeremy        

        >  > Once the WG has pronounced on this new language compare, unlike any  > other in RDF in being case insensitive, we can move on.  >    My understanding of the LC specs is that:    - n-triples permits mixed case lang tags  - concepts says these represent lower case abstract lang tags    Thus the parser tests I have suggested should pass, (but I realise that that  is really a test on the equivalence function not the parser).    The entailment tests, on the other hand, are divorced from the case handling  in both RDF/XML and N-Triples.    So:  with the entailment tests:    > file1:  > <a> rdfs:comment "a"@en-us .  > file2:  > <a> rdfs:comment "a"@en-us .  > file3:  > <a> rdfs:comment "a"@en-US .  >  > Tests:  > file1 entails file2  > file2 entails file3  > file3 entails file1    We can leave it so that in a parser test case-sensitive comparison of lang  tags is OK, but still include these entailment tests that indicate that the  case is not significant to the meaning.    These three tests do not require any changes to any documents. Nor do they  require clarification of whetehr the parser tests use case sensitive or case  insensitive comparison of language tags.    Jeremy        

        This is another ARP test case, currently I issue a special warning message -  what is the correct behaviour?    Issue is rdf:ID="sw:test"    Jeremy      <!--      Test case for bug #74.    i.e. hp internal bugzilla #74      Correct treatment of ':' in ID ...      Note the spec is poor I am escalating this to the WG.    -->  <rdf:RDF  xml:base="http://example.org/bug74_0.rdf"  xmlns:sw="http://example.org/"  xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns#'>    <rdf:Description rdf:ID="one">   <sw:name rdf:resource="#sw:test"/>   </rdf:Description>  <rdf:Description rdf:ID="sw:test">  <sw:first_name>xxx</sw:first_name>   </rdf:Description>      </rdf:RDF>        

          > -----Original Message-----  > From: w3c-rdfcore-wg-request@w3.org  > [mailto:w3c-rdfcore-wg-request@w3.org]On Behalf Of Graham Klyne  > Sent: 30 April 2002 18:22  > To: Aaron Swartz  > Cc: RDF Core; Jeremy Carroll  > Subject: Re: Clarification of charmod-uri  >   >   > At 01:55 PM 4/29/02 -0500, Aaron Swartz wrote:  > >On 2002-04-29 05:49 AM, "Graham Klyne"   > <Graham.Klyne@MIMEsweeper.com> wrote:  > >  > > >> 1) Is there some reason why these Unicode characters cannot   > be %encoded? I  > > > The reason I heard was that the I18N group would like the   > user's original  > > > character input to be preserved as much as possible.  If   > %-encoding is  > > > applied, it's not possible to tell if the user supplied it of the   > > application.  > >  > >This doesn't make any sense to me. Why would the application introduce  > >%-encoded characters, and if it did, couldn't it introduce them   > even if the  > >URI was not %-encoded?  >   > What I was trying to say is that if the reading application is   > required to   > convert Unicode URIs to %-escaped form to satisfy a requirement for   > US-ASCII only in the RDF, then information about exactly what the user   > supplied is lost.  >   > (But I may well have misunderstood this ... I'm not set to defend this,   > just trying to explain what I thought I heard.)  >     This is a concern of the I18N guys.    Jeremy        

      The missing URL is:    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Mar/0129.html    and the minutes are now complete for consideration.    > (Patrick please send a URL for the XML datatyping examples to   > complete this  > draft)      > 12: Datatypes  > Action: 2002-02-26#8  PatrickS  Create XML examples for datatypes doc  >   > This action has been completed:  >   Missing URL  >         

        Dave:  > RDF/XML was designed well before qnames in attribute values started  > to be used in XML formats and we have never promised that it would be  > preserved.  We can give best practice, if we decide to go the C14N  > route, but not much more at this stage, without making too-large  > changes to the RDF/XML syntax.  >     Personally I agree with this.    I think Tom Passin's posting to rdf-interest     http://lists.w3.org/Archives/Public/www-rdf-interest/2002Mar/0088.html    could be the basis of a disclaimer text.      Jeremy        

          After chatting with Chris ...  >     Take 1:  > Abstract:  >   > The Semantic Web consists of many RDF graphs named  > by URIs. This paper discusses the syntax and semantics  > of such collections of named graphs. This enables  > improved clarity in  Semantic Web  > publishing, allowing publishers to communicate  > assertional intent, and to sign their graphs.  > Information consumers can evaluate specific graphs  > using task-specific trust policies, and act on the  > information from those named graphs that they accept.  >   >   Take 2:      The Semantic Web consists of many RDF graphs named  by URIs. This paper extends the syntax and  semantics of RDF to cover such collections  of named graphs. This enables RDF statements  that describe graphs, which can be used  in  many Semantic Web applications.  We explore in detail the important  application of  Semantic Web  publishing: named graphs allow publishers to  communicate assertional intent, and to sign  their graphs; information consumers can evaluate specific graphs  using task-specific trust policies, and act on the  information from those named graphs that they accept.  Graphs are trusted depending on: their content;  information about the graph; and the task the user  is performing.      (Chris noted that we needed to be clear that the paper is trying to rebuild   the RDF stack, and should be more explicit about the wide applicability).    Jeremy        

        > Hmmm... can we get away with saying something like: "graphs that differ  > only in the specific literal forms used to represent the same  > values may re  > regarded as interchangeable"?  (That's a fudge, I'm trying to  > stop short of  > saying they're equal, because that imposes a burden on  > applications to know  > about the datatypes.    I quite like this fudge.    I think Patrick exagerates the extent to which one shouldn't discard  original intent. (comments do get stripped). But given the decision that the  execution of the l2v mapping is outside of RDF (which I think sounded like  the majority opinion at the telecon), we can't use c14n inside equality.    Jeremy        

          >   > Datatypes: stake-in-ground vs simpledatatype2  >   > [yeah, I know, slap me...]  >   > Patrick    I regret that you weren't at the after hours conversation last  week.  I found it helpful, and thought Aaron's e-mail summarised what  I learnt:    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002May/0066.html    While I continue to support simpledatatype2 I believe that  the group should as much as possible concentrate on getting  the current datatype stuff out to the community as a WD.    As such, I would support the chair in stating that your  agenda request is about an issue that is currently not open.    Jeremy        

          >  > we have been testing/finding that  >  >   :road :repair "P1Y2M3DT10H30M"^^xsd:duration .  >   :testcase :made "2002-11-16T01:41:00+01:00"^^xsd:dateTime .  >   :john :birthday "1956-01-10"^^xsd:date .  >   :jenny :age "10"^^xsd:decimal .  >  > RDFS/XSD entails  >  >   :road :repair "P14M3DT10H30M"^^xsd:duration .  >   :testcase :made "2002-11-16T00:41:00Z"^^xsd:dateTime .  >   :john :birthday "1956-01-10T+02:00"^^xsd:date .  >   :jenny :age "1E1"^^xsd:decimal .  >  > Jan/Dave is this useful as a testcase?  >  >    Could I suggest 4 test cases, one for each triple.  For a developer implementing XSD being able to see progress:  on Monday they  do decimals (1/4), Tuesday they do dates (2/4), Wednesday they do dateTime  (3/4), Thursday they do duration (4/4), and Friday they have a party!    Jeremy        

        > I expect I need to change the definition of N-Triples in order to  > express a resolution of rdf-charmod-uri since I noticed you (Jeremy)  > used examples such as:  >   <http://example.org/#Andr\u00E9> <owes> "2000" .  >  >   -- http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Apr/0113.html  >  > which is currently not allowed.  >    Yes, if my proposal is accepted a side effect would be a necessity of asking the N-triples editor to propose a suitable change to  N-triples. The test cases may then need modification to reflect that change, (they currently second guess the editor's discretion).    Jeremy        

        Dave  >>   We aren't normative on charmod.  or c14n?  Graham  > Currently, we *are* normative on these.    Dave we did for a while have a crossed wire in the doc where we were citing  c14n rather than xc14n, that may have been your point of confusion on that  one.    (xc14n depends on c14n so either way we *are* dependent on c14n :( ).    Jeremy        

        I concur with Aaron's comments:    > I remember three bullet  > points: [..], putting a "here be dragons"  > warning in the appropriate spec [...]      Graham's text did not IMO meet that part.  I am not sure whether dragons get into the primer.  If so, how about:    >  > <<<START>>>  >  > Fragment identifiers, when used with RDF, are treated as a simple  > extension  > of the URI to which they apply, whose interpretation is not dependent on  > the context in which they appear.  This reflects the fact that  > there is no  > special treatment of the fragment identifier part of URIrefs in the model  > theory for RDF -- that is, they are simply a syntactic part of a  > name that  > denotes some resource.  >  [[[ DELETE:  > There is sometimes an unwarranted expectation that the thing  > identified by  > a URI with fragment identifier bears some particular relationship to the  > thing identified by the URI alone.  ]]]  [[[ ADD:  In standard usage, the representation accessed by a  URL with a fragment  identifier  <em>is</em> dependent upon the representation accessed by the  URL alone.  However,  in RDF, the thing identified by a URI with fragment identifier <em>does  not</em>  bear any particular relationship to the thing identified by the URI alone.  ]]]    > For example, the RDF statement:  >  >     urn:isbn:0-520-02356-0#page10 ex:contains "metatheory" .  >  > might be regarded as having a particular relationship to the statement:  >  >     urn:isbn:0-520-02356-0 dc:title "Metalogic" .  >  > but this would be an error.  As far as RDF is concerned,  > 'urn:isbn:0-520-02356-0#page10' and 'urn:isbn:0-520-02356-0' are two  > different names with no defined relationship.  This is different from the  > normal use of fragment identifiers when retrieving web documents,  > where the  > URI with fragment identifier is taken to represent some view of the  > document referenced by the URI alone.  >  > This is not to say that a URI and that URI with fragment identifier may  > never be related, just that no such relationship is presumed by  > RDF.  Returning to the example above, it is quite possible that some RDF  > document defines a relationship between these terms:  >  >      urn:isbn:0-520-02356-0 rdf:type ex:Book .  >      urn:isbn:0-520-02356-0 dc:title "Metalogic" .  >       :  >      urn:isbn:0-520-02356-0 ex:consistsOf _:a .  >        _:a rdf:type rdf:Seq .  >        _:a rdf:_1 urn:isbn:0-520-02356-0#page1 .  >        _:a rdf:_2 urn:isbn:0-520-02356-0#page2 .  >         :  >        _:a rdf:_10 urn:isbn:0-520-02356-0#page10 .  >         :  >        (etc.)  >  > This RDF graph makes specific assertions about relationships  > between things  > denoted by the URI and URI-with-fragment-identifier.  >  [[[ DELETE:  > Finally,  ]]]  > [N]ote that in the special case of a document containing RDF/XML  > statements (MIME type application/RDF+XML???), the syntax presumes a  > convention for relating the document name to the resource names whose  > definitions it contains.  Specifically, resources described using an  > rdf:ID='...' attribute have an identifier that consists of the  > RDF document  > URI plus a fragment identifier of the given rdf:ID attribute value.  But  > observe that this is a purely syntactic convention, and does not  > of itself  > presume any semantic relationship between the defining document and the  > thing defined.    [[[ADD:  Finally, other non-RDF components of a system may expect to be  able to treat a URI with fragment identifier in a manner similar to  the treatment of a URL with fragment identifier used for document  retrieval over the web. This may lead to interoperability problems.  ]]]  >  > <<<FINISH>>>  >  >  >  > ------------  > Graham Klyne  > (GK@ACM.ORG)  >  >        

        At the f2f one of the postponed issues that I wished to advocate reopening was:    http://www.w3.org/2000/03/rdf-tracking/#rdfms-syntax-incomplete    In particular, given the amount of change we have made I think a small change to  rectify the bnode serialization problem should be considered.    However we were out of time, and so I have decided to raise this by e-mail.    This is primarily motivated for me by Jena development.  Within Jena we have repeated user requirement to enable round-tripping.    e.g. one of our summer students yesterday said words like: "we use N-triple as  our transport becuase bNodes are important."    Since we are not proposing N-triple as a standard, we do have some obligation to  make RDF/XML useable.    I propose that we should modify the RDF/XML syntax to permit bNode labels  "_:foo" wherever we currently permit URI refs.    This still leaves non-standard property names as non-serializable, but that is  much less of a problem in practice.    Jeremy      More detail:    Modify:  [[[  5.23 Production URI-reference  An attribute ?string-value? interpreted as a URI reference defined in Uniform  Resource Identifiers (URI) [URIS] BNF production URI-reference.  ]]]    uses of URI-reference should have the name changed to resource-reference and  then      Production resource-reference    URI-reference|bNode-reference      Production URI-reference    as before      Production bNode-reference    An attribute ?string-value? matching "_:<NCName>". (where NCName is the  production from XML Namespaces). The string value gives a bNode identifier with  file scope as for NTriple.                      by using two productions (the current URI reference        

          I am not very up on GRDDL but get the impression that you are not using the   stylesheet PI, despite it having been explicit created to give an XML   mechanism corresponding to the HTML link attribute ....    [[  Style Sheets can be associated with an XML[XML10] document by using a   processing instruction whose target is xml-stylesheet. This processing   instruction follows the behaviour of the HTML 4.0 <LINK   REL="stylesheet">[HTML40].  ]]    As is, any XML format wanting to use the grddl attribute has to explicitly   permit it, whereas PIs can be added to any format.    Jeremy    http://www.w3.org/TR/xml-stylesheet/        

          >  >  > >And I buy Guha's point at the Bristol F2F that with untidy  > literal semantics  > >rdf:object refers to the syntax of the triple not its semantics.  >  > That is reopening an old issue where I believe we have already  > decided the  > value of the reification properties do not denote the syntax.  >  > Are you suggesting this treatment be special for rdf:object?  > Just when it  > takes a literal value?    No, I think you have misunderstood. I am not reopening any issues.    In    <rdf:Description rdf:ID="subj" >    <eg:p1 rdf:ID="statement">10</eg:p1>    <eg:p2>10</eg:p2>  </rdf:Description>    There are three triples with "10" as object:    <#subj> <eg:p1> "10" .  <#subj> <eg:p2> "10" .  <#statement> <rdf:object> "10" .    My understanding of the model theory (any version) is that nothing special  links the interpretation of the "10" in the third triple to the  interpretation of the "10" in the first, which is not also true of the  second.    i.e. in a tidy model theory all three "10"'s are "10"; in an untidy model  theory all three "10"'s are unconstrained.    Jeremy        

            Dave Beckett wrote:    > The first question from  >   http://lists.w3.org/Archives/Public/www-rdf-comments/2003JanMar/0226.html  > is basically, does anyone use bagID?   >   > I know the CARMEN project / MathNet uses bagID with RDF/XML and  > Dublin Core.  See the PDF report from Feb 2002   >   http://www.mathematik.uni-osnabrueck.de/projects/carmen/AP6/zwischenbericht_ap6.pdf        I think this document enhances Tim's case.    The only occurrence of bagID in the doc is to create a bag that has a   matching aboutEach - which we axed.    Moreover, judging from the surrounding RDF/XML the document author appears   to want every triple generated within the XML element to be reified into   the bag, rather than only the toplevel triples (as we clarified).    i.e. this document shows a use of a construct that is not bagID which is   useful with a construct which is not RDF.    bagID was an ugly sibling to aboutEach and should have been chopped at the   same time.    Jeremy axeman Carroll        

      >  > 13: Internationalization      Fine.      >  >  > 14: IRI's  > Wheras nodes in an RDF graph are labelled with URI's and the  > standards for internationalization of URI's are not yet stable  >  > Propose the WG:  >  >   1) resolves that nodes in RDF graphs are labelled with standard  > web identifiers  >  >   2) resolves that the current standard web identifier is a URI  > as defined by RFC 2396  >  >   3) resolves that resolution 2 above may be updated by an errata  > to the specifications as new standards evolve.  >    This is unclear. First my counterproposal, second a critique of the chair's  proposal.    Counterproposal.     Propose the WG:       1) resolves that nodes in RDF graphs are labelled with standard        web identifiers       2) resolves that the current standard web identifier is a URI        as defined by RFC 2396, in its original character sequence        (in UTF-8)       3) notes that the use of identifiers of resolution 2 that are        not in normal form C presents internationalisation        difficulties and security risks       4) resolves that resolution 2 above may be updated by an errata        to the specifications as new standards evolve.       5) that equality between the identifiers of resolution 2 is        binary identity.      The chair's proposal is unclear:     + RFC 2396 talks about both "original character sequences" and percent  encoded URIs. The proposed resolution (2) does not disambiguate,  particularly given the web context.     + M&S undoubtedly licenses some use of non-US ascii URIs e.g.  http://www.w3.org/2000/10/rdf-tests/rdfcore/rdfms-difference-between-ID-and-  about/test2.rdf    <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">   <rdf:Description rdf:ID="Durst">    <rdf:value>abc</rdf:value>   </rdf:Description>  </rdf:RDF>    e.g.  <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"           xmlns:eg="http://example.org/it#">     <eg:Paghero rdf:about="http://example.org/fraudulent.html">        <eg:ricevera rdf:resource="mailto:Jeremy_Carroll@hp.com"/>     </eg:Paghero>  </rdf:RDF>     + M&S plausibly currently indicates that these should not be % escaped for  the purposes of constructing the graph.    See:  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Mar/0012.html    Since the last point is based on what XML has to say about URIs it is at  least plausible that this is a standard usage of web identifiers!    Jeremy    PS There has been off-list traffic between me and Brian in which I have  expressed the opinion that:  - the IRI part of charmod is unstable.  - currently the IRI part of charmod depends on an IRI draft by Masinter and  Durst  - that IRI draft is also unstable    This is in contrast with the NFC requirement on literals which has been a  stable requirement from the last several revisions of charmod.    As far as I can tell there is a genuine difference of opinion between us as  to how to respond to the lack of stability from I18N. My view being that we  have to respond to our I18N responsibilities independently of the stability  of other standards, I would strongly resist a minimalist US ascii only  resolution.        

          Joe Reagle has made some helpful comments reviewing our use of XML C14N:    http://lists.w3.org/Archives/Public/www-rdf-comments/2003JanMar/0128.html    In my reply,  http://lists.w3.org/Archives/Public/www-rdf-comments/2003JanMar/0162.html  I suggest he is raising two issues -    Problems to do with equality of XMLLiteral.  and    confusion about the use of C14N or EXC-C14N    Both arise from the desire we had when we finalized this design (in Cannes)  to not rule out certain difficult cases.  These are illustrated by the following example which embeds a piece of XSLT  in RDF:  http://lists.w3.org/Archives/Public/www-webont-wg/2003Jan/att-0532/01-msg#I5  .4-002    <rdf:RDF      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"      xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"      xmlns:owl="http://www.w3.org/2002/07/owl#"      xmlns:first="http://www.w3.org/2002/03owlt/I5.4/consistent002#"      xml:base="http://www.w3.org/2002/03owlt/I5.4/consistent002" >      <owl:DatatypeProperty rdf:ID="p"/>      <owl:FunctionalProperty rdf:about="#p"/>      <owl:Thing rdf:ID="i">         <first:p rdf:parseType="Literal"          xmlns:eg="eg:a"><xsl:template match="eg:foo"/></first:p>         <first:p rdf:parseType="Literal"          xmlns:eg="eg:b"><xsl:template match="eg:foo"/></first:p>      </owl:Thing>  </rdf:RDF>      The fragment <xsl:template match="eg:foo"/> uses the namespace prefix eg but  not visibly.  The position in the LC WDs is that implementations which wish to be clever  can correctly preserve the namespace, but this is not REQUIRED.  e.g. using ARP the following fragment preserves the namespace binding for eg    <owl:Thing rdf:ID="i">    <first:p rdf:parseType="Literal"     ><xsl:template match="eg:foo"       xmlns:eg="eg:a"/></first:p>      However, this is not interoperable.    Moreover, the position taken causes interoperability problems also in the  easier cases e.g.    http://lists.w3.org/Archives/Public/www-webont-wg/2003Jan/att-0532/01-msg#I5  .4-001      (this case is non-interoperable even without the comment, because of the rdf  namespace which optionally can be included in the literal value).    ==    In summary, I think we should think again about whether we made the right  trade off between the desire to not rule out advanced uses (embedding XSLT,  XML Schema's and xsi:type attributes) and good solutions to the simple case  (XHTML).    Jeremy        

            The chair asked for stuff for the f2f.    Here's my take.    A. We clearly need to close as many of the remaining issues as possible.    B. Review of Datatypes WD     - we should publish a datatypes WD straight after the f2f.    C. Document structure     - we should review whether the current arrangement of material to  documents is the one we wish to take to last call and rec.    D. Document review - maybe not suitable for f2f.    - we should have a more detailed review of the documents than we have  had to date.      e.g. on the syntax we could work through the rules one-by-one to  check that it is clear what they do, rather than merely check that what  they say is what we agreed.    E. reassessment of closed issues     I think we have got to a point where we have basically finished.     Many issues interrelated, and we closed some issues earlier and  others later.     I think it would be good to take stock, and to see whether it is  clear that we have made any mistakes.     Some issues I think got postponed because we believed we were not  making any changes; but actually we have made more changes than we might  have done. Some things we did not think about addressing might have  obvious fixes that we should, with hindsight, do.    Issues in my mind include:    - rdfms-syntax-incomplete    - should a literal's structure be represented in the graph (e.g.  xml:lang)        The difficulty is how to refresh our minds about closed issues without  letting everything cave in.    A possible mechanism might be to allow people to propose concrete  changes, with five minutes to explain, and then a straw poll to  determine whether we want to discuss it.      Jeremy        

            > Greetings.  >  > Y'all are going to just LOVE me for this,    Lot's and lots.    (While I personally like that design - it is the wrong time for this  proposal).    Hence I will pick holes:            > aaa ppp "sss"@ttt .  > -->>  > aaa ppp _:x .  > _:x xsd:string "sss" .  > _:x rdf:langTag "ttt" .  >  > Note that xsd:string is the appropriate datatype for simple literals,  > providing a way to in effect put a simple literal string in the  > subject position (encoded as a bnode). In fact, in this design,  > xsd:string is in effect owl:sameAs applied to literals.    No that last bit is incorrect - the blank node _:x has language ttt whereas  the string sss does not.    The additional blank node was at the heart of the untidy proposals (either  explicitly or implicitly) and this proposal is essentially untidiness  revisited.      Jeremy        

          This feels like a personal comment, but I would be happy if others in  the WG wished to support it.    [[[[    Charmod does not conform with itself.    This is intended as an issue with sections 1 and 2  concerning the scope and applicability of charmod,  and I apologize for the rather smartass way of  articulating it.    The exposition of the issue follows the mathematical  style known as "reductio ad absurdum", the contradiction  being the above.    A particular non-conformance is that charmod  puts no obligations upon implementors of charmod.  It, does, of course, indirectly place many obligations  on implementors of other W3C recommendations.  An argument that charmod will have no (direct) implementors  would be disingenious. e.g. I would expect/hope library  writers to provide a function that checks that  unicode strings are in normal form c and do not  start with a composing character.  Such an implementor would be able to claim charmod  conformance without having been specifically obligated with    [I] Specifications and software MUST NOT assume a one-to-one mapping  between character codes and units of displayed text.    since charmod has failed to say that implementations of charmod must    [S] Every W3C specification MUST ...  specify that implementations MUST conform to the requirements applicable  to software,    I find a similar problem when drafting text  for the current round of RDF recommendations.  Charmod is framed such that for charmod conformance  a W3C recommendation must have a dictatorial relationship  with its implementators. The RDF recommendations  are more relaxed about their power. They define  RDF documents and their meanings. They do not  indicate what implementators should do, nor do they  tell content writers what to do. It is difficult  to keep reinterpreting the requirements of charmod  into this less confrontational style of recommendation.  This is made more difficult by charmod's own  confrontational style, and expectation that  other recommendations share such a stylistic  preference.      I believe that the charmod editors are trying to  say something that is both meaningful and has my  support.  I fear that the framing of the scope of charmod  in sections 1 and 2 has not done justice to the  range of recommendations produced by the W3C  nor the range of different relationships  between recommendations and their users (both  implementors and content producers).    ]]]        

        >>3. perspecuity: it should be easy to look at and understand a model.   >>Some 'correct' approaches may be very convoluted, but this make them   >>less desirable.  >   >   > well, this one I guess I agree with, but of course Ian has lots of   > examples of things that would be easy to say in OWL Full (like the   > metamodeling itself) that require much less perspicuous   > representation in DL - in fact, the OWL Guide is full of them --   > however, other people argued to me that making the representation   > easier for machines to reason over was more important than having the   > model be human understandable..    I am one of the latter (people who argue that it must be easy for machines).      > p.s. Someone offered me a great analogy the other day - he showed me   > some papers from early 90s hypertext conference than basically   > recommended that you don't link to things off your own web site, as   > this could lead to 404 and other unanticipated errors (and showed   > empiricially that this was the case).  Of course, in a certain sense   > that is a good hypertext best practice, but it turned out to be a   > laughably foolish one for the Web -- let's try to avoid having people   > laugh at us ten years from now...      I think that people's height or people's age might fall into this category.    Many people, particularly important people, will spread disinformation on   these basic issues.  Thus in the virtual world it perhaps is simply not the case that people   have a unique height or a unique date-of-birth; virtual people are more   ambiguous than real people.    My seven year old son has worked that out: he now has three or four   different identities at lego.com; he's still shying from making one of them   female but, he will get there soon.    (You may note that my view of the Semantic Web is a virtual world, not   dependent on an underlying physical world in which Osama bin Laden does   have a unique height and my son does have a unique gender: I should   probably try and articulate that within the work of Baudrillard or Derrrida   but ...)    Even if Jim's funders could find the man and took TV pictures of him   standing upright with a ruler (showing *the* correct height), many people   (outside the US) would still be suspicious and suggest that the pictures   were faked. I don't think it is possible to successfully and convincingly   validate the virtual world against a real one.      Jeremy        

        (you were right Libby I had missed this one, thanks for it)      Shall we just go with that ... I would be surprised if it's not too small  ...    Jeremy        > -----Original Message-----  > From: Libby Miller [mailto:Libby.Miller@bristol.ac.uk]  > Sent: 12 September 2002 21:31  > To: Jeremy Carroll  > Cc: Libby Miller; www-archive; julie_lanfear; sb; david_trastour; danbri  > Subject: RE: F2F social arrangements  >  >  >  > I popped in to Seely's on the way home, and it seems quite nice.  > unfortunately they don't do any food (restaurant or bar food) on a  > Sunday evening. I think this is a problem, as people will be arriving  > hungry as well as thirsty...  >  > I'd go for the Hope and Anchor on Jacobs Wells road, who serve food till  > 9.30 on a sunday. But it might be too small, I dunno...  >  > [[  > Hope and Anchor (38 Jacobs Wells Road, Hotwells, Somerset) (0117)  > 9292987. This pub is close to the water on the edge of town opposite  > Constitution Hill. It doesn't look much from the outside with plain big  > windows and half curtains, but don't be fooled as the inside is all  > traditional wooden floors chairs and tables. Some pews and a secluded  > area for two in a corner near the beer cellar on the way to the toilets.  > The 'L' shaped bar (round to right on entrance) has old hops around it  > and the bar back is ancient 1950's. They usually have five beers on but  > only three when visited: Otter Bitter, Butts Barbus Barbus, and  > Feilinfoel Double Dragon. Food is served all day and is rather sumptuous  > with Falafel, chicken and many sandwiches. The ploughman's is famous  > round these parts and you have a choice of over 15 different cheeses,  > spicy chicken and pate to have with it. It comes not on a plate, but a  > carving plate! It comes in at just 5.75. There are also a good few  > choices for veggies. That said it's not a family pub. The secluded  > raised beer garden (with lots of steps) out back is good for the summer.  > Disabled access is possible, though the toilets are small and narrow.  > Look out for the pub cat. No accommodation here but try: Oakfield, 52/54  > Oakfield Road, Bristol, BS8 2BG. 1 km from the centre of Bristol. Price  > 21-30 for en-suite.  > ]]  >  > http://www.beerguide.co.uk/towns/bristol.htm  >  > Libby  >  > On Thu, 12 Sep 2002, Jeremy Carroll wrote:  >  > >  > >  > > Let's go with Hulabaloos, then.  > > I have never been there, ....  > >  > > Still unclear about Sunday night, don't the places you suggest  > fill up ...  > > we can't really book, because people will just be turning up etc.  > >  > > I am inclined to say "meet up in the hotel bar, with preference to stay  > > there".  > >  > > Jeremy  > >  > >  > >  > > > -----Original Message-----  > > > From: Libby Miller [mailto:Libby.Miller@bristol.ac.uk]  > > > Sent: 12 September 2002 17:06  > > > To: Jeremy Carroll  > > > Cc: Libby Miller; www-archive; julie_lanfear; sb;  > david_trastour; danbri  > > > Subject: RE: F2F social arrangements  > > >  > > >  > > >  > > > Hulabaloos food is certainly nice, and it's a BYO right?  > > >  > > > On Thu, 12 Sep 2002, Jeremy Carroll wrote:  > > >  > > > >  > > > > A suggestion from an HP conference organizer is:  > > > >  > > > > [[  > > > > Hullaballoos on Whiteladies Road for your evening meal on  > > > > Monday 7th Oct.  [Julie] contacted them and they can do a  > table for 25,  > > > > prices  > > > > are: 2 course ?13.30 or 3 course at ?16.30  > > > > ]]  > > > >  > > > > Jeremy  > > > >  > > > >  > > > > > -----Original Message-----  > > > > > From: Libby Miller [mailto:Libby.Miller@bristol.ac.uk]  > > > > > Sent: 11 September 2002 18:18  > > > > > To: Jeremy Carroll  > > > > > Cc: www-archive; julie_lanfear; sb; libby.miller;  > > > david_trastour; danbri  > > > > > Subject: RE: F2F social arrangements  > > > > >  > > > > >  > > > > >  > > > > > crud, sorry Jeremy. I did ask at work but didn't get many  > > > responses, in  > > > > > fact this was the only one:  > > > > >  > > > > > [[  > > > > > Grillbar on a sunday if you like meet they can cater for lots of  > > > > > people but they draw the line at RDF conversations......there is a  > > > > > warning on the door  ;)  > > > > > I heard that jamesons dont like DAML    :)  > > > > > ]]  > > > > >  > > > > > I don't know where the grillbar is though...jamesons is  > ok - and they  > > > > > have a cheap menu, but it's french and the portions are small.  > > > > >  > > > > > http://www.whatsonbristol.co.uk/reviews/grillbar.html  > > > > >  > > > > > I expect I could look at the hotel.  > > > > >  > > > > > below are some previous restaurant recommendations of  > restaurants from  > > > > > when I asked where to take my parents...  > > > > >  > > > > > near ILRT there's also Browns, which is quite big, though  > I've never  > > > > > been there; Azuma japanese restaurant which I like; oh, for  > > > Sunday night  > > > > > we could go to the ILRT favourite the Hope and Anchor on  > Jacobs wells  > > > > > road, which does rather nice food, though I'd have to  > check if they  > > > > > serve food on sunday evenings (I just checked - they do until  > > > 9.30 pm),  > > > > > and if the weather is poor it's not very big.  > > > > >  > > > > > see also  > > > > > http://www.whatsonbristol.co.uk/reviews/restaurant_reviews.html  > > > > >  > > > > > [[  > > > > > coccobello's is v good in Colston St (based in the bottom  > of Colston  > > > > > Tower).....they do pizza, main italian meals + plus they  > have a wet  > > > > > board (fish) (I chose the monkfish which was v good)  > > > > >  > > > > > see review:  > > > > >  > > > > > http://www.whatsonbristol.co.uk/reviews/coccobello.html  > > > > >  > > > > > however its not a BYO.....  > > > > >  > > > > > ---  > > > > >  > > > > > How about Budokan?  It's not BYO but it's not too expensive.  > > > > >  > > > > > Jamesons, opposite the BRI, is good but may be a bit pricey  > > > (and not BYI)  > > > > >  > > > > > ---  > > > > >  > > > > > lovely montpelier of course!  > > > > >  > > > > > bell's diner, or the indian place  > > > > >  > > > > > ---  > > > > >  > > > > > there is Taste of Morocco at the top of pig sty hill -  > > > although I guess  > > > > > that is about ten minutes walk up the gloucester road.  > > > > >  > > > > > ---  > > > > >  > > > > > Red Snapper on Chandos Rd, Fish, NOT BYO  > > > > >  > > > > > ---  > > > > >  > > > > > Just been last week to Juniper in Cotham (so just about walkable).  > > > > > Very good, not BYO, slightly pricey (10-12 pound for a  > main course),  > > > > > but definately worth it.  > > > > > ]]  > > > > >  > > > > >  > > > > >  > > > > >  > > > >  > > > >  > > > >  > > >  > > >  > >  > >  > >  >  >        

        > I personally agree  > with Tim that these (type List) triples are redundant, and I would  > bet that the OWL stuff, even if it does need them, could be trivially  > rewritten so that it did not. I was hoping that we could get back to  > Peter and find out whether he thought the problem was serious.      Peter punts the problem back to me - since I am the most recent person on  record as arguing for type triples in general (in OWL DL).    Here are my thoughts:    1: this is merely aesthetic either way     People who don't/do want the type triples can have what they want simply  by not using the rdf:parseType="Collection" syntax (whichever way we  decide).    2: the triples *are* redundant     It is easy to automatically add them; or for that matter, automatically  remove them.    3: the construct was added for OWL, and so the aesthetic judgement as to  whether they should be there or not in the convenience  rdf:parseType="Collection" syntax, should be made by WebOnt.    4: Given that in OWL DL and OWL Lite many type triples are needed, it is, in  my opinion, more aesthetic, to have these type triples also for Lists. The  need for type triples is principally to distinguish the various types of  user defined in Property in OWL Lite and OWL DL.    Jeremy        

          Hi    I have just been reading the W3C namespace policy:    http://www.w3.org/1999/10/nsuri    which states a policy for "namespaces defined within the W3C for   recommendation track documents" and talks about requesting such URIs when a   submission is made.    Also:  [[  In the case of a document using a policy selected from the template above,   the allocation of a namespace of the form /YYYY/MM/ssss where ssss is a   short string not causing confusion alarm or embarrassment should be an   administrative matter.  ]]    My take is that we should currently proceed with using the three? different   namespaces under http://www.w3.org/2004/03/trix/ (which are necessarily in   breach of that policy having additional directory level). If and when this   work starts down the rec track (for instance with a member submission), we   should conform with the W3C policy for rec track namespaces (i.e. by   requesting however many short names ssss are required, and arranging the   namespaces to fit, e.g. with # rather than / ).  Any such decision should be clearly articuated in any namespace documents   we publish at this stage.    Jeremy        

        After what I have heard in the telecon, I think it is worth stepping through  some very simple examples, being aware of what xslt makes of them.    This is a fairly long message, sorry.    We will arrive at a single 'complete' proposal for xml literal.    The only thing we are considering here is namespaces within the xml literal  "<foo/>".    There is a zip file attached, but it is only if you wish to run the examples  with your own version of xslt.    I have used saxon 6.4      Outline  =======    0: Assumptions  1: Namepaces That Aren't Used Should Be Ignored  2: Use of Exclusive Canonicalization  3: Difficulties with QNames as Attribute Values  4: InclusiveNameSpaces & Attribute Value "Literal"  5: Comments  6: A Proposal  7: What's the other path?        0: Assumptions  ==============    I assume:  - we do not want "namespace pollution"  - we want RDF/XML to be processable through XSLT without getting corrupted.  - following Eric's comments about comments, that we do not want to lose  potentially relevant information.    The second condition is tested using the copy transform taken verbatim from  the XSLT recommendation (copy.xsl in zip):  [[[  <!-- This program is taken from the XSLT recommendation:  http://www.w3.org/TR/1999/REC-xslt-19991116#copying  -->    <!-- For example, the identity transformation can be        written using xsl:copy as follows:  -->    <xsl:template match="@*|node()">    <xsl:copy>      <xsl:apply-templates select="@*|node()"/>    </xsl:copy>  </xsl:template>  ]]]    1: Namepaces That Aren't Used Should Be Ignored  ===============================================    So applying this to file a_1.xml  i.e.  [[[  <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"     xmlns:eg="http://example.org/" >     <rdf:Description>       <eg:a rdf:parseType="Literal">           <foo/>       </eg:a>     </rdf:Description>  </rdf:RDF>  ]]]    We get c_1.xml:  [[[  <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"           xmlns:eg="http://example.org/">     <rdf:Description>       <eg:a rdf:parseType="Literal">           <foo/>       </eg:a>     </rdf:Description>  </rdf:RDF>  ]]]    The very similar a_2.xml:  [[[  <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"     xmlns:eg="http://example.org/" >     <rdf:Description>       <eg:a rdf:parseType="Literal">           <foo></foo>       </eg:a>     </rdf:Description>  </rdf:RDF>  ]]]    is 'copied' to c_2.xml which is identical to c_1.xml  This is an example of how differences that are not in infoset are ignored by  XSLT.    Now, slightly more to the point, in a_3.xml we have a difference that is in  infoset:  [[[  <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"     xmlns:EG="http://example.org/" >     <rdf:Description>       <EG:a rdf:parseType="Literal">           <foo/>       </EG:a>     </rdf:Description>  </rdf:RDF>  ]]]    The namespace prefix eg has been replaced by the namespace prefix EG.    c_3.xml, the result of copying a_3, is not surprising:  [[[  <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"           xmlns:EG="http://example.org/">     <rdf:Description>       <EG:a rdf:parseType="Literal">           <foo/>       </EG:a>     </rdf:Description>  </rdf:RDF>  ]]]    At this stage, it appears as though changing the namespace prefix has not  changed the xml literal (which doesn't use any namespaces!).    However, a different transform extracts the xml literal from its element and  makes it a complete xml document.  The first two examples (i.e. x_1.xml and x_2.xml) in the zip are  [[[  <a>           <foo    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"    xmlns:eg="http://example.org/"/>       </a>  ]]]    Whereas the third example (x_3.xml) is:  [[[  <a>           <foo    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"    xmlns:EG="http://example.org/"/>       </a>  ]]]    NOTE Both namespaces are part of the <foo/> element as far as XSLT is  concerned, and the namespace prefixes matter. Thus as far as xslt is  concerned, the xml literals in a_1.xml and a_3.xml are different, even  though both are "<foo/>" surrounded by identical whitespace.      OPINION (uncontroversial?)  =======    I regard these extracts as illustrating "namespace pollution".  I think that the two documents a_1.xml and a_3.xml describe the same RDF  graph despite the difference between them (prefix "eg" replaced by prefix  "EG").        Moving on to a_4.xml this is:  [[[  <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"     xmlns:eg="http://example.org/" >     <rdf:Description>       <eg:a rdf:parseType="Literal">           <foo xmlns:eg="http://example.org/" />       </eg:a>     </rdf:Description>  </rdf:RDF>  ]]]    If this is our RDF input file, the author may expect that the namespace "eg"  is present on the xml literal. If you look at the xml (as text) it is indeed  there!    But ...  If we xslt copy this we get c_4.xml  [[[  <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"           xmlns:eg="http://example.org/">     <rdf:Description>       <eg:a rdf:parseType="Literal">           <foo/>       </eg:a>     </rdf:Description>  </rdf:RDF>  ]]]  which is the same as c_1.xml and c_2.xml.    What has happened is that the data model used by XSLT uses namespace  attribtues to compute the namespaces on the elements and then discards them.  The new namespace declaration does not change the namespaces on that element  ("eg" was already in scope) and hence is ignored completely.    Indeed running the extract transform to get x_4.xml we also get (almost) the  same as before:  [[[  <a>           <foo xmlns:eg="http://example.org/"   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"/>       </a>  ]]]  (note that Saxon has reversed the order of the namespace attributes, this is  not in infoset, and should be ignored)    However putting the same text string into the context of a_3 we get a_5.xml:    [[[  <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"     xmlns:EG="http://example.org/" >     <rdf:Description>       <EG:a rdf:parseType="Literal">           <foo xmlns:eg="http://example.org/" />       </EG:a>     </rdf:Description>  </rdf:RDF>  ]]]    This one is distinguishable under XSLT from all the others.  If we look at the "copied" file c_5.xml we see that the extra namespace  declaration does not vanish:  [[[  <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"  xmlns:EG="http://example.org/">     <rdf:Description>       <EG:a rdf:parseType="Literal">           <foo xmlns:eg="http://example.org/"/>       </EG:a>     </rdf:Description>  </rdf:RDF>  ]]]    Moreover looking at the extract file x_5.xml, we see that the literal has  more namespaces than previously:  [[[  <a>           <foo xmlns:eg="http://example.org/"    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"    xmlns:EG="http://example.org/"/>       </a>  ]]]      My take on these examples is that:  - the first three examples are all the same.    (the first two have identical infoset, the third is identical text).  - so is the fourth, because XSLT cannot distinguish it from the first.  - also the fifth is the same as the fourth because the text version is self  contained and identical.    i.e. all the examples (1 to 6) are basically "<foo/>" which only refers to  the default namespace and so any other namespace declaration is irrelevant!!    This differs from Infoset which sees the namespace attributes and the  namespaces as part of the element content, and from XSLT which doesn't see  the namespace attributes but does see *all* the namespaces as part of the  element content.    2: Use of Exclusive Canonicalization  ====================================    There is only one XML spec that I am aware of which worries in this sort of  way about referring to namespaces; ignoring ones that are not used. That  spec is the exclusive canonicalization spec. The key concept is:  http://www.w3.org/TR/2002/CR-xml-exc-c14n-20020212#def-visibly-utilizes    [[[  An element E in a document subset visibly utilizes a namespace declaration,  i.e. a namespace prefix P and bound value V, if E or an attribute node in  the document subset with parent E has a qualified name in which P is the  namespace prefix. A similar definition applies for an element E in a  document subset that visibly utilizes the default namespace declaration,  which occurs if E has no namespace prefix  ]]]    (that is the only new concept in exc-c14n).      Using this concept we could imagine a statement like:    "An xml literal includes the namespaces which are visibly utilized by that  literal, and no others."    or (more strongly)    "An xml literal is formed by taking the exclusive canonicalization of the  element content."    Either of these statements would be consistent with all the examples 1 to 6  being of the same literal. Note that the examples 4, 5 and 6  in which the  original XML has explicit namespace declarations within the xml literal *do  not* visibly use those namespaces, and so the namespace declarations are  simply ignored.    I use the transform smaller.xsl in the zip to make the files s_1.xml etc.  These are like the x_1.xml etc but without the invisible namespaces.    <aside>  Two other possibilities other than using at least the concept of visible  utilization from exc-c14n are:  - follow M&S in *not* addressing the namespace in xml literal issue.  - do our own thing independent of XML groups.    I do not see either of these as attractive.  </aside>    3: Difficulties with QNames as Attribute Values  ===============================================    Moving on to example 7 a_7.xml:  [[[  <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"     xmlns:eg="http://example.org/"     xmlns:q="http://example.org/q"  >     <rdf:Description>       <eg:a rdf:parseType="Literal">           <foo bar="q:name"/>       </eg:a>     </rdf:Description>  </rdf:RDF>  ]]]    As far as XSLT is concerned the qname in the attribute value is well-formed.  If we take the extract x_7.xml we see:    [[[  <a>           <foo     xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"     xmlns:eg="http://example.org/"     xmlns:q="http://example.org/q"     bar="q:name"/>       </a>  ]]]    and the "q" namespace is still around.    But the rule of ignoring invisible namespaces applies also to the q  namespace and so s_7.xml is:  [[[  <a>           <foo bar="q:name"/>       </a>  ]]]    Note that even if we use a_8.xml where the namespace is only declared on the  xml literal it still is "invisible" by the definition used.  a_8.xml  [[[  <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"     xmlns:eg="http://example.org/"  >     <rdf:Description>       <eg:a rdf:parseType="Literal">           <foo bar="q:name" xmlns:q="http://example.org/q"/>       </eg:a>     </rdf:Description>  </rdf:RDF>  ]]]  still shows the following visible part s_8.xml  (same as s_7.xml)  [[[  <a>           <foo bar="q:name"/>       </a>  ]]]    This situation is envisaged by exclusive canonicalization and they have  three solutions, all clunky:  [[[  + the XML must be modified so that use of the namespace prefix involved is  visible or    + the namespace declarations must appear and be bound to the same values in  every context in which the XML will be interpreted or    + the prefixes for such namespaces must appear in the InclusiveNamespaces  PrefixList a special parameter to list the unusual namespace prefixes which  are needed despite being invisible.  ]]]    The first one means getting the document author to add q:ignoreMe="please"  as an attribute to the element and hoping that it doesn't cause problems.    The second one would work for a small set of well-known namespace prefixes.    The third one is the only general purpose solution.    4: InclusiveNameSpaces & Attribute Value "Literal"  ==================================================    Within RDF/XML unfortunately, the natural way to list these unusual  namespace prefixes would be to use additional xmlns declaration. This  doesn't work if we wish to be XSLT-safe. XSLT systematically ignores such  declarations which repeat something that is already in scope. A good example  of a likely case is xmlns:xsd.  xsd is a prefix that is likely to be defined  at the top level, and may occur in a qname in an attribute value in an xml  literal in RDF!    We could list these unusual namespaces using an additional attribute e.g.  rdfns:xsd ....    This suffers from being fairly not backwardly compatible.    Oh dear, what we could do is decide to add these unusual namespaces after  the word Literal within the parseType. e.g.    a_9.xml  [[[  <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"     xmlns:eg="http://example.org/"     xmlns:q="http://example.org/q"  >     <rdf:Description>       <eg:a rdf:parseType="Literal q">           <foo bar="q:name"/>       </eg:a>     </rdf:Description>  </rdf:RDF>  ]]]    This would identify q as a namespace prefix to be treated unusually, i.e. as  always visisble on any element in which it is in scope.  Thus the xml literal is (the hand-written x_9.xml)  [[[  <a>           <foo xmlns:q="http://example.org/q"           bar="q:name"/>       </a>  ]]]      So there we have it.  We can prevent namespace pollution using the concept of visible utilization.  We can allow the unusual namespace use (e.g. qnames as attribute values) by  listing the unusual namespaces on the parseType value.  This is XSLT safe.  For greater precision, particularly for defining equality, we can specifiy  the use of XML canonicalization.      5: Comments  ===========    This message is based around one extreme of the solution space. We try and  fully specifiy what an xml literal is, and we try and get it right. This  will give maximum interoperability, at the cost of difficulty for  implementors.    As such I support Eric's remarks:  "I strongly vote in favor of  preserving comments.  I have a knee-jerk reaction to deleting any  information, and I believe this is what would be expected by content  produces that take time to include comments."      Thus example a_10 is different from a_1    a_10.xml  [[[  <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"     xmlns:eg="http://example.org/">     <rdf:Description>       <eg:a rdf:parseType="Literal"><!--    this comment is part of the literal -->           <foo/>       </eg:a>     </rdf:Description>  </rdf:RDF>  ]]]    the literal is extracted as s_10.xml  [[[  <a><!--    this comment is part of the literal -->           <foo/>       </a>  ]]]        6: A Proposal  =============    This proposal is based on maximally specifying the behaviour to minimize  interoperability problems, at the expense of requiring work from  implementors.    There is the assumption that the WG wishes to address xml literals that:  - use namespaces  - use namespaces within attribute values    Propose that:   - rdf:parseType="Literal" is replaced by rdf:parseType=literal     where literal is a list of names starting with the name "Literal"   - the value of such literal is the xml literal with string component given  by the exclusive canonicalization of the element content.   - that the c14n used includes comments   - that the c14n used uses the second and subsequent names from the value of  the rdf:parseType attribute as the InclusiveNameSpace Prefix list parameter  to the exclusive c14n algorithm.   - equality between the string components of xml literals is given by binary  equality   - close the xml literal issues.    Moreover, I could be actioned to draft an appendix to the syntax doc showing  how minimal RDF implementations that:  - do not need equality  - (and/or) can assume a complete set of namespaces for xml literals#    can be implemented satisfactorily without use of a c14n module.        7: What's the other path?  =========================    If the above proposal looks too heavy, I would suggest dropping qnames in  attribute values from the level of ambition, and merely trying to not  prevent implementations from treating unusual namespaces unusually. We would  then stick with "Literal" and "Resource" as the only two values of  parseType. Vagueness is possible about precisely what string is produced. A  more limited interoperablity could be achieved by concentrating the spec on  the equaity of literals.    I am happy to produce a second proposal based around that path.        Jeremy                                      application/x-zip-compressed attachment: literal.zip          

        Well, I appear to agree with Sergey and disagree with Patrick, ...    ... at least about the topic of disagreement!    I think RDF graphs are fundamentally untidy.      The serious concerns I have with S are as follows:    1. Tidiness.     Different occurrences of the same string have different types,     and IMO are better modelled as distinct entities.     S does not allow for this.     This is not asserting that implementations may not use     string interning or equivalent techniques for storage     compression, merely that the semantics of a literal node     depend on context.    2. Idiom B.       Idiom B, where the lexical form of a datatype is used directly     in a single triple, is for me, the primary idiom of RDF M&S.     For me, articulating implicit typing within that idiom is the     goal of the datatyping work. S's articulation of idiom B is     deficient.       2A:       Unfortunately in S, idiom B is explicitly a sop to backward     compatability which does not interwork properly with the     preferred S idiom, idiom A.      The examples we have already seen have been        <Jenny> <ageA> _:a .        _:a <xsd:integer.map> "4" .        <Jenny> <ageB> "4" .        <ageA> <rdfs:range> <xsd:integer.val> .        <ageB> <rdfs:range> <xsd:integer.lex> .      The single conceptual property of age gets reflected differently      in the two idioms, and the value of the age property is an integer      in one, and a string in the other. I think idiom B is *the* idiom      of choice, and datatyping should explicate how one gets from      the string lexicalization to the intended value.         2B:       Monotonicity and the open world assumption on type information.     S (idiom B and P) is non-monotonic with respect to type information,     or at least forces the RDF application to behave as if the     underlying theory were non-monotonic.  [Sorry this is rather obscure, I will ask for a clarification about S-P,  which will illustrate my concerns]      That's it. Other areas of difference are I think open to compromise.  So just as Sergey could live with one uri for each type (as in TDL), I  could live with S's three or four.    While I think the D syntactic idiom is better than S-A from a backward  compatibility viewpoint, and I do not like S idiom A, I could live with  S-A being the recommended local idiom.    I also have doubts about the implementability of S, and will seek  clarifications from Sergey.        Jeremy        

        Jos:  > I would propose to drop reification!  > so proposal to drop its sentences in 5.5, 5.9, 5.10, 5.11, 5.12 and 5.14  > as well as "5.26 Reification Rules"    Mike Dean posted an interesting provenance example to webont:     http://lists.w3.org/Archives/Public/www-webont-wg/2001Dec/0102.html      My take on this was not - wow a use case for reification, but ...     This use case needs provenance. Provenance is an important part of the  information; hence the provenance model should be an *explicit part* of the  overall schema/ontology for the information being collected.      i.e. RDF reification can be seen as a one size fits all solution for  provenance, which history shows as having fitted hardly anyone. A better  way, which is more in tune with the extremely open undogmatic nature of the  semantic web, is to allow many different schemata for provenance to flourish  and not to give preference to any one of them.        I think we should not *drop* reification, just not encourage it.  We can treat reification as a purely syntactic macro, turning an rdf:ID on a  property element into the reification quad. We could offer no model theory,  and no primer. It is there simply as a backward compatibility thing.    Jeremy        

        How about      >   >    <a> <b> "10"@fr .  >    <c> <d> "10"@fr .  >   > entails  >   >    <a> <b> _:l .  >    <c> <d> _:l .  >   >         

        Still on Patrick's comments:    Patrick:  > 11. Section 6, should a recommended algorithm for generating qnames  > on re-serialization be provided? One simple means of achieving   > reasonable round-tripping of at least qnames is to provide the  > RDF/XML writer with a set of namespace declarations to use and  > have it select for each URI the namespace which has the maximal   > intersection with the URI and use that for deriving the qname.     I think that would be a good addition; not necessarily this time round.    Jeremy        

          >  > If they were just constraining the current RDF/XML syntax, it'd  > be bearable. But  > for this to be their legacy for all future syntaxes seems pretty  > heavy, given  > that the triples are implied.  >    No - strong disagreement.    In OWL there are many triples which are redundant because they are implied.  However, it is hard to tell which triples are redundant and which are not.  End users need clear and simply guide lines. One such guideline is  "everything must have a type".    For syntaxes which omit redundant triples, then we can easily hypothesis an  intermediate stage that inserts them. And anyway future syntaxes for both  OWL and RDF are likely to either:  - list every triple explicitly  or  - be transformation based    either way I think your argument fails.    Jeremy        

          Hi Dan    this message is to you as chair of RDF IG.    Chris Bizer is visiting HP for the next couple of months.    He and I are intending to work on trust, contexts, named graphs etc.  (see threads in RDF IG)    We have agreed that work we do together is public. In order to clearly   implement that we are inclined to frequently cc: www-archive with our   on-going work, and then send occassional summaries to rdf-ig linking to the   www-archive thread.    Please confirm that this is an appropriate use of www-archive.    (Others in HP will be working with Chris on bridging between RDF and SQL,   and may choose to use the same technique for clarity about intellectual   property).      Jeremy        

        Patrick:  > 10. Section 5.27, some discussion (possibly) should be provided for  > scenarios where there is a mingling of rdf:li and rdf:_n in the actual  > serialization. Should li-counter consider the explicit _n values?  > Should it ensure resume counting after the explicit _n value? Does  > the parser have to ensure no collisions or does it create a partial  > ordering?    These issues were all resolved before I joined the WG.  The rdf:li is a simply macro that starts at 1 for each element and  increments on each occurrence. Nothing clever.    I guess following the issues list gets to the discussion eventually.    Jeremy        

        Jos:  > we want to see the entailment  >   |- rdfs:range rdf:type rdfs:Property.  > i.e. out of nothing (besides those rules of course)    That, would be broken inference.    The empty model with no assertions, i.e. every value of IEXT is empty, is a  model for those rules.    Hence if you can do the inference given, your rules of inference are  invalid.    Jeremy        

        I am unconvinced as to whether fragments addresses RDF needs.    While the context stuff is relevant, there is no canonicalisation.    Fragments are represented as XML document(s), which approximate to text  strings.    Hence the following tests are distinguishable.    All should be processed using the same base URL (if this offends globally  replace ":Description" with ":Description  rdf:about='http://example.org/parseTypeEqualsLiteral'" where rdf is the  appropriately bound namespace).    test0001 shows that an empty element expressed as one tag is distibguishable  from one expressed as two;  test0002 shows that attribute order matters;  test0002c shows that whitespace within a tag matters;  test0003 shows that comments are not stripped;  test0004 shows that namespace bindings are relevant, (the attribute meaning  may be changed by the choice of prefix for the RDF namespace!)  test0005 shows that all namespace bindings are significant, even though  neither of these are referred to in the literal.      === test0001a.rdf  <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">     <rdf:Description>        <rdf:value rdf:parseType="Literal" >            <foo></foo>        </rdf:value>     </rdf:Description>  </rdf:RDF>    === test0001b.rdf  <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">     <rdf:Description>        <rdf:value rdf:parseType="Literal" >            <foo/>        </rdf:value>     </rdf:Description>  </rdf:RDF>    === test0002a.rdf  <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">     <rdf:Description>        <rdf:value rdf:parseType="Literal" >            <foo a="a" b="b"/>        </rdf:value>     </rdf:Description>  </rdf:RDF>    === test0002b.rdf  <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">     <rdf:Description>        <rdf:value rdf:parseType="Literal" >            <foo b="b" a="a"/>        </rdf:value>     </rdf:Description>  </rdf:RDF>    === test0002c.rdf  <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">     <rdf:Description>        <rdf:value rdf:parseType="Literal" >            <foo a="a"     b="b"/>        </rdf:value>     </rdf:Description>  </rdf:RDF>    === test0003a.rdf  <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">     <rdf:Description>        <rdf:value rdf:parseType="Literal" >            <foo></foo>        </rdf:value>     </rdf:Description>  </rdf:RDF>    === test0003b.rdf  <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">     <rdf:Description>        <rdf:value rdf:parseType="Literal" >            <foo><!-- a comment --></foo>        </rdf:value>     </rdf:Description>  </rdf:RDF>    === test0004a.rdf  <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">     <rdf:Description>        <rdf:value rdf:parseType="Literal" >            <foo a="x:b"></foo>        </rdf:value>     </rdf:Description>  </rdf:RDF>    === test0004b.rdf  <x:RDF xmlns:x="http://www.w3.org/1999/02/22-rdf-syntax-ns#">     <x:Description>        <x:value x:parseType="Literal" >            <foo a="x:b"></foo>        </x:value>     </x:Description>  </x:RDF>    === test0005a.rdf  <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">     <rdf:Description>        <rdf:value rdf:parseType="Literal" >            <foo></foo>        </rdf:value>     </rdf:Description>  </rdf:RDF>    === test0005b.rdf  <x:RDF xmlns:x="http://www.w3.org/1999/02/22-rdf-syntax-ns#">     <x:Description>        <x:value x:parseType="Literal" >            <foo></foo>        </x:value>     </x:Description>  </x:RDF>    ===========  End of tests.    My belief is that to progress the literal representation issue we need to  first consider test cases like these. We can consider them against a number  of proprosals e.g.    STRING:  the literal is represented precisely by the string in the source  document  FRAG:    the literal is represented by a (to be defined) representation  conformant with XML Fragment Interchange specification.  CANON:   the literal is represented by the XML Canonicalisation of the  string in the source document.  INFOSET:    the string is represented by something from which a string can  be derived which when inserted into the source document in the place of the  original string leaves the XML Infoset of the source document unchanged.  NODESET:    the string is represented by something from which a string can  be derived which when inserted into the source document in the place of the  original string leaves the Xpath nodeset of the source document unchanged.  CANONINFO:  the string is represented by a canonical representation of the  infoset of the original string. Note: defining such a representation is  quite hard and not done.    We note that both STRING and FRAG are special cases of INFOSET; and CANON is  a special case of NODESET.    The truth table for the tests above is as follows                  1    2   3   4   5  STRING          f    f   f   t   t  FRAG            f    f   f   f   f  CANON           t    t   f   f   f  INFOSET         -    -   f   t*  t*  NODESET         -    -   f   -   -  CANONINFO       t    t   f   t*  t*    I am unsure about the four starred entries.  The t shows that the test data produces the same model, an f shows that the  test data produces different models, the - means that implementations may  produce either result.    If this is seen as a positive way forward, I can produce some more examples  early september in time for the RDF Core WG teleconference on Sept 7.    An argument against this approach is that the current M&S spec specifically  excludes testing for equality on such XML literals; in my view, this is  because that spec explicitly ducked doing these properly, and one of the  clarifications we are expected to make would allow for equality testing.    As I see it, the heart of the problem is what is the meaning of some XML.  The answer is that it is application dependent, and we should not try and  second guess which parts of infoset the application will look at; but the  application may not look at things outside infoset. However, it is plausible  to take a well-defined subset of Infoset, in particular a subset blessed by  some other W3C WG (such as the XPath nodeset).    Jeremy Carroll  HP Labs Bristol        

          > -----Original Message-----  > From: Brian McBride [mailto:bwm@hplb.hpl.hp.com]  > Sent: 20 March 2002 15:29  > To: Jeremy Carroll; Patrick Stickler; Pat Hayes; RDF Core  > Subject: RE: Unasserted triples, Contexts and things that go bump in the  > night.  >   >   > At 11:32 20/03/2002 +0000, Jeremy Carroll wrote:  > [...]  >   > >A fair point ... my example is bad stylistically, but does show   > that the XML  > >syntax is as flexible as the n-triple syntax.  >   > This is encoding information in the namespace prefix.  Is that   > legal, e.g.   > will cannonicalization preserve the distinction? Will this be another   > "thats those rdf weirdo's bending/breaking the rules again."  >     Hmmm, I think it's legal.    Jeremy        

          Brian    you seem to be counting issues as finished by "has a response been sent to  the commentator."    In concepts a number of issues have been decided but held up at this hurdle:  i.e.  pfps issues, where we want to point him at the complete document,  tex-01 where I need to generate the test cases,  efth-01 process confusion between editors    With the issues resolved today I see only:    danc-02  xmlsch-01  xmlsch-02  xmlsch-05  xmlsch-06    outstanding.    Does this tally with your records?    I am currently prioritising OWL Test Cases Last Call and RDF Core last call  issue resolutions - updating the concepts doc which will allow the pfps  responses is lower priority.    Jeremy        

          Proposed test    test001 rdf-entails test002  test002 rdf-entails test001    as in    http://www.w3.org/2000/10/rdf-tests/rdfcore/tex-01    Please check Manifest as well as test001 test002        

          Actually in response to Patrick's latest on "pfps-06 on hold"      Choices may be:    1) Fudge - peter unhappy, can probably persuade WebOnt to be unhappy,   difficult to defend WG decision    2) LC design - Xerces implementors have difficulty in passing tests    3) LC design, remove test cases        Xerces implementors can pass all the tests may potential   interoperability issues swept under carpet    4) change design - Patrick unhappy, increased distance between RDF   datatyping and XML Schema Datatypes    5) Variant of Fudge - e.g. make it clear in the implemenation note that   additional whitespace is an error, make producing a warning a SHOULD rather   than a MAY. (Probably not enough to appease Peter, may head off others),   could even make the implementation note informative and down case the MAYs   and SHOULDs.    Jeremy        

        with ref to  > 10: Discuss parseType=Literal Contributions  >  > See:  >   http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Aug/0170.html  >  http://lists.w3.org/Archives/Public/www-rdf-comments/2001JulSep/0101.html  >   http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Aug/0076.html      I think there are more relevant e-mails, in particular the thread:  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Aug/thread.html#67  (seven messages).    My (longish) message in that thread  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Aug/0138.html    suggests a way of dividing the issue into micro-issues to do with equality.    Jeremy        

        The RDF specification shows how labelled graphs can be encoded in XML.    e.g. the graph    http://lists.w3.org/Archives/Public/www-archive/2001Jun/att-0021/00-part#38    is encoded as    http://lists.w3.org/Archives/Public/www-archive/2001Jun/att-0021/00-part#65          It permits the use of well-balanced fragments of XML as one sort of label,  and refers to these as "XML Literals".    A typical example is:    <rdf:Description    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"    xmlns:dc="http://purl.org/metadata/dublin_core#"    xmlns="http://www.w3.org/1999/xhtml"    rdf:about="http://example.org/papers/paper1">    <dc:Title rdf:parseType="Literal"><!-- Relevant text start. -->      Foo<em>bar</em>    <!-- Relevant text end. --></dc:Title>  </rdf:Description>    Many users may omit the default xmlns declaration.    It is unclear precisely what the label in the RDF graph is.  There is agreement that the relevant text in the input file lies between the  two comments.    Some RDF APIs provide a string, others provide a means of accessing the SAX  events.  This is the content of the issue  http://www.w3.org/2000/03/rdf-tracking/#rdfms-literal-is-xml-structure    As will be familiar to the C14N people, there are specific issues to do with  namespace processing.    These are identified in:  http://www.w3.org/2000/03/rdf-tracking/#rdfms-xml-literal-namespaces  and also present in an example in the spec.  http://lists.w3.org/Archives/Public/www-archive/2001Jun/att-0021/00-part#257    Other problems relate to inconsistent treatment of character references etc.  which, for instance, the HP team found problematic when upgrading Jena to  work with ARP instead of RDFFilter. The two parsers had taken different  choices with respect to the exact representation of xml literals and the  regression tests then failed.    A large part of RDF Core WG's work has been making RDF more formal.  Particularly the RDF test cases and RDF model theory depend upon a well  defined equality over node labels.    These goals are in conflict with the current spec. that explicitly ducks the  issue of equality.    http://lists.w3.org/Archives/Public/www-archive/2001Jun/att-0021/00-part#220  [[[  This specification does not state a mechanism for determining equivalence  between literals that contain markup, nor whether such a mechanism is  guaranteed to exist  ]]]  RDF Model Theory  http://www.w3.org/TR/rdf-mt/  RDF Test Cases  http://www.w3.org/TR/2001/WD-rdf-testcases-20010912/      Hence, a resolution of these issues will give:  - a set of representation for XML Literals,  - a means for turning a specific well balanced XML fragment into such a  representation  - a means for comparing two such representations for equality    The RDF Core is currently agreed that C14N will be the basis of addressing  these issues.        

      RE: philosophy of SWBPD (was Re: [OPEN] and/or [PORT] : aLike Jim,    I find this anecdote uncompelling, and more a comment on the inadequacy of  the conference terms of reference and/or review. Personally I don't think  that papers that have little to do with the semantic web are appropriate at  a semantic web conference, although I note that the call-for-papers  typically do not reflect this. (At least once I have played the role of "mr  difficult on the floor" questioning the relevance of a paper on these  grounds; I expect to do that again)    Of course, some papers may be about enabling technologies, and never  actually articulate how they connect with the web - that's a flaw, but often  not fatal.    Jeremy      -----Original Message-----    From: public-swbp-wg-request@w3.org  [mailto:public-swbp-wg-request@w3.org]On Behalf Of Uschold, Michael F    Sent: 17 April 2004 06:23    To: Jim Hendler; NANNI Marco FTRD/DMI/SOP; SWBPD    Cc: Ian Horrocks (E-mail); Clark, Peter E; Sean Bechhofer (E-mail)    Subject: RE: philosophy of SWBPD (was Re: [OPEN] and/or [PORT] : a  practical question)        Jim Hendler says:          I guess it would be possible for using OWL separately from the Web, but  that is sort of like talking about using HTML separate from the Web -- why  would you want to?   Seems a pretty borderline case.              Here is your borderline case, and may help to explain the context of my  earlier remarks. We wrote a paper that got accepted last year's ISWC  conference that used DAML+OIL. The application had little if anything  specifically to do with the Web, we just used DAML+OIL because it was an  emerging standard ontology representation language, and we had a  classification problem that was amenable to DL reasoning. DAML+OIL, of  course evolved from OIL, which also had nothing specifically to do with the  Web.          I was hesitant to submit the paper on the basis of this dubious relevance.  It smacked too much of "if your program is in lisp or prolog, then you must  be doing AI". My co-authors over-ruled my concerns and I was proved wrong.  The paper got accepted and I gave the talk to a room that was 80-100% full  of people.  The predominant situation does indeed seem to be that it if you  use DAML+OIL (or OWL) then it must be relevant to the Semantic Web (or at  least, be of interest to the Semantic Web community).          Work on this project continues, and if we ever make it a Web application,  that will be independent from our choice to use DAML+OIL/OWL.  So, I guess  we are not using any of the webby portions of OWL, and to date have not seen  a need to (as far as I understand the webby vs. non-webby portions of OWL).          See: http://www.cs.man.ac.uk/~horrocks/ISWC2003/UCDF03a.html        

        > Since the vote on Friday, we have seen both Jos and Jan raise further   > dissent than was apparent at the telecon.  >   > A 6-5 vote with Jos missing and later dissenting hardly   > represents consensus.  >   > I believe we have to try again to find a consensus.      Strong support.    Jeremy        

          I think I was mistaken thinking the following ...    Jeremy:  > 4: The current spec is how it is because of an editorial oversight. This  > is an honest-to-goodness error, and should be corrected.  [meaning a 'drafting' error rather than a 'design' or 'review' error]    I now believe that it is probable that when the first versions of the  critical paragraphs were drafted the intent was an exclusive reading.    On a re-examination of the archive I think I have understood the  original motivation.    Summary:  --------    In early WDs the serialization syntax and the abbreviated syntax were  separate, with only the new productions in the abbreviated syntax. These  new productions introduced property attributes; they all permitted  identical attributes; hence the semantics of these attributes were made  uniform accross the three productions (desciption with propAttrs,  typedNode with propAttrs and propertyElt with propAttrs).   The reification reading of rdf:ID, and early versions of para 214, were  in the description of the serialization syntax (a distinct subsection  from the abbreviated syntax); while the descriptions of all the  attributes in the abbreviated form were largely identical across the  different productions in the abbreviated form.      Sources:  --------    The following draft introduced the abbreviated syntax    http://www.w3.org/RDF/Group/9711/WD-rdf-syntax-971114/    but does not describe what an id attribute on any property element  means.    The first text describing what the id attribute on property elements  mean is found in    http://www.w3.org/RDF/Group/1998/01/WD-rdf-syntax-19980111/    This crucially introduces early versions of all critical paragraphs in  distinct sections of the document.    In its discussion of the serialization syntax (section 3.1)  [[[  The value of the ID attribute, if specified, is the identifier for the  node that represents the reification of the property.   ]]]    In the discussion of the abbreviated syntax we have:  [[[  ... else if ID is specified R is a new node whose identifier is the  value of the attribute, ...  ]]]    At the same time the group were making major advances in their  understanding of reification and how to serialize it. bagID is  introduced in:    Ralph Swick (Dec 8 1997)  http://lists.w3.org/Archives/Member/w3c-rdf-syntax-wg/1997Dec/0087    (The issue list is:    http://www.w3.org/RDF/Group/Syntax/issuesd.html  )  Prior to bagID the same concept was represented by id. Hence, it remains  plausible (but not probable) that this use of id on propertyElt's with  propAttr's was some sort of left-over from the older notation.    I may still explore what happened when the text for the serialized  syntax and the abbreviated syntax got merged; and when RDF:href got  split into rdf:about on descriptions and rdf:resource on propertyElt's.  The latter removes the regularity of the treatment of *all* attributes  accross the abbreviated syntax productions; and hence makes it difficult  to sustain any non-historical motivation for a non-reifying reading of  rdf:ID.    Jeremy        

          >  I hope I can still point at something useful at  >   http://www.w3.org/TR/rdf-concepts/#dfn-blank-node-id    This link will be preserved and point to something that explains what one  is. As I indicated earlier, it does not feel like a normative part of the  abstract syntax. Does this need to be normative for you?    I don't think the defining text is changing much.    It doesn't give you a syntax for these things though - I note that the XML  balnk node ID and the N-triples blank node ID have different syntaxes.      Jeremy        

          I suggest we note the related comment:    http://lists.w3.org/Archives/Public/www-rdf-comments/2003JanMar/0027.html    "This is not an official request to do anything"    in our reply. (I had thought that this comment was sent on behalf of WebOnt,  but I can't find the trail).    Jeremy      > -----Original Message-----  > From: w3c-rdfcore-wg-request@w3.org  > [mailto:w3c-rdfcore-wg-request@w3.org]On Behalf Of Dave Beckett  > Sent: 10 March 2003 14:18  > To: RDF Core  > Subject: LC Issue hendler-01 (substantive) discussion  >  >  >  >  > Proposal to close hendler-01  >   http://www.w3.org/2001/sw/RDFCore/20030123-issues/#hendler-01  >  > Summary: rejected  >  >   This request would require substantial changes to the RDF/XML  >   grammar, make it more complex, introduce further tricky  >   implementation work and require another last call WD.  The  >   resulting RDF graph can be generated from the existing RDF/XML  >   albeit in a long form.  >  >  > NOTE * * * This is not yet a response to the issue raiser  * * *  >  > Rationale [LONG - with examples]  >  > This request would require a substantial change to the RDF/XML  > syntax, so that  >    http://www.w3.org/TR/rdf-syntax-grammar/#parseTypeCollectionPropertyElt  > would allow not only a list of node elements, but a list  > of what would might be called 'literal node elements'.  >  > This change would require another last call WD.  >  >  > Grammar Change Choices  >  > 1. The grammar would be changed to:  >  >   start-element(URI == propertyElementURIs ),  >       attributes == set(idAttr?, parseCollection))  >   (nodeElementList | literalNodeElementList)  >   end-element()  >  > and new grammar productions  >   literalNodeElementList ::= literalNodeElement*  >  >   literalNode ::= start-element(URI == ???,  >                                 attributes == set(datatypeAttr?,  > parseLiteral?))  >                     literal  >                   end-element()  >  > The latter would need new careful rules to handle both datatypes and  > parseType="Literal" forms (or the latter could be ruled out).  >  > This would mean inventing a new rdf term for ??? that would allow  > literals to be used where nodes were expected.  I will use rdf:abc  > for this example rather than pick one.  >  > 2. Alternatively only http://www.w3.org/TR/rdf-syntax-grammar/#nodeElement  > could be changed to be handle the functionality above, but it is one of  > the most complex parts of the grammar and it would be difficult.  >  >   Aside: If nodeElement was changed in this way, it *would* also  >   allow literals to be given as subjects of triples. However this is a  >   postponed RDF Core Issue:  >     http://www.w3.org/2000/03/rdf-tracking/#rdfms-literalsubjects  >   and if this choice was made, there would be temptation to  >   change all the other working drafts in order to allow it in the  >   semantics and abstract syntax, explain in the primer, etc.  >  > Examples of this new syntax  >  > So given rdf:abc and either of the above choices, you could then use:  >  >   <rdf:Description rdf:about="http://example.org/node">  >     <ex:propertyElement rdf:parseType="Collection">  >       <rdf:abc>a</rdf:abc>  >       <rdf:abc>b</rdf:abc>  >     </ex:propertyElement>  >   </rdf:Description>  >  > giving N-Triples:  >  > <http://example.org/node>  > <http://www.example.org/ns#propertyElement> _:genid1 .  > _:genid1 <http://www.w3.org/1999/02/22-rdf-syntax-ns#type>  > <http://www.w3.org/1999/02/22-rdf-syntax-ns#List> .  > _:genid1 <http://www.w3.org/1999/02/22-rdf-syntax-ns#first> "a" .  > _:genid1 <http://www.w3.org/1999/02/22-rdf-syntax-ns#rest> _:genid2 .  > _:genid2 <http://www.w3.org/1999/02/22-rdf-syntax-ns#type>  > <http://www.w3.org/1999/02/22-rdf-syntax-ns#List> .  > _:genid2 <http://www.w3.org/1999/02/22-rdf-syntax-ns#first> "b" .  > _:genid2 <http://www.w3.org/1999/02/22-rdf-syntax-ns#rest>  > <http://www.w3.org/1999/02/22-rdf-syntax-ns#nil> .  >  > and all the usual literal datatypes  >  >   <rdf:Description rdf:about="http://example.org/node">  >     <ex:propertyElement rdf:parseType="Collection">  >       <rdf:abc rdf:parseType="Literal"><a:b  > xmlns:a="http://example.org/a">Some XML</a:b></rdf:abc>  >       <rdf:abc rdf:datatype="&xsd;decimal">10</rdf:abc>  >       <rdf:abc xml:lang="fr">chat</rdf:abc>  >     </ex:propertyElement>  >   </rdf:Description>  >  > giving N-Triples  > <http://example.org/node>  > <http://www.example.org/ns#propertyElement> _:genid1 .  > _:genid1 <http://www.w3.org/1999/02/22-rdf-syntax-ns#type>  > <http://www.w3.org/1999/02/22-rdf-syntax-ns#List> .  > _:genid1 <http://www.w3.org/1999/02/22-rdf-syntax-ns#first> "<a:b  > xmlns:a="http://example.org/a">Some  > XML</a:b>"^^<http://www.w3.org/1999/02/22-rdf-syntax-ns#XMLLiteral> .  > _:genid1 <http://www.w3.org/1999/02/22-rdf-syntax-ns#rest> _:genid2 .  > _:genid2 <http://www.w3.org/1999/02/22-rdf-syntax-ns#type>  > <http://www.w3.org/1999/02/22-rdf-syntax-ns#List> .  > _:genid2 <http://www.w3.org/1999/02/22-rdf-syntax-ns#first>  > "10"^^<http://www.w3.org/2000/10/XMLSchema#decimal> .  > _:genid2 <http://www.w3.org/1999/02/22-rdf-syntax-ns#rest> _:genid3 .  > _:genid3 <http://www.w3.org/1999/02/22-rdf-syntax-ns#type>  > <http://www.w3.org/1999/02/22-rdf-syntax-ns#List> .  > _:genid3 <http://www.w3.org/1999/02/22-rdf-syntax-ns#first> "chat"@fr .  > _:genid3 <http://www.w3.org/1999/02/22-rdf-syntax-ns#rest>  > <http://www.w3.org/1999/02/22-rdf-syntax-ns#nil> .  >  >  > Working with the Existing RDF/XML  >  > All the triples given above can be generated from the existing  > grammar, with the triples written out in long form.  This would be  > true for all potential mappings and although inconvenient for  > hand-writing, would be possible.  >  > The first set of triples written out in longhand RDF/XML  >  > <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"  >          xmlns:ex="http://www.example.org/ns#" >  >   <rdf:Description rdf:about="http://example.org/node">  >     <ex:propertyElement rdf:nodeID="genid1" />  >   </rdf:Description>  >  >   <rdf:Description rdf:nodeID="genid1">  >     <rdf:type  > rdf:resource="http://www.w3.org/1999/02/22-rdf-syntax-ns#List" />  >     <rdf:rest rdf:nodeID="genid2" />  >     <rdf:first>a</rdf:first>  >   </rdf:Description>  >  >   <rdf:Description rdf:nodeID="genid2">  >     <rdf:type  > rdf:resource="http://www.w3.org/1999/02/22-rdf-syntax-ns#List" />  >     <rdf:rest  > rdf:resource="http://www.w3.org/1999/02/22-rdf-syntax-ns#nil" />  >     <rdf:first>b</rdf:first>  >   </rdf:Description>  > </rdf:RDF>  >  > The second set:  >  > <?xml version='1.0' encoding='utf8'?>  > <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"  >          xmlns:ex="http://www.example.org/ns#" >  >   <rdf:Description rdf:about="http://example.org/node">  >     <ex:propertyElement rdf:nodeID="genid1" />  >   </rdf:Description>  >  >   <rdf:Description rdf:nodeID="genid3">  >     <rdf:type  > rdf:resource="http://www.w3.org/1999/02/22-rdf-syntax-ns#List" />  >     <rdf:rest  > rdf:resource="http://www.w3.org/1999/02/22-rdf-syntax-ns#nil" />  >     <rdf:first xml:lang="fr">chat</rdf:first>  >   </rdf:Description>  >  >   <rdf:Description rdf:nodeID="genid1">  >     <rdf:type  > rdf:resource="http://www.w3.org/1999/02/22-rdf-syntax-ns#List" />  >     <rdf:rest rdf:nodeID="genid2" />  >     <rdf:first rdf:parseType="Literal"><a:b  > xmlns:a="http://example.org/a">Some XML</a:b></rdf:first>  >   </rdf:Description>  >  >   <rdf:Description rdf:nodeID="genid2">  >     <rdf:type  > rdf:resource="http://www.w3.org/1999/02/22-rdf-syntax-ns#List" />  >     <rdf:rest rdf:nodeID="genid3" />  >     <rdf:first  > rdf:datatype="http://www.w3.org/2000/10/XMLSchema#decimal">10</rdf:first>  >   </rdf:Description>  >  > </rdf:RDF>  >  >  > Both of the latter two rdf/xml examples are legal and work in parsers  > conformant with the Jan 23 2003 drafts.  >  >  > Summary of adding this form:  >  > Pros (changing to add this new form)  >   Adds a shorthand for a triples form that Hendler and Webont call  >     "very important" (Hendler)  >     --  http://lists.w3.org/Archives/Public/www-rdf-comments/2003JanMar/0322.html      and "prefered .. to be allowed" ,"would permit some constructs in          OWL that are difficult under the current design." (WebOnt)      --  http://lists.w3.org/Archives/Public/www-rdf-comments/2003JanMar/0335.html    With grammar choice 2, allows a way to do literal triple subjects.    Using the current RDF/XML is very long and "extremely ugly" (Hendler)    Cons (not changing)    Is creating another new piece of RDF/XML syntax.    Requires a new last call RDF/XML syntax WD.    Tricky grammar choices and changes, wordings.    New implementation burden.    Adds yet another alternate way to use RDF/XML - already too many options.    Requires new description in RDF/XML syntax section 2 and in the RDF  primer.    With grammar choice 2, would tempt changes to be made to most all other  WDs.    ---    My personal summary is: sorry, too late for such a large change.    Dave        

        Hmmm ...    As I understand Patrick's position:      There is an abstract layer over a tidy graph in which the TDL for one use of  a literal node is distinct from the TDL for a second use.    This abstract layer seems to be a datatyping layer between the graph and the  model theory.    I did consider this approach to doing the mathematics for TDL and couldn't  get it to work, with all respect, Patrick has not shown to my satisfaction  how it would work.    Let's suppose that it could be made to work.    I think an Occam's razor argument would favour a two layer approach over a  three layer approach.      Jeremy                > -----Original Message-----  > From: w3c-rdfcore-wg-request@w3.org  > [mailto:w3c-rdfcore-wg-request@w3.org]On Behalf Of Patrick Stickler  > Sent: 28 January 2002 09:07  > To: Jeremy Carroll; Dan Connolly  > Cc: RDF Core  > Subject: TDL is compatible with tidy literals, even if current TDL MT is  > not (which should be fixed)  >  >  > On 2002-01-25 19:22, "ext Jeremy Carroll" <jjc@hplb.hpl.hp.com> wrote:  >  > >  > >  > >  > >>  > >>  > >> Brace yourself for mind-bogglinly deep  > >> formal argument:  > >>  > >> premise:  > >> <http://www.w3.org/> dc:title "W3C".  > >> conclusion:  > >> <http://www.w3.org/> dc:title "W3C".  > >>  > >  > >  > > I am reviewing this.  > > Currently I think Dan has a point.  > >  > > So ...  > >  > > So as is, this is a show-stopping bug on TDL.  >  > Forgive me for slightly disagreeing with you Jeremy, but  > the bug is not with TDL, but with the present MT definition  > of TDL.  >  > The basis of TDL is that one interpretes a given literal  > as a lexical form of a datatype based on which TDL pairings  > are defined or inferrable from the RDF graph.  >  > In essence, TDL interpretation is like an axiom:  >  > Per local idiom:  >  > IF   a literal L is the object of the predicate rdf:value  >      and the subject is an ononymous node with an rdf:type  >      property defined,  > THEN the datatype D is the object  >      of that rdf:type property and the TDL is (L, D)  >  > Per global idiom:  >  > IF   a literal L is the object of a predicate other than  >      rdf:value  > THEN for each datatype D associated with the predicate  >      via an rdfs:range property, there is a TDL (L, D)  >  > and once we have a TDL, we know the value, based on  > the definitions in the foundational DT MT and the  > 1:1 relation between TDL pairings and mappings.  >  > Note that in the above axioms, L is the actual literal  > string, not the node, and D is the URI of the datatype  > not the node/resource.  >  > Neither of the above "axioms" require the graph to be  > untidy for literals. The only thing that requires the  > graph to be untidy is IFF the object node of a predicate  > which either has a literal label or is an anonymous  > node with an rdf:value defined literal is itself supposed  > to denote the member of the value space. If the object  > node need not denote the actual member of the value space,  > then there's no problem.  >  > See the attached illustration, which shows a literal tidy  > graph where the literal "30" is interpreted as a lexical  > form for two different datatypes. This shows that (a) the  > TDL model itself is agnostic with regards to tidy versus  > untidy literals, and also that the same literal (not  > lexical form) may have multiple interpretations, depending  > on the datatype associated with it.  >  > Thus, I see no reason why the TDL MT cannot be revised  > to allow tidy literals -- so long as folks are OK with  > the axomatic like interpretation of TDL pairings and we  > don't have to denote an actual value by any given literal  > labeled node or rdf:value=literal qualified anonymous node.  >  > > However it doesn't surprise me that there is a bug, very few of  > us produce  > > bug-free stuff first time.  > > The normal response to bugs (even showstoppers) is to fix them,  > so that's  > > what I intend to do.  >  > I have every confidence that the bug in the MT for TDL can  > be fixed ;-)  >  > Cheers,  >  > Patrick  >  >  > --  >  > Patrick Stickler              Phone: +358 50 483 9453  > Senior Research Scientist     Fax:   +358 7180 35409  > Nokia Research Center         Email: patrick.stickler@nokia.com  >  >  >        

          This is a copy of a message sent to the coordination group:  http://lists.w3.org/Archives/Member/w3c-semweb-cg/2003Aug/0012    [[  I have heard that some people are arguing that the RDF/I18N dispute needs a  second last call for its resolution.    I have discussed this possibility with HP Lab's management, and wish to  provisionally register deep concern at this possibility.    For a number of months HP's level of commitment to RDF Core has been  greater than we would like, and we do not welcome the thought of another delay.    If this comes to pass, we would need to review our level of commitment to  RDF Core, and consider how we might make substantial reductions.    Jeremy Carroll.    ]]        

          Here's where I am now, but I am out of time for today - will continue  tomorrow.    I've finished the first cut, and duplicated it and started pruning the first  copy.    Jeremy          text/html attachment: TDL_Model_Theory.html          

      >  > I have a couple of comments/questions...    I'll try and answer.      >  > OK, they key idea here is that the denotation of a literal node is a  > <unicode-string,value> pair, rather than just a value, right?    Yes    >  > So the denotation of a node labeled with "10" and type-designated to be a  > decimal integer can never be exactly the same as a node the  > denotes just an  > integer value that is, say, the count of my fingers-and-thumbs, without  > regard for how it is lexically represented.   (I don't see this as a  > problem, but note that it seems like a departure from previous  > approaches.)    Yes, but such nodes don't exist in the models ... unlike S-A, (or the  original P), at least in the model theory all values (such as integers) are  always paired with a lexical representation.        >  > >The Interpretation of Datatype URIs  > >  > >If E is a uriref and the label of E=u(d) for some d in DT, then I(E) = d.  >  > Hmmm... it's just a nit (I think) but this implies that a uriref has a  > label.  Do you mean something like:  "If E is labelled with a uriref and  > the label of E=u(d) ..."    Yes that's fine I accept the nit.    >  > >The Interpretation of Blank Nodes  > >The mapping A on blank nodes is unrestricted and a blank node can be  > >interpreted  > >as any object in the Universe (including literal-value pairs).  > >  > >The Interpretation of Asserted Triples  > >  > >The function IEXT is modified as follows:  > >IEXT maps the set of properties IP into the powerset of ( Universe x  > >Universe).  >  > If literals cannot be subjects, would this become a powerset of (IR x  > Universe)?    I want rdf:value as the identity which is why its Universe x Universe.    I am not suggesting literals as subjects in any serialization of RDF, but in  terms to the graph, and particularly taking the schema closure of a graph  literal as subjects is necessary in this approach. (Both the P & D idiom  really does seem to have literals as subject or type statements, just not  syntactically)      > Something thing that is bothering me about this is:  the  > interpretation of  > a Unicode node is stated in such a way that there may be several  > literal-value pairs that could be denoted.  Do you mean the  > interpretation  > in this case to be ambiguous?    Extremely. I am trying to delete the suggestion that xsd:string is the  default type.    If we support no types, or no type information is available for a particular  node labelled "foo", then that node can be interpreted as a pair <"foo", x >  for any x what so ever.    It's model theory not application semantics.         Suppose that data types BinaryNumber and  > DecimalNumber are recognized, then a node labelled "10" can denote:  >     <BinaryNumber,2>  >     <DecimalNumber,10>  >  >    "10" without type information could also just be the string, or maybe  there's its of some type we haven't thought of yet. So in the pair < "10", x  > an application is only really going to find the "10" helpful in this case,  since the x is free.      > Also, how does the change to rdf:type work for data types that  > don't have a  > defined lexical form?  E.g. consider the format used by RDFWeb for  > describing people:  >  >    _:gk rdf:type  foaf:Person .  >    _:gk foaf:name "Graham Klyne" .  >    _:gk foaf:mbox <mailto:GK@ninebynine.org> .  >    (etc...)  >  > There is no defined lexical form that universally denotes me, the  > person.  So what is the denotation of the thing labelled _:gk ?    Pass for now.    >  Jeremy    >        

        Patrick    I would be interested in seeing an X version of the RDF/XML examples ...    We also need to have examples that only use the XML schema built-in types,  we have had some discussion about complex numbers in RDF, but not about  enumerations.    Jeremy        

        Mark Davis:  > If the character % were itself escaped, then escaping *would be* fully  reversible.    Hmmm, not if you don't know the charset of the original character sequence.  I seem to remember an example of a non UTF-8 URL in charmod.    ===    My take on the erratum at http://www.w3.org/XML/xml-V10-2e-errata#E26. is  that RDF needs to specify that for RDF/XML documents the RDF processor  should escape the URI as soon as it can (i.e. just after it gets it from the  XML processor, or straight after turning a relative URI into an absolute  one, whichever happens later). i.e. the RDF needs are diammetrically opposed  to the XML solution.    The reason for this is that URI equality is important in RDF. The realistic  algorithm for URI equality is binary comparison, and this only works by  determining a normalized form for URI's. Because of the one-way nature of  URI escaping (see above) it is necessaary to normalize to the fully encoded  form (with uppercase hexadecimal escapes) rather than the fully unencoded  form.    I think that the internal representation of  international URIs in RDF  should be US ASCII RFC 2396 URIs.    For RDF/XML output, and other human display, we could suggest that  applications should make best efforts to reverse the escaping, with the  exception of the % character and any that are not well-formed UTF-8.    Jeremy        

          > 8: Status on Incoming Last Call Comments  >  > 2003-03-28#9  jjc  update Concepts in light of XML Schema LC  >         review editorial comments    I expect to get to this next week. I will try and have an editors draft of  concepts updated to be up-to-date with issue resolutions before budapest.      > 2003-03-28#11  danbri  check for editorial actions on Schema from  >         XML Schema LC review  >  >  >  >  > 9: Issue xmlsch-07 datatype definition  >  >   http://www.w3.org/2001/sw/RDFCore/20030123-issues/#xmlsch-07  >  > Formal proposal to not accept this comment as it has been withdrawn by  > the xml schema group:  >  >   http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2003Apr/0316.html  >  >  >  > 10: Issue tex-01    Hopefully e-mail with test cases to follow.    > 11: Issue timbl-03  >    Possible proposal:    PROPOSE: that RDF Core asks WebOnt WG to decide this issue.    Pat and Dan might be better placed to say than me, but it might be best to  delay another week ... :( (I was not at the webont telecon, and there are no  minutes or IRC as yet, but got signs of a lack of resolution in the e-mail)    >  > 12: Language tags in typed literals    I offer the co-chair  the subagenda just sent out.    >  >  >  > 13: Issue xmlsch-01 Typed Literal Structure  >  > Various proposals to close:  >  >   http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2003Apr/0247.html  >  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2003Apr/0252.html    I withdraw my comments 247 in favour of Brian's 252.    > 14: Issue xmlsch-02 Whitespace facets  >  > Proposal:  >    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2003Apr/0224.html  >    I will try and make a formal proposal now.    Jeremy        

        Ron:  > Canonicalizing the literal just makes things hard for the  > DPH, which will in turn limit the use of RDF.    DPH ? Perl Hacker ?    Jeremy        

           o charmod uri    I think we can make substantial progress on both I18N issues by agreeing a  response to the test case examples I posted in:    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Mar/0027.html    Do we think:    1: this is an RDF problem (i.e. present in the graph)  2: this is an XML problem (i.e. present in the XML serialization only)  3: this is not a problem (e.g. to be addressed, if at all, at the  application layer)      ************  (More - rambling ...)    Given such a response I could go away and draft resolutions to both issues,  and justify them on that basis.      If 2 or 3 then we should document that and close the charmod-literal issue.  (If these examples are not compelling then I don't think that there will be  compelling examples). The charmod-uri issue is not impacted by this test  case.    If 1 then a solution is:  - prohibit RDF string literals that are not in NFC.  - treat a URI before %-escaping and its %-escaped version as distinct in the  RDF graph  - explicitly allow the uriReference production to match original character  sequence (in UTF-8) URIs.  - prohibit the use of non NFC 'URIs' in RDF.      I note that the issue is exemplified by the archive web page, looking at the  in-line RDF example with Internet Explorer 5.5, and looking at the same  example with view source. Depending on what tools you have available you may  or may not get the same effect.    The view I have displays the two "#Andre" strings identically (which  conforms with unicode), whereas my view source mode does not.      Jeremy        

          I am going on holiday just as the telecon starts!    Jeremy        

        >  > RDF C14N Inclusive or Exclusive (B)  > ===============================  > Discussion of the differences between the two C14N specs.  >    C14N provides two quite different treatment of namespaces.  These two specs also differ in their treatment of attributes in the XML  namespace, (see below).    Background  ==========  People using XML envelopes found the earlier inclusive canonicalization spec  a little problematic, in that information from the envelope ended up in the  canonical version of the payload. Exclusive C14N is intended to be useful  for such applications. rdf:parseType="Literal" appears to be such an  enveloping application and so we should seriously consider exclusive C14N.      Namespaces  ==========    In the inclusive treatment all namespaces on a node are made explicit in the  canonical form.    In the exclusive treatment only those that are visibly utilized on elements  qnames or attribute qnames are made explicit.    http://www.w3.org/TR/xml-exc-c14n#def-visibly-utilizes    As an example consider:      <rdf:Description    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"    xmlns:xsd="http://www.w3.org/2001/XMLSchema"    xml:lang="en"    xmlns:eg="http://example.org/">    <eg:bar rdf:parseType="Literal">      <foo xsi:type="xsd:decimal">10.09</foo>    </eg:bar>  </rdf:Description>    Under inclusive C14N the literal value is:    "\n    <foo xml:lang="en" xmlns="" xmlns:eg="http://example.org/"  xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"  xmlns:xsd="http://www.w3.org/2001/XMLSchema"  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  xsi:type="xsd:decimal">10.09</foo>\n  "    although I've probably got the attributes in the wrong order.    All the namespaces, including the rdf one (which must be present because of  rdf:parseType) are present.    Under exclusive C14N the literal value is:  "\n    <foo xmlns="" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  xsi:type="xsd:decimal">10.09</foo>\n  "    because only the xsi and default namespaces are visibly used.    I note that in some sense the exclusive C14N has got this example wrong,  since we need to preserve the binding of the xsd prefix to preserve the  semantics of this example.      Attributes in the XML namespace  ===============================    Note that the exclusive form does not copy the xml:lang attribute, whereas  the inclusive form does.        

         IRI-everywhere  I am the issue owner of http://www.w3.org/2000/03/rdf-tracking/#rdf-charmod-uris, and wished to share some of the analysis that I did in applying the lessons of Charmod to URIs in RDF.  The main function of a URI/IRI in RDF is as a name, just like in XML namespaces.  Being able to retrieve a URL is of less interest.    Three levels of IRI definition  Allow (nearly) any Unicode  The XLink href text, and the XML System Literal text (though erratum) provide a working definition of an IRI that allows any Unicode string that would %-escape to a URI.    Disallow non-NFC  A theme in charmod is the important of NFC, and early uniform normalization.  We analyzed this and found security issues when two XLink style URIs differ only in normalization (two different names look the same, and hence cannot be visually distinguished: see:  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Mar/0027.html  The two strings:  "/Andr??"   "/Andre??"   are not identical but look the same.  )  Hence, in the IRI draft and in the current RDF WDs the identifiers must be in NFC.  In XML Namespaces 1.1, when used within XML 1.1, this restriction (that IRIs must be in NFC) is implicit. While XML Namespaces 1.1 does not mention normalization, since an XML 1.1 document must be fully normalized, all attribute values are in NFC, including those for xmlns attributes.    Disallow certain BiDi  The IRI draft also considers problems to do with BiDi text. I don't pretend to understand these. Further Unicode character sequences, which involve right-to-left characters and other bidi markup, which are legal under XLink href, are not legal as IRIs according to the IRI draft. This part of the IRI draft, is, as far as I am aware, still cooking.    IRI equality  The definition of equality between identifiers is important for any system like XML Namespaces or RDF which uses URIs/IRIs as names rather than as URLs. This notion of equality differs from operational equivalence. (Note the HTTP spec, when discussing equality of http URLs, is essentially discussing operational equivalence, rather than abstract equality of names).    Identity - Character by Character  The simplest notion of equality is found in the XML Namespaces spec (both 1.0 and 1.1) i.e. character by character equality. This is good from an implementors point of view; and easy to explain to users.    Same Resource? Scheme specifc equality  Another intuitive sense of equality is that the two URIs/IRIs identify the same resource. Attempting to capture this would involve both generic processing to do with case, %-escapes, IANA protocol numbers, etc. and scheme specific processing. Even then, such an implementation would not fully capture this intuitively appealing concept of equality.    Same URI - (ASCII) URI as value space for anyURI  When faced with IRIs as a migration from URIs it is tempting to define equality of IRIs as two IRIs are equal if their URIs are equal. This essentially punts the question, and typical involves URI character-by-character equality. It also raises stupid questions about %7E and %7e ...  From an application point of view, defining equality in this way creates work:      a.. the original characters (the IRI) must be retained, in order to redisplay the identifier to the user in the manner they expect.    b.. either the %-escaping must be repeatedly performed or the value cached, both of which adds significant overhead.    c.. When two different IRIs %-escape to the same URI (possible when one IRI is already, perhaps partially, %-escaped) and the associated concepts get merged, the application will probably retain one, and arbitratily discard t he other, leading to potential user confusion.    d.. It may be necessary to normalize case of hexadecimal characters in % escape sequences, this runs counter to the lack of case normalization in URI comparison.    Proposed Actions  I think there are good arguments, presented in Charmod, for requiring NFC.  I think there are good arguments for, when an IRI is being used as an identifier, then equality of IRIs should be character-by-character comparison.  I think the sooner an I18N-WG recommendation has normative text defining IRIs the better.  I think this should not be made dependent on resolving the bidi issues that are hard.     Current State-of-Art=Disallow non-NFC  In the specs that are already at full recommendation we have IRI support allowing any unicode. In specs such as Namespaces 1.1 (within XML 1.1) we have the proposal that IRIs should be in NFC. I think that the W3C should have this as the current expectation on WGs - the specs should support IRIs (without the BiDi) and should require full normalization.     Replace Charmod Section 8 with explicit text    I understand that charmod is currently held up, partly because of its dependence on IRI-draft.  Thus I propose to modify charmod as follows, and move it to Candidate/Proposed Rec.  - delete normative text in section 8 Character Encoding in URI References  - add text defining an IRI, similar to that in XML Namespaces 1.1, XLink, or  the RDF concepts WD, with the explicit constraint that IRIs are in NFC.  - add an eratum to the charmod erratum page with fragID #IRI and text - "No IRI erratum at present."  - add a note to section 8 of charmod suggesting that the reader refer to that erratum  - add a constraint in section 8 that documents and implementations SHOULD not use right to left or bidi characters in IRIs   - add a note explaining that IRI-draft does address bidi, but this is still in development    Once IRI-draft is a recommendation, then update the erratum against charmod replacing section 8 with:  [[Note: this section is deleted. However,  specs, implementations and documents MUST conform with IRI]]  This will allow XML Namespaces 1.1 and other documents to normatively refer to a definition of IRI. Moreover, once bidi in IRI is cooked, new specs will be able to refer to IRI.      Jeremy Carroll.        

          Are we banning use of rdf:* except where we say so?    My thought is that a parser may choose to treat rdf:ParseType as a propAttr.  Your test cases are still errors but with a different sort of error message.      e.g.     ERROR: Unknown rdf attribute: 'ParseType'    or       ERROR: Unexpected text, propertyElt with propAttrs must be empty.      which one do we go for?    (I prefer the first)      Jeremy        

            Minutes - RDF Core WG - Telecon 30 November 2001  ================================================    Agenda:     http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Nov/0641.html    Summary:     DECISION 2001-11-30#1  Frank Manola will co-edit the Primer.     DECISION 2001-11-30#2  Jan Grant will co-edit the Test Cases WD.     DECISION 2001-11-30#3  Reserve use of names in the rdf namespace as  in agenda.     DECISION 2001-11-30#4  'Delete' para 196 from Syntax WD.         ACTION 2001-11-30#1 Dan Connolly: Review  rdfs-transitive-subSubProperty test cases.     ACTION 2001-11-30#2 Pat Hayes: Review rdfs-transitive-subSubProperty  test cases.     ACTION 2001-11-30#3 Jan Grant: Get access to test case areas of W3C  site.     ACTION 2001-11-30#4 Dave Beckett: Create test cases covering reserved  use of rdf names in this proposal.     ACTION 2001-11-30#5 Dave Beckett: Create test case showing that the  2nd URL in Para 196 is permitted.     ACTION 2001-11-30#6 Mike Dean: Sumamrise Joint Committee position,  confirm with them, circulate to us.     ACTION 2001-11-30#7 Pat Hayes: Write up P for inclusion in Sergey's  document.     ACTION 2001-11-30#8 Dan Connolly: Write up Perl datatyping proposal  as e-mail to group.     ACTION 2001-11-30#9 Jeremy Carroll: Write up XML Schema structures  datatyping proposal as e-mail to group.        Note: We had frequent technical problems with the irc channel.        The attached log is incomplete, and has non-irc notes         appended. I believe that I did not get all the irc messages        even before I lost connectivity.     1: Allocate scribe      Jeremy Carroll      2: Roll Call    Present  -------    Brian McBride    Eric Miller    Dave Beckett    Dan Connolly    Ron Daniel    Jos De Roo    Jan Grant    Graham Klyne    Frank Manola    Stephen Petschulat    Patrick Stickler    Aaron Swartz    Mike Dean    Pat Hayes    Sergey Melnik (for item 11 only)    Absent  ------    Frank Boumphrey    Bill dehOra    Rael Dornfest    Yoshiyuki Kitahara    Michael Kopchenov    KWON, Hyung-Jin    Ora Lassila    Satoshi Nakamura    Pierre Richard    R.V. Guha      Regrets  -------    Dan Brickley    Martyn Horner      3: Review Agenda      No AOB.    4: Next telecon - 10am Boston time, 07 Dec 2001      5: Review Minutes of 2001-11-16     http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Nov/0561.html      No comments, minutes approved.        6: Status of Primer     Eric requested a coeditor for the Primer.     DECISION 2001-11-30#1  Frank Manola will co-edit the Primer.      7: Status of Model Theory     2001-11-16#5 PatH  Post updated copy of model theory, with datatype  discussion elided, for group review by Wednesday 21-Nov-2001     Action continued.    8: Status of Syntax WD     No progress.     Dave Beckett hopes to have something by end of next week.    9: Issue: rdfs-transitive-subSubProperty  Propose Approve test case  -------------------------  Not considered since no-one has reviewed test cases.     ACTION 2001-11-30#1 Dan Connolly: Review  rdfs-transitive-subSubProperty test cases.     ACTION 2001-11-30#2 Pat Hayes: Review rdfs-transitive-subSubProperty  test cases.         10: Manifest Proposal  Review Jans proposal.  --------------------    Jos wants a distinction between rdfs and rdf entailment.  Brian notes that this text belongs in the Test Cases WD.    DECISION 2001-11-30#2 Jan Grant will co-edit the Test Cases WD.    ACTION 2001-11-30#3 Jan Grant: Get access to test case areas of W3C  site.       12: Issue #rdfms-rdf-names-use  [[[  Propose the WG      o Resolves that the use of rdf:RDF, rdf:ID, rdf:about,      rdf:resource, rdf:bagID, rdf:parseType, rdf:aboutEach and rdf:li  except      as reserved names as specified in the grammar is an error.    o resolves that test case   http://www.w3.org/2000/10/rdf-tests/rdfcore/rdf-containers-syntax-vs-schema/test005.rdf      be obsoleted    o resolves that  a copy of that test case be created as an error test  case    o actions DaveB to create test cases for the above cases    o actions DaveB to identify any similar cases to those above and  create      test cases to cover them also  ]]]  ---------      Jeremy Carroll asked for clarification that this still allows rdf:_NNN  as a typed node.  Dave Beckett indicated that it did.    Dan Connolly seconded proposal.    No objections to the proposal, no abstentions.       ACTION 2001-11-30#4 Dave Beckett: Create test cases covering reserved  use of rdf names in this proposal.     DECISION 2001-11-30#3 Reserve use of names in the rdf namespace as in  agenda.    Para 196  --------  Eric and Ron who were both in the first WG, clarified that the second  URL in para 196 is not a typo; but was intended to reserve namespace for  future use.    Jeremy Carroll seconded Dave Beckett's e-mail proposal that para 196 be  dropped.    Discussion.       DECISION 2001-11-30#4 'Delete' para 196 from Syntax WD.  [Scribe pedantic note: while the discussion was in terms of deleting  this paragraph, since it is in a different document, it is more a  question of not including it].     ACTION 2001-11-30#5 Dave Beckett: Create test case showing that the  2nd URL in Para 196 is permitted.    11: Datatypes  Action 2001-11-16#9 FrankM  --------------------------    Continued.  Action 2001-11-16#10 Jeremy WebOnt working group.  ---------------------------    Done - but no meaningful response - too early in WOW-G process.    Action 2001-11-16#11 MikeD DAML+OIL joint committee.  --------------------------     Both Pat Hayes and Mike Dean reported back from the Joint Committee.    Apparant summary: P preferred, then U, then S, which could be lived  with.      ACTION 2001-11-30#6 Mike Dean: Sumamrise Joint Committee position,  confirm with them, circulate to us.      Review Sergey's document and status of ongoing discussions.  ----------------------------------------------------------    Many positive comments on Sergey's document.  General discussion: particularly about Perl datatyping, and its  relationship to Jena and Squish datatyping.  Brian observes that there is increasing support for something other than  S.      ACTION 2001-11-30#7 Pat Hayes: Write up P for inclusion in Sergey's  document.    ACTION 2001-11-30#8 Dan Connolly: Write up Perl datatyping proposal as  e-mail to group.    ACTION 2001-11-30#9 Jeremy Carroll: Write up XML Schema structures  datatyping proposal as e-mail to group.      The meeting ended as the bridge died.    13: Issue rdfms-aboutEach  NOT REACHED    14: Issue: rdfms-assertion  NOT REACHED    15: Semantics of Reification - what progress  NOT REACHED        My own log of the IRC, followed by rough notes:  ==============================================    *** jjc (jjc@dhcp-07.ilrt.bris.ac.uk) has joined #rdfcore  *** Topic is: RDF Core Telecon: 10AM EST | sagan.openprojects.net in  case of instability | +1 630 536 3003 room #3003  *** Topic set by AaronSw on Fri Nov 30 2:59 PM  *** bwm (bwm@dhcp-10.ilrt.bris.ac.uk) has joined #rdfcore  *** xena (xena@mewtwo.espnow.com) has joined #rdfcore  <AaronSw> .time  <em> +pat  <xena> 2001/11/30 15:00:04.85716 Universal   * AaronSw dials  <em> +ericm  <em> +ron  <em> +steve  *** gk (~GK@host213-120-28-173.webport.bt.net) has joined #rdfcore  <dajobe> +bwm, jjc, jan, dave  *** Mode change [+o bwm] on #rdfcore by ChanServ  *** spetschu (spetschu@24.83.162.109) has joined #rdfcore  *** spetschu (spetschu@24.83.162.109) has left IRC  [niven.openprojects.net irc.openprojects.net]  *** dajobe (~cmdjb@tatooine.ilrt.bris.ac.uk) has left IRC  [niven.openprojects.net irc.openprojects.net]  *** logger_2 (~rdfcore-l@tatooine.ilrt.bris.ac.uk) has left IRC  [niven.openprojects.net irc.openprojects.net]  *** AaronSw (aaronsw@mewtwo.espnow.com) has left IRC  [niven.openprojects.net irc.openprojects.net]  *** em (~em@dhcp065-024-049-132.columbus.rr.com) has left IRC  [niven.openprojects.net irc.openprojects.net]  *** xena (xena@mewtwo.espnow.com) has left IRC [niven.openprojects.net  irc.openprojects.net]   * gk dialing...  *** em (~em@dhcp065-024-049-132.columbus.rr.com) has joined #rdfcore  *** xena (xena@mewtwo.espnow.com) has joined #rdfcore  *** AaronSw (aaronsw@mewtwo.espnow.com) has joined #rdfcore  *** Mode change [+oo em AaronSw] on #rdfcore by niven.openprojects.net   * AaronSw reconnects  *** AaronSw (aaronsw@mewtwo.espnow.com) has left IRC [Remote closed the  connection]  *** dajobe (~cmdjb@tatooine.ilrt.bris.ac.uk) has joined #rdfcore  *** logger_2 (~rdfcore-l@tatooine.ilrt.bris.ac.uk) has joined #rdfcore  *** Mode change [+o dajobe] on #rdfcore by niven.openprojects.net  *** jjc is now known as jjcscribe  *** DanC (~connolly@adsl-208-190-203-68.dsl.kscymo.swbell.net) has  joined #rdfcore   * DanC switches to sagan...  *** AaronSw` (aaronsw@mewtwo.espnow.com) has joined #rdfcore  *** DanC (~connolly@adsl-208-190-203-68.dsl.kscymo.swbell.net) has left  #rdfcore  *** Mode change [-oo dajobe em] on #rdfcore by ChanServ  *** Mode change [-o bwm] on #rdfcore by ChanServ  [jjcscribe] 1: jjc is scribe  *** DanC (~connolly@adsl-208-190-203-68.dsl.kscymo.swbell.net) has  joined #rdfcore  <em> agenda ->  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Nov/0641.html  [jjcscribe] Agenda 2: Roll Call  *** spetschu (spetschu@24.83.162.109) has joined #rdfcore  [jjcscribe] reghrets DanB  [jjcscribe] Brian pres  [jjcscribe] Eric Present   * AaronSw` whistles a well known melody.  aaronsw  <AaronSw`> Hmm.  [jjcscribe] +DaveB  [jjcscribe] -FrankB  [jjcscribe] +Jeremy  [jjcscribe] Reg DanC  [jjcscribe] +RonD  [jjcscribe] -BillD  [jjcscribe] +Jos  [jjcscribe] -Rael  [jjcscribe] +Jan  [jjcscribe] reg martin  [jjcscribe] -yoshi  [jjcscribe] +graham  [jjcscribe] -MichaelK  [jjcscribe] -Kwon  *** AaronSw` is now known as AaronSw  [jjcscribe] -Ora  [jjcscribe] +FrankM  [jjcscribe] -satoshi  [jjcscribe] +steve  [jjcscribe] -PiereR  [jjcscribe] +PatrickS  [jjcscribe] +Aaron  [jjcscribe] -MikeD  [jjcscribe] -Guha  [jjcscribe] +PatH  *** em (~em@dhcp065-024-049-132.columbus.rr.com) has left IRC  [niven.openprojects.net irc.openprojects.net]  *** xena (xena@mewtwo.espnow.com) has left IRC [niven.openprojects.net  irc.openprojects.net]  [jjcscribe] -Sergey  [jjcscribe] +MikeD  *** em (~em@dhcp065-024-049-132.columbus.rr.com) has joined #rdfcore  [jjcscribe] +danC  *** JosD (nobody@un.impressive.net) has joined #rdfcore  [jjcscribe] 3: Review Agenda  [jjcscribe] No AOB  [jjcscribe] 4: Minutes  [jjcscribe] No comments  [jjcscribe] Minutes approved  [jjcscribe] 6: Status of Primer   * DanC dials in...  <AaronSw> +Pat -Sergey  <DanC> ouch; no sergey?  *** mdean (~mdean@hh1114013.direcpc.com) has joined #rdfcore  *** mdean is now known as mdean_  <AaronSw> Hmm, I'm seeing a lot of lagg.  [jjcscribe] Eric would like help - coownership.  [jjcscribe] Eric would like co or primary editor  [jjcscribe] Eric rejects casual offers of help  [jjcscribe] Eric wants serious help!  [jjcscribe] FrankM volunteers has co-editor  [jjcscribe] Decision: FrankM is co-editing Primer   * gk test  <DanC> test... this logged?  <AaronSw> yes  [jjcscribe] 7: Model Theory  <AaronSw> Model Theory Status  <AaronSw> Pat: sorry, i'm late... i think i'll the thing i promised by  next ??  [jjcscribe] Pat is late, ... action continued.  [jjcscribe] 8: Syntax  <AaronSw> Syntax Status  [jjcscribe] DaveB: No Progress  [jjcscribe] DaveB: TestCases is published.  <AaronSw> Dave: i now have 2 WDs and i need some help  <AaronSw> bwm: let's stick to syntax  <AaronSw> dajobe: gonna spend some time next week on this  [jjcscribe] DaveB hopes to have something by end of next week  <AaronSw> ... hope to have something to next week for the WG.  [jjcscribe] Will have stuff that emits triples  <AaronSw> dajobe: have to finish writing out the rules, sketch out more  sections (reification, aboutEach, etc.)  <AaronSw> ... write some introductory material  <DanC> pointer to current syntax WD editor's copy? (is there a pointer  on the WG home?)  <dajobe> yes  [jjcscribe] 9: rdfs-transitive-subProperty  <AaronSw> Approving Jos' Test Case  [jjcscribe] Nobody has reviewed  <AaronSw> no one yet approved it...  <AaronSw> ACTION DanC, PatH take a look at the test case.  [jjcscribe] Action: PatH to review rdfs-transitive-subProperty  [jjcscribe] Action:DanC to review rdfs-transitive-subProperty  [jjcscribe] 10: Manifest Proposal  <AaronSw> Jan: manifest proposal  <DanC> would the keybard-monster pls mute?  *** mdean_ (~mdean@hh1114013.direcpc.com) has left IRC  [niven.openprojects.net irc.openprojects.net]  *** DanC (~connolly@adsl-208-190-203-68.dsl.kscymo.swbell.net) has left  IRC [niven.openprojects.net irc.openprojects.net]  *** spetschu (spetschu@24.83.162.109) has left IRC  [niven.openprojects.net irc.openprojects.net]  *** AaronSw (aaronsw@mewtwo.espnow.com) has left IRC  [niven.openprojects.net irc.openprojects.net]  *** logger_2 (~rdfcore-l@tatooine.ilrt.bris.ac.uk) has left IRC  [niven.openprojects.net irc.openprojects.net]  *** dajobe (~cmdjb@tatooine.ilrt.bris.ac.uk) has left IRC  [niven.openprojects.net irc.openprojects.net]  [jjcscribe] Jos needs rdfs and rdf entailment clairifcation  <gk> Jos has problems with lack of distinction between RDF entailment,  RDFS entailment, etc  [jjcscribe] Jan invites Jos to suggest modification, inventing test type  *** mdean_ (~mdean@hh1114013.direcpc.com) has joined #rdfcore  *** spetschu (spetschu@24.83.162.109) has joined #rdfcore  *** DanC (~connolly@adsl-208-190-203-68.dsl.kscymo.swbell.net) has  joined #rdfcore  *** AaronSw (aaronsw@mewtwo.espnow.com) has joined #rdfcore  *** dajobe (~cmdjb@tatooine.ilrt.bris.ac.uk) has joined #rdfcore  *** logger_2 (~rdfcore-l@tatooine.ilrt.bris.ac.uk) has joined #rdfcore  <AaronSw> ... also log:includes and log:notIncludes to work on  <AaronSw> ... hoping that jan would unify, but I can take that over as  well  <AaronSw> bwm: where does this text belong? test cases wd?  <AaronSw> ... who will edit that doc?  [jjcscribe] Brian: we need an owner for test cases  [jjcscribe] Brian asks Jan to co-edit Test Cases wd  <AaronSw> Jan volunteers.  [jjcscribe] Jan thinks he can edit it.  <AaronSw> DanC: we have 3 mos.  [jjcscribe] Jan will come back if he does not have enough time (in a  week or two)  <AaronSw> bwm: more an issue of having an owner than getting it out  <AaronSw> jos: i'll help with technical things  <AaronSw> jjc: important to keep test cases up-to-date  <AaronSw> [ access considerations to W3C server ]  <AaronSw> ACTION Jan: Give access to the Test Cases WD.  [jjcscribe] Action Jan to get access to appropriate space on W3C site  for Test Cases  [jjcscribe] Dave asks for team contact support  <AaronSw> s/Give/get/  <DanC> I think Jan's action is to request that Eric give him access.  [jjcscribe] Action Jan to find out what is needed in terms of access  [jjcscribe] Item 11 Datatypes  *** JosD (nobody@un.impressive.net) has left IRC [niven.openprojects.net  irc.openprojects.net]  *** em (~em@dhcp065-024-049-132.columbus.rr.com) has left IRC  [niven.openprojects.net irc.openprojects.net]  [jjcscribe] Sergey still absent - postponed  [jjcscribe] 12: rdfms-names-use  [jjcscribe] seconded by DanC  *** em (~em@dhcp065-024-049-132.columbus.rr.com) has joined #rdfcore  <AaronSw> 12: RDF Names Use  <AaronSw> 2nded by COnnolly  <AaronSw> danc: rdf:_nn not special  [jjcscribe] JJc asks if rdf:_NNN is strill allowed as tryped node  <AaronSw> no objections, no abstentions  [jjcscribe] daveB yes  [jjcscribe] |Proposal agreed  [jjcscribe] Action DaveB to create test cases  <AaronSw> ACTION dajobe: take test cases  [jjcscribe] P196?  *** Server connection lost  Dan indicates that P196 was to reserve namespace for future use.      Brian: some have not implemented this at all         some have assumed that it was a typo      Jeremy reminds group that DaveB proposed dropping this para         seonds proposal    Dan wants to keep some record    Pat suggests footnote    Aaron points out this is the URI of M&S    Action DaveB to create test case showing this name is not special  Decision drop para 196   no dissent    Dave points out no update of syntax doc is required.    +Sergey    11. Datatypes    Action 11-16#9 continued         11-16#10 done - but no responses since too early         11-16#11 with DAML+OIL       Pat: indicates that Patel-Schneider believes that blank node  proposals (incl S)   violate current XML practice       The use of range specs is common and is a good thing.     Brian indicates that this includes lexical mappings.     PatH issues to do with union datatypes and lexical mappings      Can of worms.        P preferred, U could be accomodate, S could be lived with.      Action Mike to summarise joint committee position, confirm with them,  get back to us      Sergey's doc  ------------    Dan: "great", Graham's stuff should be incorporated.    Dan gives overview of Perl typing.    Jena & Squish take this view.    PatH thinks of Perl as bcpl of thinking        stops using type info as a constraint.    patrick: appreciates Perl      In perl using string comp is on lexical forms            whereas int comp is on value       leaves decision as to which space is left to operator      Graham: propogramming languages stuff maybe misleading    DanC: Perl documentation says there is one type "scalar"    DanC reiterates e-mail about entailment    Brian proposes we include something about P proposal    Action Pat to write P proposal in .    DanC will write up Perl approach      DaveB and FrankB interested    Jjc will write up       Meeting cut off.        

      >  > Ah... then about this bit:  >  > -------  > The use of the phrase "asserted triple" in the third condition is a  > deliberate weasel-worded artifact, intended to allow an RDF graph or  > document to contain triples which are being used for some  > non-assertional purpose.  > -------  >   -- http://www.w3.org/TR/2002/WD-rdf-mt-20020214/  >  > I suggest it's time to get rid of the weasle-words.  >  > The most straightforward thing to do is to strike that text.  > That's my preference.      I second that proposal.    Dark triples have now wasted a hold load of time and money.    They have a cool name; and may strike Pat and Peter as a cool idea.    But they are not in RDF M&S; they are not necessary; they do not clarify  M&S; they are not in charter.    Jeremy        

          In Patrick's Part I a datatyped valued is represented in the graph as a  pair: a URI and a unicode string in the lexical space.    My take is that what we were really heading for is that in the abstarct  syntax the graph node is labelled with the value.    The test case is:    <rdf:Description>    <eg:prop rdf:datatype="&xsd;deciaml">2.00</eg:prop>  </rdf:Description>    is equal (i.e. syntactically)    <rdf:Description>    <eg:prop rdf:datatype="&xsd;deciaml">2.0</eg:prop>  </rdf:Description>      (I think it is also equal to    <rdf:Description>    <eg:prop rdf:datatype="&xsd;int">2</eg:prop>  </rdf:Description>    but I would need to check the XSD specs)    Jeremy        

        Patrick:  > But it seems that no'one (myself included) feels that the  > answer is 'yes' (apart from perhaps Jeremy, though he has  > not responded to this question directly) so I'll drop it.    Whilst it is good of you to keep thinking of me, I have decided that I am  too far from the group consensus to contribute positively to the process.    I have lost quite what the "question" refered to above was, but it seems  that the e-mail has settled on a rational point (which I disagree with).    In some contexts the literal string "25" in the model theory denotes the  literal string "25" but "according to our shared understanding" there is a  corresponding value of 25. The 25 does not occur in the model theory, but  the application is expected to use it.    Personally I detect doublethink. If the specification indicates that the  application should use 25 when it receives "25" then wherever the official  line at which the model theory stops there is an implicit and  ill-articulated extended conceptual model which has the value 25 in it. That  is the conceptual model that the specifications expect the application  writer to use (and document authors ...). My earlier argument that the  datatyping proposal was non-monotonic is refuted up to the model theory.  This is from the clarity that there is only "25" and not 25. But the  argument still stands as far as the conceptual model goes.    It seems that the clarity of this thread that one idiom delivers 25 whereas  the other delivers "25" should be made clear in the document, and an  explicit admission that the disideratum of interoperability between the  global and local type mechanism has not been met.      Jeremy        

            I agree that these are possible weaknesses, I think the schedule issue is   an important one. Please suggest improvements - possibly to do with use of   this document, and a separate rebuttal that consists of  a) the blow-by-blow account I added in today's draft  b) discussion of wider issues such as schedule and no compelling reason for   delay    Jeremy    Graham Klyne wrote:    > Concerning:  >   > [1]  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2003Sep/0259.html  > [2]   > http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2003Sep/att-0259/i18n-part.html   >   >   > I'd like to record my unease over the general approach of this argument   > [2], to the extent that (a) it doesn't entirely reflect what I felt was   > the WG's reason for sticking with the current design, and (b) the   > coverage of design alternatives discussed is possibly spurious or   > incomplete.  >   > My apologies for not chiming in with this sooner, but the first time I   > read a draft of this text I found myself feeling uneasy and confused   > without any real focus for such feelings.  >   > My perception is that we chose to stick with the current design because:  > (a) the desire for "seamless" evolution from plain to XML literals was   > articulated very late in the day, and had not previously been part of   > our design goals,  > (b) a more complete treatment of this desideratum would require   > extensive changes to many of the documents at a very late stage in the   > overall process at a time when the group really needs to complete its   > work quickly if it is to deliver value to the community,  > (c) we do not feel we have been presented with a sufficiently compelling   > argument that the current design is broken in any fundamental or fatal   > way, and  > (d) we have been trying to minimize dependence on XML of the core design   > of RDF (other than the XML serialization syntax).  >   > The draft justification [2] dwells very much on details of specific   > design choices we might have made, which I do not feel fully captures   > the true situation.  In short, I perceive our position is:  > - we really, really need to finish soon;  > - the current design is not fatally flawed;  > - to find an alternative acceptable design will cause a major delay.  >   > As it stands, the draft seems to consist almost entirely of details that   > justify the final point above.  >   > I'm not claiming that anything in Jeremy's draft [2] is wrong.  If my   > perception is not matched by others in the WG, and folks feel this   > really does fully capture the group's position, then I am content to let   > it stand (having hereby had my day in court, so to speak).  >   > #g  > --   >   > At 15:17 26/09/03 +0300, Jeremy Carroll wrote:  >   >> I made some minor changes, in particular dropping the very limited   >> discussion  >> I had of two designs as not worth the space.  >>  >> Also added link to the legacy message of earlier  >>  >> http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2003Sep/0249  >>  >> Jeremy  >   >   > ------------  > Graham Klyne  > GK@NineByNine.org  >         

          > The inclusion of lang tags for XML literals as defined  > in the last call specs was found to cause substantial  > problems both for the MT and for clarity and usability.  > I'm quite confident to bet that the WG will *not* be  > putting them back in.  >    As the member of the WG who recorded an abstention at the vote on the  crucial proposal that Martin objects to, I note that I am now convinced that  the WG has made the right decision.    Jeremy        

        Not sure if this is a swbp or www-rdf-interest thing ...    Noted that in the IRC at the end of yesterday's meeting:    [re wordnet, the big issue to my mind is whether, if we map noun terms to  RDF classes, what namespace URI to use (end in # vs /) since that affects  what you can do by derferencing a term]    I am just thinking about constructing an infinite ontology (i.e. an ontology  with an infinite number of terms in it, slightly more interesting than  rdf:_1, rdf:_2 ...)  This is for language tags, and the infinite number of terms comes from  permitting unregistered extensions to an RFC 3066 tag    My thought is to have it so that e.g.    lang:en-us and lang:en-gb-scouse  work in a tractable way of having a namespace binging    xmlns:lang="http://someserver.example.org/lang.jsp?tag="    Thus the URI for lang:en-us is    http://someserver.example.org/lang.jsp?tag=en-us    Is this good practice or bad practice?    This URI would retrieve everything you need to know about this tag (e.g. its  relationship with en) but if you want to know about en-us-boone's  relationship with this tag you need to get  http://someserver.example.org/lang.jsp?tag=en-us-boone    i.e. I think I can structure my infinite ontology so that getting all the  URIs you have in your hand gives you that finite subset that you need.    (I guess I could do this with a URI ending in "/" and some magic on the  server - certainly would have difficulty ending in "#")    It seems to me that it is bad practice to have a namespace name in RDF that  ends in a character permitted in an NCName (because then there is a problem  finding the splitpoint)    Jeremy        

            Graham Klyne wrote:      > Changes requested are:  > ACTION: 2003-08-29#5 gk to liase with JJC on removal of WS "fudge" \  >         from concepts  > ACTION: 2003-08-29#7 (all editors) update cross-references to 5 Sept \  >         documents  >   > Since I don't have the pen, nor am I sufficiently familiar with pubrules   > procedures, it was understood that I'd ask you to actually apply the   > changes.  Is this OK?  >         Yes I had indicated willingness to prepare for publication.  I had missed the WS fudge ACTION, but that's already done.      > ...  >   > Also, I took an action:  >   > ACTION: 2003-08-29#3 gk check CONCEPTS 6.4 wrt details of URI and "%"  >       Taken onto the list (and pfps)    Jeremy        

        RDFCore WG minutes for the telecon 2001-10-12    Transcript:    http://ilrt.org/discovery/chatlogs/rdfcore/2001-10-12  Agenda:    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Oct/0173.html      Summary:    Actions:  ========    ACTION 2001-10-12#1:  Pat     Review domain and range test cases    ACTION 2001-10-12#2:  Art     Review domain and range test cases    ACTION 2001-10-12#3:  Jos     Change domain and range test cases to use example.org.    ACTION 2001-10-12#4:  Graham      Bring identity of anonymous resourcese back to the table for next week.    ACTION 2001-10-12#5:  Frank M.      Respond to Graham's text, see agenda 2001-10-12, item 12.    ACTION 2001-10-12#6:  Jos    Send interpretation properties URL to e-mail list.    ACTION 2001-10-12#7:  Sergey    Summarise rdfs-xml-schema-datatypes issue for next week's telecon      Decisions:  ==========    Decision 1:    The WG accepted Art's proposal    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Oct/0171.html    Decision 2:    The WG approved the rdfs-no-cycles-in-subClassOf test cases.    Decision 3:     The WG approved the rdfs-no-cycles-in-subPropertyOf test cases.    Other:  ======  There was no support in the teleconference for dropping parseType="Literal".      1: Allocate scribe: Jeremy Carroll      2: Roll Call    Participants:      - Eric Miller      - Brian McBride (chair)      - Art Barstow      - Dave Beckett      - Jeremy Carroll      - Ron Daniel      - Jos De Roo      - Martyn Horner      - Graham Klyne      - Frank Manola      - Sergey Melnik (from item 12 onwards)      - Stephen Petschulat      - Aaron Swartz      - Mike Dean      - Pat Hayes    Regrets:      - Daniel Brickley      - Dan Connolly      - Bill deHora      - Jan Grant    Absent:      - Frank Boumphrey      - Rael Dornfest      - Yoshiyuki Kitahara      - Michael Kopchenov      - KWON Hyung-Jin      - Ora Lassila      - Satoshi Nakamura      - Pierre G Richard      - R.V. Guha      3: Review Agenda      Aaron proposed adding singing of Golden Triples to agenda.    Ron proposed adding discussion of parseType="Literal" to agenda.      Both additions were accepted by the chair, although we were out    of time before the singing.      5: Review Minutes of previous meeting       APPROVED      4: Next telecon - 10am Boston time, 19th October 2001       DECIDED: Meet at same time next week.     Pat offered regrets.      6: Confirm Status of Completed Actions       CONFIRMED DONE      7: Confirm Folling actions are withdrawn       Brian and Eric agreed that the action 2001-08-17#5 is withdrawn.      8: Tidying up broken Test cases    The following actions have been completed:  ACTION 2001-09-28#5  Dave Beckett  Fix test case errors  ACTION 2001-09-28#6  Jeremy Carroll  Re-post problem found in test case  ACTION 2001-09-28#8  Art Barstow  Delete test cases containing                       rdf:aboutEachPrefix  ACTION 2001-09-28#9  Art Barstow  Investigate best W3 practice in                       deleting test cases    The following action is continued:    ACTION 2001-09-28#7  Jan Grant  Remove xml:base from test cases    Decision 1: The WG accepted Art's proposal  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Oct/0171.html    [Scribe note: the URL in the agenda and the transcript was incorrect:    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Oct/0322.html  ]        9: Propose approve cycle in subClassOf test cases        These test cases have been reviewed by:      Art Dave Jos and Pat    Decision 2:    The WG approved the rdfs-no-cycles-in-subClassOf test cases.      10: Propose approve cycle in subPropertyOf test cases      These test cases have been reviewed by:       Dave, Jos, Art    Decision 3:    The WG approved the rdfs-no-cycles-in-subPropertyOf test cases.      11: Review domain and range test cases      Dave has had a quick look at these test cases.    Art requested more time for review.    ACTION 2001-10-12#1:  Pat     Review domain and range test cases  ACTION 2001-10-12#2:  Art     Review domain and range test cases      Art suggested that all test cases should use example.org as the    default host name.    ACTION 2001-10-12#3:  Jos     Change domain and range test cases to use example.org.      12: Issue: Identity of anonymous resources  The WG did not agree the text in the agenda.    Ron disagreed with there being no URI for anonymous nodes.  Ron had not noticed the decision that bNodes are existentially quanitified.  Frank Manola wanted to question the specific wording.    Frank asked what the text was for (i.e. which document would it go in).  Brian responded that the text was for the issue list.    There was general animated discussion that was curtailed by an unhappy  chair.  The chair argued that consensus on this issue had been reached at the  face-to-face.  The chair was unhappy with late objections.    The chair requests the naysayers to make a substantive case as to what is  wrong with the emerging consensus.    There was an attempt at a vote on the issue. This attempt was aborted since  there was a need for separating quibbles with the wording from substantive  disagreement.    ACTION 2001-10-12#4:  Graham      Bring identity of anonymous resourcese back to the table for next week.    Graham noted that this involves formulating a simple votable question.    ACTION 2001-10-12#5:  Frank M.      Respond to Graham's text, see agenda 2001-10-12, item 12.      13: Syntax Sub-group Report      http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Oct/0119.html    The quick summary was:     The syntax subgroup likes Relax NG     Jeremy is working on a transform approach to triples.     The syntax subgroup has identified the syntactic issues in the issue  list.    Jos asked whether the Syntax subgroup was using XSLT. This question was left  open.      14: Issue rdfs-xml-schema-datatypes:  Review Progress    Sergey reported that e-mail discussion is on-going.  Pat noted that his discussions with Peter Patel-Schneider were progressing  positively.    Sergey preferred to postpone further teleconference discussion of this issue  while the e-mail discussion advanced.    ACTION 2001-10-12#6:  Jos    Send interpretation properties URL to e-mail list.    ACTION 2001-10-12#7:  Sergey    Summarise rdfs-xml-schema-datatypes issue for next week's telecon      AOB: 15: parseType="Literal"      Dan C had suggested in e-mail that this be dropped.  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Oct/0151.html    Ron and Dave opposed this.      There was no support in the teleconference for dropping  parseType="Literal".      Ron presented three use cases:    A: In PRISM a particularly editorial style uses XHTML <I> elements within  RDF values e.g.      <ns:title rdf:parseType="Literal"><i>CRN</i> Interviews: Tom  Cruise</ns:title>      B: Including XHTML paragraph breaks in RDF values.      C: For i18n, there is a need for XML markup for bidi and Ruby amongst  other things.      There was extended discussion that continued after the close of the  meeting.    Issues included discussion of how namespaces figure with literals, and  whether an RDF Literal is marked as to whether it came from an  rdf:parseType="Literal" production.      The meeting closed without singing the Golden Triples.        

          > I probably have my facts wrong - I haven't checked the documents:  >  > There are two possible behaviours:  >  > a) leave extra ".."'s in the path  > b) delete extra ".."'s.  >  > a is legal in 2396 and not in 2396bis  > b is legal in 2396 (but not recommended) and in 2396bis  >  > You are recommending we fix on a?  >  > Brian  >    My earlier understanding was that b was not legal but tolerated in RFC 2396.    Unfortunately, I had misread RFC 2396 - I just reviewed it ...    It seems that my understanding was correct except that a is not legal  either, but tolerated to a greater extent. Hence the pedant in me suggests  the test should in fact be an illegal document.    I'll have a look at 2396bis - to see if that helps.      On this topic - the section I had read said:    [[  C.2.  Abnormal Examples       Although the following abnormal examples are unlikely to occur in     normal practice, all URI parsers should be capable of resolving them     consistently.  Each example uses the same base as above.       An empty reference refers to the start of the current document.          <>            =  (current document)       Parsers must be careful in handling the case where there are more     relative path ".." segments than there are hierarchical levels in the     base URI's path.  Note that the ".." syntax cannot be used to change     the authority component of a URI.          Berners-Lee, et. al.        Standards Track                    [Page 30]    RFC 2396                   URI Generic Syntax                August 1998            ../../../g    =  http://a/../g        ../../../../g =  http://a/../../g       In practice, some implementations strip leading relative symbolic     elements (".", "..") after applying a relative URI calculation, based     on the theory that compensating for obvious author errors is better     than allowing the request to fail.  Thus, the above two references     will be interpreted as "http://a/g" by some implementations.  ]]    with the earlier paragraphs suggesting the behaviour of retaining the .. is  recommended and the behaviour of stripping the .. is implementation  variation.    However, in the main body it says:    [[  5.2. Resolving Relative References to Absolute Form    ...          g) If the resulting buffer string still begins with one or more           complete path segments of "..", then the reference is           considered to be in error.  Implementations may handle this           error by retaining these components in the resolved path (i.e.,           treating them as part of the final URI), by removing them from           the resolved path (i.e., discarding relative levels above the           root), or by avoiding traversal of the reference.    ]]    which suggests that the normative behaviour is to barf.        

        >   > This change shouldn't break earlier code since rdf:li as an element  > name was not explicitly in the old grammar (except by matching the  > old typedNode) and the feedback from the probably, only, implementors  > who looked at the change is the reason we are junking it!  >   +1    I'll be absolutely heart-broken to delete the ARP code that does this!!    Jeremy        

          Running ARP against the zip    all_20021213.zip    I had the following incorrect results (two not mine):    datatyping - my error - test001 test002    rdfms-nested-bagIDs 008 old nt file is correct, new one is wrong.    rdf-ns-prefix-confusion 0007 should be OBSOLETE.    (The version of ARP used is not yet publicly available - it should be in   the jena2 cvs on sourceforge before christmas).      Jeremy        

        > 8. (related). The definitions of rdf and rdfs entailment have been  > simplified so that they do not make explicit reference to a  > vocabulary. This is actually more conventional; and Herman pointed  > out that the more complicated definitions meant that entailment might  > not be transitive (aargh). The motive for introducing this  > complication in the definition in the first place has been removed by  > subsequent changes. This doesn't change any test cases.  >    My understanding is that test cases do change - in particular the test cases      >   rdfms-seq-representation/Manifest.rdf#test002  >   rdfms-seq-representation/Manifest.rdf#test004    which were incorrect according to the LC2 semantics doc, now become correct.  So this is a substantive rather than an editorial change. (I am awaiting  feedback from HP implementors concerning this)    Jeremy        

          Dave Reynold's original comment:  http://lists.w3.org/Archives/Public/www-rdf-comments/2003JulSep/0076.html    [[  PositiveEntailmentTest xmlsch-02/Manifest.rdf#whitespace-facet-3 - FAIL     This tests bNode introduction - that a typed literal entails a graph     with a bNode of type rdf:Literal. We have deliberately omitted the     bNode introduction rules from the reasoner config on the grounds that     this is not the way an RDF API should do it - users can query the     nodes themselves for type information and creating virtual triples     for this would be wrong from an API perspective.    ** Failures - could fix:  NegativeEntailmentTest xmlsch-02/Manifest.rdf#whitespace-facet-2 - FAIL  NegativeEntailmentTest xmlsch-02/Manifest.rdf#whitespace-facet-1 - FAIL     These test non-mutual entailment of a valid literal with an invalid     literal that differs only by whitespace. Unfortunately our XSD     handling library is happy with the whitespace and doesn't     treat " 3 " as an invalid int.     This could be fixed if that is indeed how XSD is supposed to work,     though the current behaviour seems more useful in practice.  ]]    Patrick.Stickler@nokia.com wrote:    > Could someone please provide a pointer to the actual comment...  >   > Thanks,  >   > Patrick  >   >         

      >  > However, I still think that most people who write something like  >  > foo rdfs:range xsd:integer .  >  > would intend to be saying that the range of foo was integers as  > defined by xsd.  >    Talking with Brian it seems it would have been clearer for our WG to have  used xsd:integer.map throughout the TDL proposal - at least that's the way  model theory worked out.    The TDL proposal only uses the value without its lexical representation in  the application space (above the model theory).    The way the mdoel theory for TDL is clear about type is to always have both  the literal string and the typed value.    Jeremy        

        >  >  > One thing to bear in mind is DAML's requirements.  Should we  > consider cases  > where a daml:unambiguousProperty and a daml property with cardinality  > constraints take parseType=Literal values.  >    I had been forgetting this.    DAML/OWL does need literal equality over xml literals.    So we should, IMO, give words that allow for that.    I still think we could leave some implementation freedom over the unusual  namespaces. (i.e. the namespaces involved in the sentences with too many  relative clauses!)    A namespace used in a qname in an attribute value in an xml literal in RDF  that is not visibly used in an enclosing element within the same xml  literal.    Noting that full interoperability is not achieved for this case seems better  than trying to over-engineer for it.      Jeremy        

            Patrick.Stickler@nokia.com wrote:      >   > If the entities are not ever being resolved at any  > stage of the parsing process, then that worries me  > alot. It suggests that an RDF/XML parser is not  > playing by the rules of XML fully.  >   > Patrick      The parser expands the entities - and then uses the rules specified in the   C14N rec to put entities back in. These may (but usually aren't) the same   as the ones that got expanded.    Jeremy        

            pat hayes wrote:    >   >> This is the usual weekly call for agenda items for this weeks   >> telecon.  On my list of possibles I have:  >>  >>   o approve datatype test cases  >>   o issues arising after publication - eds - are there any you need to   >> discuss  >>   o the last deliverable  >   >   > What is the value space of rdf:XMLLiteral?      I defined it as the set of canonical XML documents with rdf-wrapper as the   root tag.  Perhaps there is a slight lack of clarity in that I am talking about   Platonic documents rather than actual documents. The "canonical" word sort   of makes that an angels on pinhead discussion rather than one with any real   content.    I don't know whether anyone would care to argue whether a document is or is   not an XSD string. I would think not ... an xsd:string is a sequence of   unicode code points, whereas a document is a sequence of bytes (a canonical   XML document is a sequence of bytes in the UTF-8 charcater encoding).          > Can one create a synonym for rdf:XMLLiteral, and if so does it invoke   > the same datatyping rules??  >       The question is ...    rdf:XMLLiteral owl:sameIndividualAs <eg:dt> .  _:a <eg:a> "a"^^<eg:dt> .    hmmmm ....    which is easier? we could prohibit it.    Jeremy        

          > I think I'm probably pushing for more of a tangible solution that  > the rest of you, due I'm sure to my practical "build it so it will work"  > mentality.  >    I think we are all on-board that goal ... but we also should be doing the  best theoretical job we can within the constraints of actually being useful!        > > I see that as a publisher's choice.  >  > Well, it's a publisher's choice what machinery they choose to use  > to indicate assertion/authenticity -- but ideally there would be  > a well defined model/methodology to do so which most publishers  > and agents would both use -- and that requires a reasonable  > definition of how those "bootstrapping" interpretations are done.  >  > As shown in numerous examples, a bunch of statements and the RDF  > and OWL MTs don't get you there. You end up either with the  > chicken/egg question (how can a graph that is not asserted contain  > a statement that asserts it) or the authenticity question (how do  > we know that the authority of a graph as identified in a graph  > actually is the origin of the graph).  >  > I think what we need to do is to (eventually) provide a model  > that publishers will want to use because it provides useful  > answers to the above two questions.  >  > Patrick    Agreed - the most obvious is that the assertion chain should bottom out with  a graph that:  - asserts itself  - and includes its own signature  - with a minimum of inference (e.g. none)  - possible contains noting else except assertions and signatures of other  graphs    A potential information-consumer can verify that signature, and particularly  if the graph does not contain other stuff, will be happy to accept the graph  as true - and the heart of the boot-strap is completed.    Jeremy        

          As actioned at telecon:  rdf:nodeID  http://www.w3.org/2000/10/rdf-tests/rdfcore/rdfms-syntax-incomplete/    rdf:ID, rdf:bagID is like xml ID    http://www.w3.org/2000/10/rdf-tests/rdfcore/rdfms-rdf-id/    I've also tried to write the Manifest files.    Jeremy        

        An additional note about deliverables    Jeremy Carroll wrote:    > DELIVERABLES  > A WG Note describing the issue resolutions or the failure to resolve  > An OWL Ontology describing the value spaces of the XML Schema builtin simple  > Datatypes.      Personally, I would like the TF to publish a first version of the note very   quickly (e.g. one month after kick-off, late June maybe, assuming a   kick-off over a beer in new york).  This first version would:  - describe the two issues  - describe one or more possible solutions  - ask for public feedback, possibly with a deadline    After the deadline, the TF would propose a resolution with rationale for   consideration by both WGs - if this proves acceptable the TF succeeds,   otherwise it fails. Either way it documents the result in second version of     note.    I guess I could redraft with such a plan and schedule explicit.    Jeremy        

      > RDF C14N Max or Min  > ===================  > Should the new RDF specs try to maximally or minimally specify  > the behaviour  > of RDF processors w.r.t. rdf:parseType="Literal"  >  >    An issue that I began to bring up in the message on equality was are we  trying to bless as much as possible the current behaviour of RDF  implementations, or are we trying to specify as tightly as possible  'correct' behaviour (hence breaking all current implementations).    The trade off is that a maximal specification will:  - break all existing systems  - be harder to implement  - provide a better foundation for interoperability    A minimal specification will  - almost bless some existing implementations  - not commit to decisions that we are not yet in a position to know the  answer to.  - provide sufficient interoperability for some test cases and perhaps for  the model theory    I think both cases are fairly difficult to understand, because C14N provides  a barrier.  Whether it is easier or more obscure to push that difficulty into the  equality algorithm I don't think I can judge.    My take on what is a maximal and minimal solution is as follows:                                 Min        Max  Comments                     No         Yes  Excl/Incl                    Excl       either  NamespacePrefixList          No         Yes  SyntaxOrEquality             Equality   Syntax    Although almost any combination of features is plausible.        

          Not sure who EricP is, please forward this ...    My only real bit of user input on this one is a guy in spain who uses arp  with RDF in which the embedded XML Literal includes processing instructions,  which he wants preserved. These can't be finessed away very easily.    A test case I use in ARP development is:    <rdf:Description>  <tp:representacionXul rdf:parseType="Literal">  <?xml-stylesheet href="/sistema-acceso/css/bindings.css"  type="text/css"?>  <?xul-overlay href="/sistema-acceso/xul/c4d_common.xul"?>  <xul:window ID="Simulacion" title="Pantalla de Simulacion"  xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"  xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"  xmlns:c4d="http://www.isegware.com/rdfs/au/c4d.rdfs">  <vbox></vbox>  </xul:window> <!--  A comment.  -->  </tp:representacionXul>  </rdf:Description>    Jeremy    > -----Original Message-----  > From: Graham Klyne [mailto:GK@NineByNine.org]  > Sent: 12 February 2003 20:10  > To: Jeremy Carroll  > Cc: www-archive  > Subject: RDF-concepts: <rdf-wrapper>  >  >  > Jeremy,  >  > Some questions were being asked about <rdf-wrapper> in IRC.  I don't know  > if I got the intent right.  But there was a suggestion or two that might  > avoid the need to use <rdf-wrapper>.  >  > Transcript follows.  >  > [[  > <gk> Eric, as I recall, <rdf-wrapper> stuff is to make a well-formed  > document so that canonical form can be described by simple  > reference to XML  > C14N specification.  It feels a bit kludgy, but I couldn't see a  > neater way  > to do it.  > * danbri wishes http://www.idleworm.com/nws/2002/11/iraq2.shtml  > were in SVG  > <danbri> gk, is rdf-wrapper in the Syntax spec anywhere?  > *** grove_ has joined #rdfig  > * DanCon returns from call, wonders where we are on the calendar agenda;  > adjourned?  > <ericP> gk, i'd recommend saying that each child of the propertElt with  > parseType="Literal" is a exc-c14n document  > <danbri> adjourned, i believe.  > <DanCon> thx  > <gk> Danbri, not as I recall.  It's part of the mapping from  > abstract graph  > to the domain of interpretation.  > <danbri> it has angle brackets in it, so seems syntaxy...  > <ericP> if i find such a literal as a result of a query, will it have  > <rdf-wrapper> around it?  > <danbri> depends on the query api  > <gk> Eric, I'd be happy to suggest that to Jeremy, but is that  > enough?  What about the space between the children?  I don't know XML  > subtleties well enough to know.  > <ericP> so that i need to XPath my real data out?  > <danbri> presumably we won't see <rdf-wrapper> in ordinary rdf  > serializations?  > <ericP> gk, inter-children space, hmm, thinking...  > <gk> danbri, absolutely; not in RDF/XML serialization.  > <ericP> what if rdf-wrapper were made more abstract, ie, some element, so  > that folks would never try to put it in or take out out with XPath.  > <ericP> ?  > <amy> bye all  > *** amy has quit IRC ("Leaving")  > <gk> As I understand it, it's just a device to help the formal  > specification, and (maybe) the description of equivalend RDF graphs under  > XML canonicalization.  The presence of XML literals in the RDF somewhat  > middies that issue, I think.  > <ericP> assuming my current interp is correct, that it is a temporary  > construct to make sure the canonicalization starts one down from the root  > element  > *** DanCon changes topic to 'RDF & Semantic Web hack'n'chat  > http://rdfig.xmlhack.com/'  > <ericP> algorithm:  > <gk> Eric, I think there's a problem of exposition if folks are  > tempted to  > put in <rdf-wrapper> in their XPath.  > <ericP>   get byt string from API or parser  > <ericP>   stick inside <rdf-wrapper>  > <ericP>   allpy exc-c14n  > <ericP>   remove from <rdf-wrapper>  > <ericP>   stick in graph  > <ericP> done  > *** arnarl has quit IRC ("Client Exiting")  > <gk> Eric, I'm very sympathetic.  Don't know if that's enough.  I believe  > the intent of what you describe matches the WG intent.  > <ericP> i'll think about this and see if i can come up with anything  > <zoyd> other than RDF, what else will/does make the semantic web happen ?  > <ericP> right now, my code (serving annotea) does something like that,  > except it doesn't need to stick it inside <rdf-wrapper> as that  > fucntionality is available in my canonicalizer  > <ericP> other than inter-child spaces, is there an affect of the  > <rdf-wrapper>  > <ericP> ?  > <ericP> (other than to confuse my poor canonicalizer's understanding of  > which namespaces are currently in play)  > *** Ol has left #rdfig  > <gk> Eric, you just reminded me:  <rdf-wrapper> is also used to bring the  > appropriate language tag into play.  I suppose that might be done on each  > child element.  But now I feel the complexification of this approach may  > start to bite.  > ]]  >  > #g  >  >  > -------------------  > Graham Klyne  > <GK@NineByNine.org>  >  >        

      I have looked at these, and agree.  Jeremy    > -----Original Message-----  > From: w3c-rdfcore-wg-request@w3.org  > [mailto:w3c-rdfcore-wg-request@w3.org]On Behalf Of Dave Beckett  > Sent: 18 March 2002 14:50  > To: w3c-rdfcore-wg@w3.org  > Subject: Changes to rdfms-empty-property-elements tests  >   >   >   > I mention in the last meeting that some tests had to change in light  > of literal decisions and N-Triples being updated.  Here are some that  > I've just made:  >   > Changed literal result to be xml"" rather than ""  >   >     > http://www.w3.org/2000/10/rdf-tests/rdfcore/rdfms-empty-property-e  > lements/test003.nt  >     > http://www.w3.org/2000/10/rdf-tests/rdfcore/rdfms-empty-property-e  > lements/test009.nt  >   > Dave  >   >         

        Brian:  > Jeremy, what did you intend?    I try to pass the hot potato to Pat!    (A more serious answer to Graham)    > I also understand that, following DanC's requests,  >   >    _:x ex:prop "foo" .  >    ex:prop rdfs:range xsd:string .  >   > will be satisfiable in conformance with xsd:string datatypeconstraints.    No decision - the current drafts say NO.    Concepts say a literal is a pair.  Ntriples says "foo" goes to "foo"-""  Model theory says untyped literals are self-denoting.    "foo"-"" is not an xsd:string.    >   > But, what about this:  >   >    _:x ex:prop "http://example.org/" .  >    ex:prop rdfs:range xsd:anyURI .    Similarly, currently this is a NO.    >   > #g  > --  >   > PS:  in my subject line, I say "test cases", which these are strictly   > not.      They could be made so by the invention of a new test case.    Jeremy        

            The current editors' version is at:    http://sealpc09.cnuce.cnr.it/jeremy/RDF-concepts/20021121/Overview.html      This is still being worked on ...    Anticipcated changes include:    - moving authority stuff forward in 2.4, and rewriting with text from DanC.  - adding some sort of comment about syntactic vs semantic equality  - deleting unused refs, moving some refs between normative and informative    Jeremy        

        You may be right, "you are IMO just us much out on the fringes of, or   beyond, RDF-land", let's hear Pat ... he's back from his travels.      Jeremy      Patrick Stickler wrote:    >   > On Mar 30, 2004, at 15:12, ext Jeremy Carroll wrote:  >   >> Patrick Stickler wrote:  >>  >>>>> Section 8.1: "We require [the value of the swp:signatureMethod   >>>>> property]  >>>>> to be a literal URI, which can be dereferenced on the Web..."  >>>>> Question, what is the difference between a URI and a literal URI? Do  >>>>> you mean rdfs:range xsd:AnyURI?  >>>>  >>>>  >>>>  >>>> xsd:anyURI I think - a literal URI denotes itself in the RDF Model   >>>> Theory and hence can then be used for dereference operation, whereas   >>>> a URIref node denotes a resource, presumbably the same resource as   >>>> that for which you get a representation when you dereference it, but   >>>> that takes us well into the social meaning issue, that we are trying   >>>> to skirt around.  >>>  >>> But wouldn't you be *wanting* to denote the resource, the method itself?  >>> Otherwise, anything said about that method would not be stated in terms  >>> of that URI.  >>> I don't think the range/value should be a literal. I think it should  >>> be the method itself, denoted by a particular URI, which might be  >>> dereferencable (or might not).  >>  >>  >> In theory I agree, in practice I don't - let's hear what Pat has to   >> say on this one. In theory, whenever you use a web dereferencable URI   >> the resource denoted has a representation that is got by the URI-GET,   >> however that is not a part of RDF Semantics and I don't think it is   >> for this paper to add it.  >   >   > I'm not suggesting that we add anything to the RDF semantics.  >   > This is why I suggested that the value be a resource -- and whether  > the URI denoting the resource is web resolvable or not is not significant  > to the function of that resource -- which is simply to serve as a commonly  > agreed method (however/wherever defined, regardless of the web).  >   > By specifying that the value is an xsd:anyURI literal, you are IMO  > just us much out on the fringes of, or beyond, RDF-land than talking  > about whether the URI used resolves to a representation that defines  > the method in question.  >   > A signature method is a thing/resource, and we'd probably want to use RDF  > to talk about that method in pretty significant detail. Using a literal  > precludes that (in any practical sense).  >   > I don't see it as any different than a vocabulary term. If it's best to  > use xsd:anyURI values to denote methods, than it's just as valid to use  > xsd:anyURI values to denote vocabulary terms (if literals could be  > subjects or predicates, that is ;-)  >   > Patrick  >   >   > --   >   > Patrick Stickler  > Nokia, Finland  > patrick.stickler@nokia.com  >         

          Sergey, Patrick,    this discussion presupposes a Model Theory for TDL which Patrick has  explicitly not furnished.    Of course I am going to solve the issues with a stroke of a magic wand.    When the magic happens either be amazed and applaud or (more likely) offer  criticism at that point!    Jeremy    > -----Original Message-----  > From: Patrick Stickler [mailto:patrick.stickler@nokia.com]  > Sent: 19 January 2002 10:16  > To: ext Sergey Melnik  > Cc: www-archive@w3.org; Jeremy Carroll  > Subject: Re: Problem with TDL (EVEN BIGGER ONE)  >  >  > On 2002-01-18 22:41, "ext Sergey Melnik" <melnik@db.stanford.edu> wrote:  >  > > Patrick,  > >  > > thank you for the clarification. In fact, your approach suggests a third  > > original idiom, in which typed elements are interpreted as pairs (value,  > > lexical representation). I'm going to accommodate this idiom in the  > > datatyping document that I'm editing.  > >  > > However, under the above interpretation, your document [1] is  > > inconsistent. The figures in 3.1 and 3.2 can only be consistent with  > > each other, if literals (rectangles) are interpreted as pairs. This is  > > fine, but you run into the issue that the interpretation of literals is  > > context-sensitive (i.e. not fixed, but depends on the property that the  > > literals are handing off). So, for example, the literals hanging off  > > rdf:value are now also interpreted as some kind of pairs.  >  > I'm not sure I follow you. The idiom requires that rdf:value has  > a literal value. It is not a recursive idiom. You can't have  > an anonymous node with an rdf:value that is itself an anonymous  > node with an rdf:value....  >  > Perhaps this is not specified clearly enough in the discussion  > of the idiom. I will try to make that clearer.  >  > Note though, that this is an issue with the idiom, not the TDL  > model.  >  > The separation from the TDL model and the idioms employed is  > intentionally strict -- so that each idiom is simply a means  > of expressing a pairing, and the pairing itself is the foundation  > of interpretation.  >  > > Furthermore, your scheme *does* require modifications the the present  > > RDF graph model: it is based on untidy graphs, quite in contrast to what  > > you claim! In other words, you cannot just merge two literals with the  > > same content together (they might represent two different pairs,  > > depending on the properties they are hanging on).  >  > My understanding of graph tidying is that nodes with literal labels  > and anonymous nodes are never merged. Only nodes with URIref labels.  >  > Thus, you would never merge two literals. Every literal node (every  > instance of a lexical form) is unique in the graph.  >  > If this is not correct, then that's *major* news to me, and I'll  > have to go back and re-re-re-re-read the MT and other relevant  > discussions.  >  > Thus, per my present understanding, TDL is based on tidy graphs,  > and both of the defined idioms are valid for tidy graphs without  > the problems you indicate.  >  > Also, again, if it turns out that I am mistaken about the tidying,  > it is only an issue of the particular idiom, and not of the TDL  > model itself.  >  > Regards,  >  > Patrick  >  > > All in all, given your clarification, your scheme is a specialized  > > variant of Patel-Schneider's/Hayes' one, but with some false claims...  > >  > > Sergey  > >  > > [1] http://www-nrc.nokia.com/sw/TDL.html  > >  > >  > > Patrick Stickler wrote:  > >>  > >> On 2002-01-18 4:42, "ext Sergey Melnik" <melnik@db.stanford.edu> wrote:  > >>  > >>> Patrick,  > >>>  > >>> there is a well-known problem with the rdf:type/rdf:value  > representation  > >>> that you described in  > >>>  > >>> http://www-nrc.nokia.com/sw/TDL.html  > >>>  > >>> In essence, the interpretations of nodes _1 and _2 in  > >>>  > >>> _1 rdf:value "3.0"  > >>> _1 rdf:type us-double  > >>> _2 rdf:value "3,0"  > >>> _2 rdf:type german-double  > >>>  > >>> fall together (_1 and _2 represent the same real value), and  > the pairing  > >>> between the lexical representation and the type gets corrupted.  > >>> Specifically, the semantics of the above four statements is equivalent  > >>> to that of  > >>>  > >>> _3 rdf:value "3.0"  > >>> _3 rdf:value "3,0"  > >>> _3 rdf:type us-double  > >>> _3 rdf:type german-double  > >>>  > >>> How do you suggest to work around this problem?  > >>  > >> There is no problem.  > >>  > >> The nodes _1 and _2 would *never* be merged in that fashion.  > >>  > >> 1. They do not denote the same value space member of the same  > >> datatype as us-double is not the same datatype as german-double.  > >>  > >> 2. Neither anonymous nodes nor literal labeled nodes participate  > >> in graph tidying.  > >>  > >> The fact that the TDLs ("3.0",us-double) and ("3,0",german-double)  > >> may correlate to the equivalent member in each other's value spaces or  > >> in the value space of e.g. xsd:double is a matter  > >> of interpretation -- not of representation.  > >>  > >> E.g.  > >>  > >> <rdfl:LexicalDatatype rdf:about="xsd:double"/>  > >>  > >> <rdfl:LexicalDatatype rdf:about="us:double">  > >>    <rdfl:lexicalSubClassOf rdf:resource="xsd:double"/>  > >> </rdfl:LexicalDatatype>  > >>  > >> <rdfl:LexicalDatatype rdf:about="german:double">  > >>    <rdfs:subClassOf rdf:resource="xsd:double"/>  > >> </rdfl:LexicalDatatype>  > >>  > >> which defines, as we would expect, that the value  > >> space of both us:double and german:double are subsets  > >> of the value space of xsd:double but only the lexical  > >> space of us:double is a subset of the lexical space  > >> of xsd:double.  > >>  > >> (note the difference between rdfs:subClassOf and  > >> rdfl:lexicalSubClassOf!)  > >>  > >> And if we know that the value spaces of us:double  > >> and german:double are in fact a perfect intersection,  > >> then we can also say  > >>  > >> <rdfl:LexicalDatatype rdf:about="us:double">  > >>    <rdfs:subClassOf rdf:resource="german:double"/>  > >> </rdfl:LexicalDatatype>  > >>  > >> <rdfl:LexicalDatatype rdf:about="german:double">  > >>    <rdfs:subClassOf rdf:resource="us:double"/>  > >> </rdfl:LexicalDatatype>  > >>  > >> which says that any member of the value space of  > >> us:double is also a member of the value space of  > >> german:double and visa versa.  > >>  > >> Thus, there is no problem.  > >>  > >> The nodes in your example would never be merged, and  > >> the relationships between the lexical and value spaces  > >> of the datatypes in question are explicitly defined,  > >> and interpretation about whether the two TDLs  > >> ("3.0",us-double) and ("3,0",german-double) denote  > >> the same value happen outside the RDF-space, yet  > >> the RDF representation -- using the TDL scheme -- is  > >> fully sufficient for making that interpretation.  > >>  > >> Cheers,  > >>  > >> Patrick  > >>  > >> --  > >>  > >> Patrick Stickler              Phone: +358 50 483 9453  > >> Senior Research Scientist     Fax:   +358 7180 35409  > >> Nokia Research Center         Email: patrick.stickler@nokia.com  >  > --  >  > Patrick Stickler              Phone: +358 50 483 9453  > Senior Research Scientist     Fax:   +358 7180 35409  > Nokia Research Center         Email: patrick.stickler@nokia.com  >  >  >        

          Pat:    > 1. [Patrick?] and Graham want range-sensitive inline literals.  > 2. Dan C. wants an inline literal used with no datatyping to  > unambiguously denote a character string.  > 3. We all want the logic to be monotonic.    > Something has to give.      I want range-sensitive inline literals.  For me that was a major motivation for TDL, and an attraction of P.  It is also IMO the only *requirement* as opposed to *disederata*.    As I see it, we have four different worked out proposals for inline  literals:   S-B   P (with Bermuda triangle model theory)   TDL global   Syntactic transform to rdf:value    The first three are all talking about the same idiom      <Jenny> --ex:age--> "15"  ex:age --some:range--> eg:Integer .    and the differences lie in the subtly of the model theoretic treatment.      S-B provides no model theoretic treatment other than tidiness.  P+Bermuda and TDL both provided some model theory at the expense of  tidiness.  P+Bermuda is superior to TDL.    The syntactic transform, where the two triples above somehow get transformed  into three triples:      <Jenny> --ex:age--> _:bnode --> "15" .  ex:age --some:range--> eg:Integer .    has the advantage of maintaining tidiness and delivering an integer.  Also any non-monotonicity can be buried within whether we use the transform  or not.  A further advantage is that by making inline literal idiom datatyping part  of the graph the treatment of datatyped values is explicit in the data model  (which many users understand) as opposed to hidden away in the model theory  (which is generally difficult).     Perhaps we should drop all other disiderata. i.e. just do this, and do it  in such a way as we remain agnostic about which model theoretic treatment  (S-B or P+Bermuda) we use.    The only practical differences are whether certain corner case descriptions  are ill-formed or not.    (eg. prop --range--> integer, prop--range--> string, r--prop-->"10")    We can punt on the model theory for datatyping, and provide a syntax for the  one bit we can agree on.    Jeremy        

            Alan Rector wrote:    > Chris  >   > Agreed.  The message was primarily to the WebOnt group, and sent here   > for information and possible support.      Sorry I had misunderstood that.    Jeremy        

        The attached version is a current snapshot - I already have a long list of   corrections etc from myself and Chris - however I am off home now, so it   won't be til tomorrow afternoon that the next version is ready.    Particular interest is sections 4 and 8 with semantics and section 7 that   tries to cover the semantic web publishing.    I suggest this as a heads up, maybe a "looks good" or "seriously wrong"   binary type response at this stage, with a more detailed review tomorrow   after I've worked in the current comments.    Further tasks will be:  - do we want to model it differently (i.e. move the classes and properties   around)  - do we want to rename things  - do we need some more examples to make say bootstrapping clearer  - what other sections do we need  ...    Jeremy          Jeremy            application/pdf attachment: ng.pdf          

        incorporating comments ...                application/pdf attachment: ng.pdf          

        Tim:  > > > I hope that RDF will move toward unicode strings as primitives, and  > > > langauges as properties.  { "chat"en  =  [lang:en "chat"].}  > >  > > This would, of course, require untidy literals, and we just decided  > > to make literals tidy.  > >  > > If languages as properties, in conjuction with literals as subjects,  > > is truly is a desirable feature in the future, should we rethink tidy  > > literals?  > >  > > If literals remain tidy, then that closes the door on languages  > > as properties.  >  > There must be some other assumption here; because we *can* have tidy  > literals and { "chat"en  =  [lang:en "chat"].} and not use literals as  > subjects just by letting the xml:lang attribute entail the extra Bnode.  >    Sorry I am flogging a dead horse.    Maybe, but using Tim's encoding (which I like), would be a lot easier if we  had chosen to follow Pat's    http://www.coginst.uwf.edu/users/phayes/simpledatatype2.html    instead of lumbering him with a specific reading for the S-B idiom.    From simpledatatype2:    [[[  Thus, a triple such as    Jenny ex:age "35" .    in effect means that the value of the property is something that can be  indicated by the literal label. RDFS provides a way to say this explicitly:    Jenny ex:age _:x .  _:x rdfs:dlex "35" .    where the second triple asserts simply that _:x is a value which can be  represented by the character string. This does not in itself 'fix' the  value, of course, but it can be used as a way of making the association  between the value and a lexical form explicit, for later use or  amplification. We will call this a lexical form triple. A useful way to  think of the meaning of rdfs:dlex is: "..can be described by the character  string.." or "..can be a value of the literal..."    These two forms - the single triple with a literal as object, and the  similar triple with a bnode as object, together with a lexical form triple  linking the bnode to the literal - are identical in meaning and can be  substituted freely for one another. The first is obviously more compact and  often easier to 'read', but the second form provides distinct nodes for the  literal itself and for its value, which is sometimes useful.    ]]]    One time useful is to encode language.    e.g.      Jenny ex:age "35"en-US .    <==>    Jenny ex:age _:x .  _:x rdfs:dlex "35" .  _:x rdfs:lang "en_US" .      Flogging a dead horse    Jeremy        

          > Again, there are better ways to model language qualification than  > xml:lang (even though at the expense of additional triples) and  > the fact that lang tags for plain literals are invisible to generic  > inference rules is IMO a far greater shortcoming of the final  > solution than not having lang tags on XML literals. But that's another  > (and probably needless, at this moment) discussion.      This perhaps suggests that what we should be doing is noting we were not   chartered to improve the I18N support in RDF, but however feel that there   is at least room for exploration - requirements gathering etc. Hence we   could create a new issue "I18N and the semantic web" and postpone it for   consideration by the coordination group.    I believe we have already fulfilled our charter obligations to clarify the   I18N support already in M&S; we have also updated much of the M&S work in   light of advances in charmod; we have made it much clearer how XMLLiteral   is meant to work. We have exceeded what we had to do, but I fear that there   is still more that could be done, and probably should be done in the next   phase. We have postponed one I18N issue to do with language ranges, I   wonder if we should not at least suggest to the CG that, after RDF and OWL   are at Rec, it would be worth having a task force with adequate I18N IG   support to at least scope what else could be done.    Jeremy        

        Jeremy:  > Option 1:  > XMLLiteral ceases to be a typed literal but we revert to the old  > treatment  where it was simply a special.      Patrick:  > My strong preference is then for option 1, reverting (in a sense)  > XML literals to the M&S definition.  >  > This has the additional benefit that lexical forms can be left  > as-is in the graph per the RDF/XML serialization and only need be  > canonicalized when testing for equality.  >  > Thus, plain and XML literals both may take lang tags and neither  > are typed literals nor fall within the scope of RDF datatyping.  >  > Typed literals do not take lang tags, period.  >  > This avoids all the headaches relating to the bizzare datatype  > rdf:XMLLiteral.  >  > Patrick  >  >    The old treatment was in say:  http://www.w3.org/TR/2002/WD-rdf-concepts-20020829/    I think that the reagle issue resolutions would in the main stay, and the  canonicalization would still be specified in the syntax, but with the  implementation note that makes it clear that they "only **need** be  canonicalized when testing for equality."    I have three concerns about this option:    a) we had comments  http://lists.w3.org/Archives/Public/www-rdf-comments/2002JulSep/0092.html  linking to  http://www.w3.org/2002/07/29-rdfcadm-tbl.html#xtocid103643    and    http://lists.w3.org/Archives/Public/www-rdf-comments/2002JulSep/0165.html    both of which would need resurrecting, since we have followed up saying that  we have changed in the way they sort of wanted.      b) how difficult would it be for Pat to go back and rework    c) impact on OWL support for XML Literals - webont are generally negative  about them, the more work they have to do, the less support there will be in  OWL for these.    Jeremy        

          > -----Original Message-----  > From: Aaron Swartz [mailto:me@aaronsw.com]  > Sent: 28 April 2002 18:08  > To: RDF Core; Jeremy Carroll  > Subject: Clarification of charmod-uri  >  >  > I am not (yet) planning to protest the decision we made about unicode  > strings in URIs, but I would like some clarification.  >  > 1) Is there some reason why these Unicode characters cannot be  > %encoded? I  > thought someone said something to this effect on the telecon,  > but I didn't  > catch it. If not, what's the rationale for insisting on a  > backwards-incompatible change, when the (comparatively)  > backwards-compatible  > %encoding works just as well?    One reason concerns normal form C issues, and how %-encoded URIs get  displayed.    In a system that %-encodes URIs for storage and reasoning it is highly  desirable that they get unencoded for display. As we have seen there are  multiple ways under unicode of representing characters such as e. Retaining  these within unicode it is possible to specify and realistically expect  implementations of the normal form C constraint - i.e. that the unicode  must be normal form C. This constraint becomes significantly more difficult  to check (i.e. less something that can realistically be expected of a  unicode library) if the check is does this %-encoded uri correspond to a  UTF-8 encoding of a unicode string that is not in NFC.    I see a significant risk of URI fraud in an international context if there  is no normal form c constraint. I see this constraint as looking highly  unrealistic if it is made on %-escaped URIs.    A further issue is to do with interoperability of lower and upper case %  encoding.    The standard treatment of URIrefs is to do as little processing as  possible. So xml namespaces differ if the uri-ref differs in spelling, not  intent. In particular:    http://example.org/#Andr%c3%a9    and    http://example.org/#Andr%C3%A9    are different as far as XML Namespaces goes.    If we assert that these are both identical to    http://example.org/#Andre    we need to account for how they are the same under RDF.    ---    A less significant reason is showing that preserving the original input  characters is mandatory (these are the most useful way to display the URI  on output).      >  > 2) Am I correct in saying that this means that RDF will no  > longer be using  > URI-refs to identify Resources? Is this consistent with our charter?      Misha argues that RDF M&S has already had its meaning "clarified" in this  way by errata 26 against XML second edition. (I would confess to having  sense of a non-backwardly compatible clarification, rather like the  unqualified attributes issue!).    See:  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Mar/0012.html          >  > 3) Does this mean we will allow other characters like %20  > (space) into our  > URIs that have traditionally been %encoded? If not, how do we  > decide what's  > allowed and what isn't?    The approved test case  http://www.w3.org/2000/10/rdf-tests/rdfcore/rdf-charmod-uris/test002.rdf    shows that % escaped URIs are still legal.  Do you think a %20 case would also be helpful.    test003 and test004 (see the manifest) divorces the meaning of the %  escaped URI from the non-% escaped URI, at least for the RDF MT. I have  suggested that this should be seen like alternative spelling of what is  operationally the same URI (e.g. http: vs HTTP: ).      >  > 4) Which spec is going to describe these new identifiers? The IRI spec[1]  > seems to have fifteen rather complex but relevant pages on them. Can we  > afford the extra time it may take to integrate these and review them?    I am against referring to the IRI spec (it is a draft and does not yet have  a consensus around it).    The best texts I have seen are:   http://www.w3.org/TR/xlink/#link-locators  and   http://www.w3.org/XML/xml-V10-2e-errata#E26    Either of these is short enough to be copied and edited.    >  > All the best,  > --  > [ "Aaron Swartz" ; <mailto:me@aaronsw.com> ; <http://www.aaronsw.com/> ]    I feel some sense of failure at having arrived at such a singular lack of  consensus on this issue. I do agree with the sense at the telecon that it  was better to make the decision now, and see how much support or dissent it  generates in the wider community; but regret that we have not had a fuller  debate in telecon and e-mail. I would particularly like to hear from Jos  and Brian as to why they voted against.    For instance, while I have surfaced the uri fraud issue before, I don't  think I have discussed the lowercase/uppercase % encoding issue. Both of  these have helped form my opinion that the resolution we came to was a good  one.    I also note that I am influenced by a sense of the inappropriateness of an  historic limitation of the US phone system (that the eighth bit used to be  dirty) should limit the functionality available to web users around the  world. If this has been significant in our voting then perhaps that could  raise charter issues.    Jeremy        

          Patrick is "fully versed in XML 1.0".      One minor point, you use local entity defs to simulate qnames in attr  values.    This is quite cute, but does go against this para in M&S:    [[[  Note: Schema developers may be tempted to declare the values of certain  properties to use a syntax corresponding to the XML Namespace qualified name  abbreviation. We advise against using these qualified names inside property  values as this may cause incompatibilities with future XML datatyping  mechanisms. Furthermore, those fully versed in XML 1.0 features may  recognize that a similar abbreviation mechanism exists in user-defined  entities. We also advise against relying on the use of entities as there is  a proposal to define a future subset of XML that does not include  user-defined entities.  ]]]      I am happy to drop the intent of this paragraph - that seems to be a  corollary of Patrick being "fully versed in XML 1.0" :).      Jeremy        

          Some doubt has been expressed whether this issue is in scope.    See M&S section 6 has text:    [[[  Two RDF strings are deemed to be the same if their ISO/IEC 10646  representations match. Each RDF application must specify which one of the  following definitions of 'match' it uses:  ]]]    i.e. paras 217 - 219 (incl note)    http://lists.w3.org/Archives/Public/www-archive/2001Jun/att-0021/00-part#217    This text has an explicit ambiguity which the early uniform normalization  model addresses.  Hence this issue is within the core purpose of this group to clarify M&S.    Jeremy        

        Short version: "SHOULD" in literal equality considered dangerous.      I am not particularly wedded to SHOULD, and next time the WG considers this  I will suggest MUST.    As for    > Presumably the alternative choices would have been to deprecate the  > language tags on RDF literals, in favor of either using XML  > with parsetype literal, <d:name rdf:parseType="literal"><span  > xml:lang="fr">chat</></>  > or RDF itself    > d:name    [ lang:french "chat" ];    > The latter I of course find by far the most manageable.  > But I am sure you have all been all around the options.      I take that to be specifically out of charter for this WG; in that I find  M&S to be consistent and clear on this and I believe that my suggested  (Unicode String,Lang-Tag?) pair representation of a literal to be a more  explicit rearticulation of what it says.    While that isn't perfect, I believe xml:lang is used by RDF users and there  is no critical problem with it.    Jeremy        

      Bill:  > RDF doesn't need a veto on all the values, just some of them: the M&S  > seems over constrained at this point. DAML and Tim Berners Lee have had  > the foresight to use a prefixed value that will play with namespaces;  > possibly we can't expect others to do likewise.  >  > What is _not_ perfectly clear is whether M&S users should crack ahead  > and extend parseType in the hope that if the M&S catches up, it won't  > run them over. Whatever about qualifying parseType attributes, the wg  > should export a clear stance on the matter of parseType extensibility.    We could reserve all unprefixed parseTypes for RDF use, and say that  extensions should use namespaced prefix attributes; thus blessing DAML and  TBL without a significant change to M&S.    Jeremy        

      Dave:  > >   * Provides only one way to encoded the literal-structures  > >     and so in that sense is canonical.  Graham:  > Also good - simple-minded applications may still do string  > comparison, right?      Hmmm, ....    we still have to decide that, ....    Dave:  >   xml("<b>foo</b>")              XML content, no language  what about xml("<b >foo</b>") is this:  a) not legal ntriple  b) legal but different from xml("<b>foo</b>") (and not representable in  RDF/XML?)  c) legal and the same as xml("<b>foo</b>")      Personally I prefer (c), but I think it is better for the group to not make  this decision until after we have completed the xml literal issues.    For our test cases I think we can choose appropriate canonical strings, so  this needn't slow us down at all.    Jeremy        

        DanBri:  > I just sent one: we would need to decide which version of XPath to  > reference, and understand any costs/risks re blessing XPath 1.0 when 2.0  > is looming.  >    I think this is a misplaced concern.    We *have* a dependency on xpath 1.0 in that we depend on exc-c14n which  depends on c14n which depends on xpath 1.0.    Yes, we have swept that dependency under the transitivity carpet ... but to  make it explicit would not be a substantive change.    A particular issue is to do with processing instructions; the last time I  looked (a while ago) xpath 2.0 was treating these differently than in xpath  1.0. Life is not perfect and of course some of our dependencies are aging.  For the XML 1.0 to XML 1.1 variation we have worked harder to be aware of  the implications. This is not something we have done for xpath 1.0 to 2.0,  and I do not believe we have the energy to do it now.      Jeremy        

      > We both comiserated but at the time, it seemed that producing test cases  > that describe what the M+S said (not what we thought it should say) was  > the honest thing to do; this is the (spurious?) backwards-compatibility  > argument.    I find it spurious.  It is at least as honest to say that M&S does not make sense, and has not  had sense made out of it by the community.    BTW: The first version of ARP implemented my proposed resolution, but Brian  persuaded me that I should do otherwise about version 1.0.3. I probably  would have done better to have dug my heals in then.    Jeremy        

        (picking up on recent message in rdf-interest)    Well, even before we have published the last call syntax spec we seem to   have had four compliant parsers announced!    I suspose it would be rude to publish a proprosed rec before the beginning   of the last call period!    Jeremy        

        This does not look disastrous to me.    In RDF URIrefs ending in # (i.e. with explicitly empty fragment) only  regularly occur as namespace names. All possible uses of such URIrefs  involve qnames which give them a non-emtpy fragment part.    The text in question    "URI producers and normalizers should omit a delimiter if the component it  delimits is empty"    uses a "should" not a "MUST", and is hence sufficiently weak.    We perhaps could suggest modifying the text:  [[    , with one exception: a double-slash delimiter indicating an authority  component should not be removed, even when the authority is empty, since  doing so can lead to misinterpreting the path.  ]]  http://gbiv.com/protocols/uri/rev-2002/rfc2396bis.html#normalize-empty    to  [[  . A first exception is: a double-slash delimiter indicating an authority  component should not be removed, even when the authority is empty, since  doing so can lead to misinterpreting the path.  A second exception is: a common idiom in RDF/XML uses URI references with  empty fragments as XML namespace names.  ]]    The overall normalization rules in section 6  http://gbiv.com/protocols/uri/rev-2002/rfc2396bis.html#comparison  inevitable create a many positive matches that are not honoured in RDF  concepts. Like XML namespaces we chose the simplest possible definition of  equality: string equality. The overall tone of section 6 ought to respect  such a choice.        Jeremy      > -----Original Message-----  > From: w3c-rdfcore-wg-request@w3.org  > [mailto:w3c-rdfcore-wg-request@w3.org]On Behalf Of Graham Klyne  > Sent: 17 February 2004 13:17  > To: rdf core  > Subject: Heads up: RFC2996bis, possible problem for RDF  >  >  >  > I've just reviewed:  >  >     http://gbiv.com/protocols/uri/rev-2002/rfc2396bis.html  > Modified: 16 February 2004 11:36:15  > Size: 167.42 KB (171437 bytes)  >  > Which has recently been "last called" in the IETF URI informal group in  > preparation for an IESG last-call request, per:  >    http://lists.w3.org/Archives/Public/uri/2004Feb/0082.html  >  > I am concerned that the empty component normalization rules may be  > troublesome for RDF.  My review comments are at:  >    http://lists.w3.org/Archives/Public/uri/2004Feb/0094.html  >  > The specific example raised is:  >  > [[[[  > Section 6.2.2.3:  > I'm concerned about empty component normalization:  > In RDF usage, the URIs:  >      http://example.org/  > and  >      http://example.org#  > would result in quite distinct resource identifiers, e.g. in:  >  > [[  > Triples of the Data Model in N-Triples Format (Sub, Pred, Obj)  >  > <http://www.w3.org/RDF/Validator/run/foo>  > <http://example.org/prop> "value" .  >  > The original RDF/XML document  >  > 1: <?xml version="1.0"?>  > 2: <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"  > 3:   xmlns="http://example.org/">  > 4:   <rdf:Description rdf:about="foo">  > 5:     <prop>value</prop>  > 6:   </rdf:Description>  > 7: </rdf:RDF>  > ]]  >  > and  >  > [[  > Triples of the Data Model in N-Triples Format (Sub, Pred, Obj)  >  > <http://www.w3.org/RDF/Validator/run/foo>  > <http://example.org#prop> "value" .  >  > The original RDF/XML document  >  > 1: <?xml version="1.0"?>  > 2: <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"  > 3:   xmlns="http://example.org#">  > 4:   <rdf:Description rdf:about="foo">  > 5:     <prop>value</prop>  > 6:   </rdf:Description>  > 7: </rdf:RDF>  > ]]  >  > (RDF triples generated by http://www.w3.org/RDF/Validator/)  >  > Are distinct RDF graphs, even though the URIs are equivalent under the  > normalization rules given.  > ]]]]  >  > #g  >  >  > ------------  > Graham Klyne  > For email:  > http://www.ninebynine.org/#Contact  >  >        

      Summary:    RDF Core's interpretation of same-document references within RFC 2396 is  legitimate.  And even if it isn't, it is a legitimate interpretation of a same-document  reference within an RDF document!        Jeremy:  > > e,f,i,j,k,l  > > Base does apply to same document references in RDF/XML  Stuart:  > I think that you're changing the semantics of URI references as defined in  > RFC2396, particularly section 4.2, same document references. I think your  > answers would be correct only for those cases where the in-scope base URI  > and the URI from which the document were retrieved are the same.      Stuart's point of view was expressed clearly (and repeatedly) to the RDF  Core WG during the decision process e.g. issue #1 in    http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Feb/0516.html      Jeremy:  > The positive tests on the test cases web site show a usage of xml:base  > in RDF/XML and the resolution of that usage in terms of the RDF graph  > produced (with absolute URI ref labels).    Paul:  >  It is important that RDF and everyone  > else realize that use of XML Base requires compliance with RFC 2396 which  > requires that relative URI references consisting of just the fragment id  > ignore any base URI and instead always refer to a fragment id within the  > current document.      I do not  recall the RDF Core WG having resolved a justification of the  decision in favour of the these test cases. Hence I will give my own  justification.    First:  The actual decisions of the RDF Core WG reflect what 'same document  references' mean within an RDF/XML document within the scope of an xml:base  attribute. Primarily the WG decisions reflect the meaning of RDF/XML rather  than XML Base of RFC 2396. However, these decisions do point to weaknesses  in RFC 2396.  The RDF Core WG has consistently (with or without xml:base) interpreted all  uri references as absolute uri references. The decisions clarify that when  the normal uri resolution mechanisms deliver a same document reference, we  form the absolute uri ref using the currently in scope xml:base uri.      Second:    The definition of same-document references is unfortunately focussed on  browsing:    [[[  4.2. Same-document References    1 A URI reference that does not contain a URI is a reference to the  2 current document.  In other words, an empty URI reference within a  3 document is interpreted as a reference to the start of that document,  4 and a reference containing only a fragment identifier is a reference  5 to the identified fragment of that document.  Traversal of such a  6 reference should not result in an additional retrieval action.  7 However, if the URI reference occurs in a context that is always  8 intended to result in a new request, as in the case of HTML's FORM  9 element, then an empty URI reference represents the base URI of the  0 current document and should be replaced by that URI when transformed  1 into a request.  ]]]    line 3 "start of that document" is meaningless for an RDF document. RDF is a  graph and is not a linear structure.    line 6 "no additional retrieval action" All URIrefs in RDF are absolute, and  none are retrieved accept when the application content "is always intended  to result in a new request".  The RDF Core is trying to clarify which absolute URI ref corresponds to a  same document ref.    line 9 The answer, at least for empty same document refs, it is the "base  URI".    We discover what a base URI is in section "5.1 Establishing a Base URI"      [[[  5.1. Establishing a Base URI       The term "relative URI" implies that there exists some absolute "base     URI" against which the relative reference is applied.  Indeed, the     base URI is necessary to define the semantics of any relative URI     reference; without it, a relative reference is meaningless.  In order     for relative URI to be usable within a document, the base URI of that     document must be known to the parser.  ]]]    I note that the algorithm in  5.2. Resolving Relative References to Absolute Form  amongst its defects, does not implement line 9 of section 4.2.    Once we are dynamically changing the xml:base from one element to the next,  we are outside the design bounds of RFC 2396.    If we consider only documents with a single xml:base on their outermost  elements, then as far as RDF goes, the resolution of the same document test  cases is consistent with section 4.2 of RFC 2396.  A same document  reference, like any uri ref, in an RDF file means an absolute URI ref. The  absolute URI ref is formed by taking "the base URI" of the document, as  suggested in line 9 of 4.2. The fragment part if taken from the same  document reference.    Jeremy          > > EASY:  > > a "http://example.org/dir/file"      "../relfile"  > > b "http://example.org/dir/file"      "/absfile"  > > c "http://example.org/dir/file"      "//another.example.org/absfile"  > >  > > GETTING HARDER:  > > d "http://example.org/dir/file"      "../../../relfile"  > > e "http://example.org/dir/file"      ""  > > f "http://example.org/dir/file"      "#frag"  > >  > > MASTER CLASS:  > > g "http://example.org"               "relfile"  > >  > > h "http://example.org/dir/file#frag" "relfile"  > > i "http://example.org/dir/file#frag" "#foo"  > > j "http://example.org/dir/file#frag" ""  > >  > > k "mailto:Jeremy_Carroll@hp.com"     "#foo"  > > l "mailto:Jeremy_Carroll@hp.com"     ""  > > m "mailto:Jeremy_Carroll@hp.com"     "relfile"        

          > And charmod?  If you add a dependency here - and it is an addition -  > it's to a WD, not a REC and it would be a new thing that RDF  > implementors would have to look at.  I'm pretty confident we decided  > not to depend on charmod in it's current non-REC state.      See comment in section 4.1. This section is the only one that   normatively depends on charmod.    The problem here is that the concept of early uniform normalization is   sufficiently large amount of text to explain that the reference is the   only realistic way to do it.    I think we formally decided to go with early uniform normalization; I   could try and dig up a reference.    At some level I see this as a negotiating position with the I18N WG.   This para indicates that we are willing, as long as they progress.    It is quite likely that we will have to remove it, and then Charmod   will be demoted to an informative reference.    Jeremy        

          > I think we could go in either of two directions:  >  > A: accept the comment  > "worried that it may not be  >     obvious that the whitespace processing is not part of the process of  >     checking lexical forms for type validity," and add test cases to  > demonstrate that whitespace is significant even inside typed literals of  > types which in a XML Schema context would get processed away (such as the  > integer examples)  >  >    PROPOSE RDF Core accepts the comment xmlsch-02 and agree to add the  following test case:      <rdf:Description rdf:about="http://www.example.org/a">     <eg:prop rdf:datatype="&xsd;int">3</eg:prop>  </rdf:Description>    Does not entail    <rdf:Description rdf:about="http://www.example.org/a">     <eg:prop rdf:datatype="&xsd;int"> 3 </eg:prop>  </rdf:Description>    Moreover the following comment to be added to concepts:    [[  NOTE: In [XML Schema (part 1)], white space normalization occurs  during validation according to the value of the whiteSpace  facet. The lexical-to-value mapping used in RDF datatyping  occurs after this, so that the whiteSpace facet has no  effect in RDF datatyping.  ]]        http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#section-White-Space-Norm  alization-during-Validation        

          I have some sympathy with Peter's position, and I am sorry that Brian did not  give us a chance to comment on his text before sending it.    In particular I think the fact that:      Test A*:       <Jenny> <ageInYears> "10" .     <John>  <ageInYears> "10" .     <ageInYears> rdfs:range xsd:decimal .    holds in all cases is relevant and was omitted.    Jeremy      > -----Original Message-----  > From: w3c-rdfcore-wg-request@w3.org  > [mailto:w3c-rdfcore-wg-request@w3.org]On Behalf Of Brian McBride  > Sent: 11 July 2002 20:04  > To: RDF Core  > Subject: datatypes discussion on other lists  >  >  >  > I have sent, at last, the datatypes message to rdf interest and rdf logic  > and await the explosion.  >  > I have modified it from the draft approved by the WG in the light of recent  > discussion.  I trust the WG will approve of the modification.  >  > At the f2f and elsewhere, concern has been raised the we might simply  > repeat the discussion, in all its confusion and volume, that we have had in  > RDFCore, in a wider forum.  It would be a disaster if that were to happen.  >  > I am not sure what other WG's have done in the past, and would welcome  > guidance from those who have been here before.  >  > However, I strongly suggest that members of the WG refrain from any form of  > advocacy for their preferred position on the other lists.  We are seeking  > input from the community on this issue, not a debate.  >  > I recognise that what is advocacy and what is helpful explanation is a  > difficult line to draw.  I am loathe to suggest gagging people, but I also  > suggest that folks leave it to me to answer for the WG on any questions or  > issues that arise on the other lists.  If anyone is dissatisfied with  > anything I say, then raise that with me first and we will correct it.  >  > Brian  >  >        

        The rdf-schema.rdfs file needs the XML decl, with  <?xml version="1.0"  encoding="iso-8859-1"?>    As it stands, the file is not XML! (Because it uses the default UTF-8  encoding and sousPropriétéDe is ill-formed UTF-8 - it is  iso-8859-1).    Jeremy    > -----Original Message-----  > From: Dave Beckett [mailto:dave.beckett@bristol.ac.uk]  > Sent: 25 September 2001 10:53  > To: Jeremy Carroll  > Cc: w3c-rdfcore-wg@w3.org  > Subject: Re: RDF Schema work-in-progress, URL  >  >  > >>>Jeremy Carroll said:  > > I reworked appendix A, attached, if this is any help.  >  > I guess I should also point I did some of this:  >  >   http://ilrt.org/discovery/2001/09/rdf-schema-tests/  >  > RDFS in RDF/XML (updated) and N-Triples for the schema and examples.  > The N-Triples were generated by my Raptor N-Triples parser, haven't  > been hand-checked yet.  >  >   CVS: http://cvs.ilrt.org/cvsweb/redland/rdfcore/schema/  >  > Dave  >  >        

            Martin Duerst wrote:    > I just have had a look at  > http://www.w3.org/TR/2002/REC-xml-exc-c14n-20020718, and found  > two problems, one of them i18n-related.  >   >   > 1) encoding underspecified?  >   > The exclusive canonical form of a document subset is a physical   > representation of the XPath node-set, as an octet sequence, produced by   > the method described in this specification.  >   > This does not at all say what the encoding is. Is this UTF-8? If yes,  > where is this specified? If no, what is the encoding? Is the reader  > supposed to go check elsewhere?      I found that very clear.  IIRC exc-c14n defers to c14n which specifies UTF-8,  I'll check ...  "The exclusive canonical form ...    is as defined in the Canonical XML Recommendation [XML-C14N] except ..."      and following the link  UTF-8 is in the first bullet point in the definition of canonical form in   section 1.1.        >   >   > 2) what is 'visible'?  >   > The document says "namespace nodes that are not on the InclusiveNamespaces  > PrefixList are expressed only in start tags where they are visible and if  > they are not in effect from an output ancestor of that tag."  > The word 'visible' turns up only one more time, again not in a defining  > context. Readers probably can work out what 'visible' is supposed to  > mean from context and examples, but that's not how a spec should work,  > I guess.  >      Once again I found that clear: #def-visibly-utilizes is the anchor.  I suppose the reader is meant to link visible and visibly        >   > Regards,    Martin.  >   Jeremy        

          I'm with Dave - the current text might be difficult (i.e. requiring reading  at least two other specs to understand one sentence) but it is unambiguous.    Jeremy    Dave:  > That should be:  >  > _:a <eg:prop> "<em><br /></em>^^ rdf:XMLLiteral .  >    :(  it's not what the validator gives ...    Jeremy        

          Also note I have updated the status section specifically to help   commentators understand the current status.    Jeremy        

            Jos De_Roo wrote:      >>>I'm waiting on one thing. As I understand it, the value spaces of  >>>xsd:integer and xsd:decimal no longer intersect.  >>>  >>What?!?!?!?!?  >>  >   > I'm also stupified. On the other hand Pat told us about  > disjoint value spaces in XSD. So far I assumed that  > xsd:integer a rdfs:Datatype; rdfs:subClassOf xsd:decimal.  >       There is no possible reading of XSD that does not have this.    I will try and clarify:    - XSD has primitive simple types (e.g. decimal) and derived simple types   (e.g integer).  - one reading of XSD suggests that different primitve types are disjoint.  - a different reading of XSD suggests that different primtiive types may   share members.  - both readings agree that a derived type has a value space that is a   subset of its supertype.    - we have recently clairified that rdf:XMLLiteral's value space is disjoint   from the value space of any XSD simple type. This decision *does not* say   anything about whether two XSD types intersect or not.      So - knowing that xsd:integer is derived from xsd:decimal, we know that the   two types are also in rdfs:subClassOf relationship.    The test is unchanged, and I believe Jan had got the wrong end of some   stick ...    Jeremy        

          I have been reviewing M&S to see which parts of it are:  - not currently in any of our new specs  - have not been decided to be dropped    These sections appear to be candidates for inclusion in the new top-level  document, fulfilling its dustbin role.    The main content is to do with vocabulary, particularly:  - containers  - reification  - rdf:value    I understand that we are maintaining M&S containers but without formal  semantic support and hence somewhere we need informal but normative text  corresponding to para 90.  http://lists.w3.org/Archives/Public/www-archive/2001Jun/att-0021/00-part#90    I understand that we are maintaining reification but clarifying it as  supporting the provenance use case (and hence 'stating' rather than  'statement'). As such text corresponding to M&S section 4 is needed - (all  subject to complete rewrite).  http://www.w3.org/TR/REC-rdf-syntax/#higherorder    I do not understand what we are doing with rdf:value, but there is a lot of  legacy which is based on stuff written in M&S and we should, IMO, carry some  of that text forward even if we deprecate it.  e.g. show some of the use cases.      While this stuff might belong in the schema specification, the current  schema draft appears to want to be very conservative and not suggest  semantics that are not in the model theory.  e.g.  http://www.w3.org/TR/rdf-schema/#ch_containervocab  http://www.w3.org/TR/rdf-schema/#ch_value    Assuming that we do want to carry such intent from M&S forward, and that the  new document is the right home for that intent, then Graham and I were  thinking of putting it within the document structure as follows (section 5):    1. Introduction  2. RDF overview  * as before *  3. RDF specification  3.1 - 3.4  3.5 RDF vocabulary definitions  3.5.1 RDF defined vocabulary terms  pointer to section 5  3.6 RDF datatyping  3.7 Test cases  3.8 Primer  4. RDF Graphs  * text more or less as already suggested  on formal definition of RDF graph *  5. Informal Semantics of Some RDF Vocabulary  5.1 Containers  5.2 Reification  5.3 rdf:value  6. Additional technical considerations  6.1 Internationalization  6.2 Character normalization  6.3 Conformance  6.4 RDF in HTML  7. Acknowledgments  8. References      Jeremy        

      Sergey Melnik wrote:  > 1 FOUNDATION  > ------------  >   > <SUG1>: I'd like to propose to use the standards specs listed below as a  >         foundation of our work on datatyping:  >   > [XSD] XML Schema Part 2: Datatypes. http://www.w3.org/TR/xmlschema-2/  > (May 2001)  > [UML] Unified Modeling Language 1.4.  > ftp://ftp.omg.org/pub/docs/formal/01-09-67.pdf (Sep 2001)  > [CWM] Common Warehouse Metamodel 1.0.  > ftp://ftp.omg.org/pub/docs/ad/01-02-01.pdf (Feb 2001)  >     I take these last two references to be:    [UML] pp 6-29 => 6-44  and  [CWM] pp 22-491 => 22-508    (I am hoping these sections are moderately self-contained!)    Jeremy        

                  text/html attachment: RDF_Datatyping.htm          

          >>language ::= [a-z0-9][a-z0-9-]+  >>  >>(delete ref to REC-xml#sec-lang-tag)  >   >   > Why?  I guess this is incomplete since it is refering obliquely to  > multiple changing RFCs.  Is checking this unimportant?  Is it defined  > elsewhere that is better pointed at?    This is editorial at this point, sounds as though we should stick with   what you've got.    >   > If I used the above defn, it would be good to explain where it came  > from.    If you ant that then something like grahams text  [[      The language tag is composed of one or more parts: A primary language      subtag and a (possibly empty) series of subsequent subtags.        The syntax of this tag in ABNF [RFC 2234] is:         Language-Tag = Primary-subtag *( "-" Subtag )         Primary-subtag = 1*8ALPHA         Subtag = 1*8(ALPHA / DIGIT)        The productions ALPHA and DIGIT are imported from RFC 2234; they      denote respectively the characters A to Z in upper or lower case and      the digits from 0 to 9.  The character "-" is HYPHEN-MINUS (ABNF:      %x2D).  ]]    is the relevant stuff from RFC 3066, XML got burnt because this was a   change from RFC 1766 which XML initially copied.  In terms of N-triple syntax, a minimal change to your text would be    language ::= ( character - ('.'|'^' | ws )) +    to avoid the ambiguity on datatyping, keeping the comment.    Jeremy        

        If I've understood you want:     to use / instead of # as the namespace separator     doing a get on any of the terms will get a representation of that term     we will collect each schema in a file with an unrelated URL    that seems OK to me. (Who knows what best practice is? :) )    We could also have a trix file with both the rdfg and swp schemas in it,   named by the URIs at which you can get the individual schemas.    On the dc:rights  My copyright is held by "Hewlett-Packard Development Company, LP", put that   last ... (as far as I understand any intellectual property I generate   belongs to them)        Jeremy        Patrick Stickler wrote:  >   > On Mar 31, 2004, at 09:59, ext Jeremy Carroll wrote:  >   >>  >> We need to finalize a namespace URI for this round of publications.  >>  >> I suggest we go with something on Patrick's TriX site since he does a   >> good job of keeping it up to date.  >>  >> So suggest patrick gets to choose a URI directory and the following   >> files therein:  >   >   > The following suggestions follow our vocabulary versioning methodology,   > which  > keeps disjunct the identity of vocabularies from their representations   > (i.e.  > RDF/XML documents, etc.).  >   > Major versions are indicated in the namespace name. Minor versions are   > reflected  > in the RDF/XML document names (see below).  >   > So for each of the following, I propose both a namespace, and an initial   > home  > for the RDF/XML document:  >   >>  >> - a trix namespace, with DTD and XML Schema  >   >   > xmlns:trix="http://sw.nokia.com/TriX-1/"  > URL: http://sw.nokia.com/trix/schemas/TriX-1.0.rdf  >   >> - an rdfg namespace with RDFS/OWL Schema  >   >   > xmlns:rdfg="http://sw.nokia.com/RDFG-1/"  > URL: http://sw.nokia.com/trix/schemas/RDFG-1.0.rdf  >   >> - an swp namespace with RDFS/OWL Schema  >   >   > xmlns:swp="http://sw.nokia.com/SWP-1/"  > URL: http://sw.nokia.com/trix/schemas/SWP-1.0.rdf  >   > I'll then add the necessary links to the TriX homepage I've  > been maintaining at http://sw.nokia.com/trix/.  >   > And these vocabularies will be syndicated into the Nokia SW Server  > such that one can access both human browsable and machine readable  > (RDF) representations of the terms. I.e. simply doing a GET on  > http://sw.nokia.com/RDFG-1/Graph will provide a description of  > that class, etc.  >   > Whether we want to employ the VOC vocabulary for vocabulary  > descriptions [1] is an open question. If so, I'm happy creating  > the RDF/XML documents accordingly. See [2] for an example.  >   > Anyway, are the namespaces/URLs above OK with you guys?  >   > Would the following dc:rights statement be adequate/acceptable:  >   > [  > Copyright (C) 2004 {AUTHORS' NAMES ORDERED AS ON PAPER}. All rights   > reserved.  >   > This document may be copied, published, and distributed, without   > restriction  > of any kind, provided it is not modified in any way.  >   > THIS DOCUMENT IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTY OF ANY   > KIND,  > EITHER EXPRESSED OR IMPLIED, INCLUDING, WITHOUT LIMITATION, WARRANTIES THAT  > THE DOCUMENT IS FREE OF DEFECTS, MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE  > OR NON-INFRINGING. THE ENTIRE RISK AS TO THE QUALITY AND USABILITY OF THIS  > DOCUMENT IS WITH YOU. SHOULD THIS DOCUMENT PROVE DEFECTIVE IN ANY RESPECT,  > YOU (NOT NOKIA, ITS LICENSORS OR AFFILIATES OR ANY OTHER CONTRIBUTOR)   > ASSUME  > THE COST OF ANY NECESSARY SERVICING, REPAIR OR CORRECTION.  > ]  >   > (the Nokia legal trolls like that last bit to be in there, not that it   > isn't  > usually obvious to anyone with half a clue...)  >   >   > Patrick  >   > [1] http://sw.nokia.com/VOC-1  > [2] http://sw.nokia.com/schemas/nokia/FN-1.0.rdf  >   > --   >   > Patrick Stickler  > Nokia, Finland  > patrick.stickler@nokia.com  >         

      Dave:  >  > old text:  >  >   absoluteURI  ::=  character+ with escapes as defined in  > section URI References  >   -- http://www.w3.org/2001/08/rdf-test/#absoluteURI  >  >   3.3 URI References  >  >   URI references are defined and encoded using the rules defined in  >   [Charmod] section Character Encoding in URI References.  That is,  >   disallowed characters are represented in UTF-8 and then encoded  >   using the %HH format, where HH is the byte value expressed using  >   hexadecimal notation.  >   -- http://www.w3.org/2001/08/rdf-test/#sec-uri-encoding  >  >  > might be changed to:  >   -----------------------------------------------------------------------  >   absoluteURI  ::=  character+ with escapes as defined in  > section URI References  >   -- http://www.w3.org/2001/08/rdf-test/#absoluteURI  >  >   3.3 URI References  >  >   URI references are sequences of US-ASCII character productions  >   encoding Unicode characters that form an Internationalized  >   Resource Identifier (IRI) [IRIs].  >  >   Disallowed IRI characters (see [IRIs] 2.3 part B) are represented in  >   UTF-8 and then encoded using the %HH format, where HH is the byte  >   value expressed using hexadecimal notation.  >  >   Characters above the US-ASCII range are made available by the \u or  >   \U escapes as described in section Strings for ranges [#x80-#xFFFF]  >   and [#x10000-#x10FFFF] respectively.  >  >   Characters [#x0-#x1F] and #x7F are forbidden in URI references.  >  >   -- http://www.w3.org/2001/08/rdf-test/#sec-uri-encoding  >   -----------------------------------------------------------------------  >  >  > along with a new reference  >  >   -----------------------------------------------------------------------  >   [IRIs]  >      Duerst and Suignard, Internationalized Resource Identifiers (IRI)  >      IETF Internet Draft (work in progress), April 17 2002,  >        http://www.ietf.org/internet-drafts/draft-duerst-iri-00.txt  >  >   -- in section http://www.w3.org/2001/08/rdf-test/#ref_normative  >  >   -----------------------------------------------------------------------  >  > but I'm sure Jeremy could write something better :)  >    I am looking at  http://www.w3.org/TR/xlink/#link-locators    [[[    3.3 URIRefs        The uriref production expands to a string which must be a URI reference as  defined in [IETF RFC 2396], or must result in a URI reference after the  standard escaping procedure is applied. The procedure is applied when  passing the URI reference to a URI resolver. The standard escaping  procedure is described in [IETF RFC 2396] using UTF-8 as the character  encoding.    >  >   Characters above the US-ASCII range are made available by the \u or  >   \U escapes as described in section Strings for ranges [#x80-#xFFFF]  >   and [#x10000-#x10FFFF] respectively.  >  >   Characters [#x0-#x1F] and #x7F are forbidden in URI references.  >    ]]]    We could add a non-normative link to xlink for the full procedure, we could  just copy-paste from xlink, there is also the rfc 2732 issue that my text  doesn't deal with.    I am hoping we will have time to consider the choice at the telecon today.  I am fairly easy as to whether to have the link to IRI or not ...    I believe Dave's proposed text and my proposed text differ in their  treatment of bidi IRIs!  (not that I've read that bit of Martin D?rst's draft).    Jeremy        

            Brian McBride wrote:    >   > I propose to cancel this weeks telecon and schedule another for 12 Mar   > 2004, if needed.  >     I think that means we will not formally respond to I18N on the charmod   comments, shall I tell them that we do not intend to, but that the e-mail   discussion has not shown any disagreement.    e.g.  I have informed the RDF Core WG of your decisions, and no one has indicated     unhappiness - however we have not formally discussed these issues; and   are not likely to.    Jeremy        

        In rdf-interest I have had a pointer to a DC document that suggests  generating a triple for xml:lang ....    section 4.2.1 in    http://dublincore.org/documents/2001/11/30/dcq-rdf-xml/#sec4    cf the thread    http://lists.w3.org/Archives/Public/www-rdf-interest/2002Mar/thread.html#28    particularly the message    http://lists.w3.org/Archives/Public/www-rdf-interest/2002Mar/0007.html    Jeremy        

            I think we are agreed that:      the choice between an asserted attribute in the XML and vocab in the   triples is an important one      that it is not obvious which way to go      (Jeremy, Pat and Patrick have all argued for an asserted attribute at   some point)    Judging by Pat's last message, at least for now, we are trying a vocab   solution. I need to read and probably reply separately to that message.       The obstacle of legacy RDF/XML that does not have such an attribute, and   legacy RDF/XML tools that do not support such an attribute is one reason   for using vocab, but we should try and enumerate the pros and cons.      Pro XML attribute       - very clear     - publisher has clear control     - easy solution to bootstrapping problem    Con XML attribute       - publisher's identity left implicit     - legacy     - third party assertions impossible     - adds additional theoretical level, isn't assertional status just more   metadata?      Pro Vocab       - uses existing mechanisms, and hence partially addresses legacy     - enables third party assertions, or single assertion by author for many   docments     - can derive assertional status, so system is extensible by users     - vocab can require publisher to be identified by a URI node (well I   guess a bnode would do, but I wouldn't trust it!)    Con Vocab       - can derive assertional status so bootstrapping is complicated     - bootstrapping is logically twisted, since we seem to need to assume   that a graph is asserted in order to examine its assertional status      What have I forgotten? Short statements please, no advocacy.    Jeremy        

          A further concern I have is that many Semantic Web users use mainly RDF   with maybe just a tiny bit of OWL ... To communicate with them OWL Abstract   Syntax is not appropriate.    Jeremy        

            > But could we not still state that the value space consists of  > Infosets, and the L2V mapping is from canonical octet sequence  > to nodeset to infoset, and visa versa?  >  > If it can be finessed, I think we are in a better position  > having a value space of infosets.  >  > Patrick  >    Using the infoset you are supposed to say which bits of it are relevant:    http://www.w3.org/TR/xml-infoset/#conformance    since rdf:XMLLiteral depends on exc-c14n which depends on xpath, we depend  on  the same information items (not the document). I suggest it is not our  place to articulate those.    In --  2.2 Element Information Items  2.3 Attribute Information Items  2.4 Processing Instruction Information Items  2.6 Character Information Items  2.7 Comment Information Items  2.11 Namespace Information Items    Out --  2.1 The Document Information Item  2.5 Unexpanded Entity Reference Information Items  2.8 The Document Type Declaration Information Item  2.9 Unparsed Entity Information Items  2.10 Notation Information Items    ????    i.e. we can follow the specs from our current design thru to Xpath. While  there is presumably a link between xpath and infoset, that looks more  difficult. So I cautiously favour remaining silent, and leaving XMLers to  fill in the gaps if any.    Jeremy        

          (Note reagle-01 has also been submitted as part of the webont consensus  review).    These issues concern the design of rdf:XMLLiteral and  rdf:parseType="Literal".    Reagle reviewed on behalf of the C14N group (Digital Signatures).  I had indicated that we were seeking expert feedback as to how well we had  used their work.    Reagle suggested:  - we should use the same type of C14N throughout - I think this was intended  for clarity - it is difficult to assess what our solution does with its mix  of both exc-C14N and incl-C14N.  - to remove implementation variability    WebOnt  - request removing implementation variability from RDF/XML thru to domain of  discourse  - suggest removing all implementation variability (as an example of how to  satisfy request)    ======    I see the choice space as:    1: Leave things as they are  2: Choose a form X of canonicalization,     require parser to implement X     define lexical to value mapping as X  3: Choose a form X of canonicalization     define lexical to value mapping as X     leave text in Syntax largely unchanged (except use X in place of current  "exclusive canonicalization without comments"). This allows cheap and  cheerful parsers that do not canonicalize.    =====  3 is now my preference - I realise it needs expansion, but before I do that  I wish to list pros and cons, and get feedback from WG.  =====    Consider three use cases:  A) cheap and cheerful RDF impl using embedded XHTML  B) OWL or other semantically advanced use where it is desired that  representation in domain of discourse is not implementation dependent.  C) Embedding XSLT document inside and rdf:XMLLiteral (hence requiring  support for preservation of not visibly used namespaces)      1:  A - works  B - doesn't really work, because of comments and not visibly used namespaces  C - might work depending on having an implementation that knows when to  preserve not visibly used namespaces    2:  A: expensive  B: works  C: does not work    3:  A: works  B: works  C: does not work    i.e. our current position works non-interoperably for XSLT in RDF - a use  case that we have not seen, and that is its only advantage over soln 3 which  interoperably does not work for XSLT in RDF.    ====    If we go for soln 2 or soln 3 we have to reconsider whether we wish to  preserve comments, and which not visibly namespaces we preserve.  I suggest preserve comments, and no namespaces that are not visibly used.    BTW - if we go for 2 or 3 ARP will need updating - it has some support for  preservation of not visibly used namespaces. I could ask on jena-dev whether  anyone is using this feature.    Jeremy        

        > Since what I am proposing is (I believe) exclusively a change  > to the RDF/XML syntax and RDF/XML to graph mapping, I was waiting  > to hear from Jeremy and Dave particularly.  >   > Jeremy didn't seem to thrilled, though I think he is seeing  > ghosts. I didn't want to get into that before/unless there  > was some clear indication from the WG and you in general that  > this is something we should actively address further.  >       I have been confident that the basic framework agreed for XML Literals as   we resolved the original issues (in Cannes?) works.    I am not confident that a fundamental change to that framework would work.  I might be seeing ghosts, but we would need to work through application   scenarios for embedded XHTML in detail. I have failed to come up with a   succinct example as to how it does not work but remain prejudiced against   any variant of the proposed change.    Jeremy        

        With the XMLLiteral URI clairification.    Jeremy          text/html attachment: rc.html          

        Jeremy:  > Searching in the mail archive the earliest reference to the contradiction  I  > could find was:  >  > http://lists.w3.org/Archives/Public/www-rdf-comments/1999JanMar/0026.html    The author, Tamito Kajiyama, has confirmed to me that he has not yet  received any reply to his comment. I have indicated to him that I believe we  are currently considering this comment under    http://www.w3.org/2000/03/rdf-tracking/#rdfms-not-id-and-resource-attr    Jeremy        

        Chris Bizer wrote:    > Hi Patrick,  >   >   >>>>Section 4: use of parentheses  >>>>Perhaps we should use crather than parentheses  >>>>to be more compatible with N3/Turtle, which use parentheses  >>>>for collections.  >>>  >>>I am easy - parentheses as opposed to braces was Chris's choice - I'll  >>>let him argue the case (if he wishes to).  >>  >>I'm thinking about what will create the least path of resistance  >>if folks start adopting this -- and compatability with N3/Turtle  >>seemed to me to be a big win.  >>  >   >   > Hmm, yes, I see arguments for both options:  >   >   >   > pro parentheses:  >   > - we started with them and already used them in the SWIG paper  >   > - a named graph is not a N3 formula, which is underlined by using  > parentheses  >   > - TriG is based more on N-Triples than N3.  >   > - We didn't decide on a list syntax for TriG yet, or whether we want to  > include lists at all.  >   > - using braces would also imply braces in TriQL which would move it further  > away from RDQL  >   > - parentheses look "nicer" and are easier to reach on German and English  > keyboards.  >   Much easier on italian keyboards which do not have braces.      >   >   > I think that all these arguments are not very strong. So if you have the  > strong feeling that we should change to braces it is OK with me.  >   >   >   > Chris  >   however, none of the arguments is strong    Jeremy        

        Dave question normative nature of CHARMOD ref.    My analysis is as follows:    1: section 3 had normative dependencies by mistake.     The intent, not properly wordsmithed, is that the references to CHARMOD  and XML Schema concerning RDF Literals are informative rather than  normative. I will correct.    2: Section 4.1 on early uniform normalization    http://www.ninebynine.org/wip/RDF-basics/2002-07-25/Overview.htm#xtocid48034    does normatively depend on charmod.    I added this as part of what I understood as the deal with the I18N WG from  the Cannes plenary. My view is:  - if charmod has sufficiently progressed down the rec track at last call  than we leave 4.1 and the normative ref  - if charmod has not, we excise section 4.1 and move the ref to informative    The motivation for this view is that of the many things required for full  charmod conformance, early uniform normalization is: (a) has the biggest  practical impact and (b) is explicitly mentioned in M&S. Hence I think, if  at all appropriate, we should clarify M&S and make it easy for RDF2 to be  fully charmod conformant. However, given the rules of not having normative  dependencies on non-recs, and given the implausibility of in-lining the  concept, if I18N have not got their act together sufficiently then we have  to (reluctantly?) drop it.        ====    Summary:    propose to leave the normative dependency in this WD and revisit shortly  before last call.    add editorial note to document at section 4.1 to that effect.    Jeremy        

          So far I am the only one to have spoken against 4 - if there are no others  who join me in that position in the telecon I am currently expecting option  4 to win.    Option 4 makes XMLLiteral ignore language.      Jeremy      > -----Original Message-----  > From: Patrick.Stickler@nokia.com [mailto:Patrick.Stickler@nokia.com]  > Sent: 09 May 2003 13:40  > To: bwm@hplb.hpl.hp.com; jjc@hplb.hpl.hp.com; w3c-rdfcore-wg@w3.org  > Subject: RE: typed literals and language tags - suggested sub-agenda  >  >  >  >  > > -----Original Message-----  > > From: ext Brian McBride [mailto:bwm@hplb.hpl.hp.com]  > > Sent: 09 May, 2003 13:36  > > To: Stickler Patrick (NMP/Tampere); jjc@hplb.hpl.hp.com;  > > w3c-rdfcore-wg@w3.org  > > Subject: RE: typed literals and language tags - suggested sub-agenda  > >  > >  > > At 13:10 09/05/2003 +0300, Patrick.Stickler@nokia.com wrote:  > >  > > [...]  > >  > > >"We prefer one of the options 1-4 over no change" - Yes  > > >  > > >If Yes, then  > > >  > > >    Prefered options: 4, 1  > > >    Can live with:    2  > > >    Can't live with:  3 (reason: making the wrapper real)  > >  > > Patrick,  > >  > > Thanks for input - its great to have.  Could you expound a  > > little on the  > > can't live with - why does making the wrapper real cause you  > > a problem?  >  > Because it's not part of the literal as expressed by the  > author in the RDF/XML and thus one cannot trust that  > applications consuming that literal down the pipe will  > know if the wrapper element was added by the author or  > an RDF parser.  >  > I'm presuming that it is not illegal to say  >  >    <rdf:Description rdf:about="#something">  >       <ex:foo rdf:parseType="Literal">  >          <rdf-wrapper xml:lang="en">  >             <p>Foo</p>  >          </rdf-wrapper>  >       </ex:foo>  >    </rdf:Description>  >  > How do you differentiate that case with the following:  >  >    <rdf:Description rdf:about="#something" xml:lang="en">  >       <ex:foo rdf:parseType="Literal">  >          <p>Foo</p>  >       </ex:foo>  >    </rdf:Description>  >  > In short, it smacks of being a hack, and not good design,  > and we do not have time to explore all the possible implications  > of taking this path.  >  > It was one thing to posit some abstraction of a wrapper element,  > it is something *very* different to make that wrapper element  > a real thing.  >  > Cheers,  >  > Patrick  >        

        > I suggest an abstract syntax along the lines of:  >  > An RDF Literal Node can be labelled with one of:  >  > - an RDF String Literal (as now)  > - an RDF XML Literal  (as now)  > - a value from the value space of a datatype.  >  > We simply note that an implementation that is unaware of a  > specific datatype  > used in an RDF/XML document will need to store the datatype URI + lexical  > form pair as a fall-back.  >  > An RDF Graph contains precisely one triple for each Literal node in the  > graph.  >  > [As I have previously indicated this extreme syntactic untidiness is  > practically indistinguishable from extreme tidiness, but leaves Pat more  > room to wriggle.]    Benefits:    1. Implementations don't need to store the original string, fits with almost  all plausible implementations of values. (e.g. in a database)    2. Makes the Closed World Assumption on datatyping. This is more accurate  than an Open World Assumption.  When the document author writes    <my:datatype>"10"  they know already whether they mean the string "10", the number 2 (binary),  or 10 or 16 (hex).  They are not saying that they are going to make up their mind later about  what the "10" means. <my:datatype> is already defined and they are using  that definition. Someone else shouldn't come and redefine <my:datatype> so  that "10" means something else.    I agree with Patrick that it has a weakness to do with implementations that  do not know a particular datatype have to fallback to something like his  proposal; which licenses two slightly different behaviours. However, note  that XML Schema Datatypes is closed. There are only the predefined basic  types and (possibly user defined) types derived from them. Hence, at least  in principle, an RDF implementation could know all possible predefined  datatypes and the rules for understanding a user definition of a new type.    Jeremy        

        I have risked blood with I18N, I have risked my sanity with C14N, ...    ... to ensure one principle that I think is key to this discussion.    Literals have well defined equality; and that equality is an equivalence  relation.    As long as that is true then the model theory works, tidiness works, our  test cases work.      What is a Literal?  ==================    Given two literals it is possible to tell whether they are the same or not.  A literal is used to label the nodes in the graph that are not blank and are  not labelled with URIrefs.        From the non-syntactic point of view that is it.    Of course with the datatyping based on XML Schema Datatypes, we also need:    There is a partial function from the set of literals to strings.        ....    OK, let's try again.    What is a Literal  =================    Each literal is one of    - a unicode string    - a unicode string and an RFC 3066 lang tag    - a well-balanced XML fragment    - a well-balanced XML fragment and an RFC 3066 lang tag    Two literals are equal if they are of the same kind (i.e. the same one of  the above list) and each component of the two literals are equal.    Two unicode strings are equal if they are equal as binary UTF-8 sequences.  Two RFC 3066 lang tags are equal if they are ASCII equal ignoring case.  Two well-balanced XML fragments are equal if they canonicalise to equal  strings.    (note: the latter statement is not yet quite precise enough, I am working on  it).    (note: greater mathematical precision would define a literal as an  equivalence class of the above set of literals).    Terminology  ===========  A literal of the first two kinds is referred to as a string literal.  A literal of the last two kinds is referred to as an XML literal.    What is Tidiness  ================    A tidy graph has no two nodes with equal labels.    How does datatyping work  ========================  An RDF graph using an XML literal in a datatyping context is ill-formed.  In a datatyping context where a unicode string is needed as the argument in  a lexical to value mapping the string component of a string literal is used.  The language component (if any) of the string literal is ignored.          Hope this clarifies things.    Jeremy        

        anti-regrets - my earlier meeting has finished much earlier than I   imagined. I will join the telecon in twenty minutes.    Jeremy      Jeremy Carroll wrote:    >   >   > Once again I am afraid I won't make the telecon. Sorry.  >   > Jeremy  >   >         

        Peter is unhappy with the lack of decisiveness in the whitespace processing.    http://lists.w3.org/Archives/Public/www-rdf-comments/2003JulSep/0269.html      I note that WebOnt backed a similar comment, saying:    http://lists.w3.org/Archives/Public/www-rdf-comments/2003JanMar/0335.html    "OWL necessitates that the  denotation in the domain of discourse be fully defined by the source   RDF/XML file. "    This might suggest that Peter could, if he chose, get WebOnt support for   his comments above.    A different way of coping with the implementors' feedback would have been   to have added the whiteSpace normalization to the l2v mapping within RDF   datatyping. This would have avoided the MAYs and SHOULDs that cause the   implementation variability.    I confess to being worn out with this - but if anyone could suggests words   I guess I would support them.    (Dave made a valiant attempt to head this criticism off - but I think Peter   concern follows from almost any MAY in our spec)    Jeremy        

        More on the content of your message about http://..../City    Aldo Gangemi wrote:  > But also look at the file at http://xmlns.com/wordnet/1.6/City: City is a class   > introduced with all its taxonomic branch (poor practice: if each class is   > introduced with all its superclasses, the ontology results unnecessary long),    I am less than convinced - for a very big, or infinite ontology, this is a   *necesary* practice (good or bad) since otherwise any use of the ontology   requires a huge (possibly infinite) download.    I am currently working on an ontology for language tags, based on RFC   3066bis, which is infinite - I was thinking of using a similar approach to   the one above to give finite views of relevant parts of the ontology, so   that any use could be achieved by downloading all the URLs constructed with   language tags actually present in your data.    If all you want to know about is City then the City download is a good one,     if you want to know about more than that, maybe you need the full   download (wherever that is).    Jeremy        

            > - close issue    Yes Aaron is right.  This should have been "postpone rest of issue"    Jeremy    -----Original Message-----  From: Aaron Swartz [mailto:me@aaronsw.com]  Sent: 16 July 2002 20:05  Subject: Re: rdfms-syntax-incomplete      On Tuesday, July 16, 2002, at 01:48  PM, Jeremy Carroll wrote:  > - reopen issue rdfms-syntax-incomplete  [...]  > - close issue    Um, how can we close the issue when you can't represent:  <urn:foo> <urn:bar:#> <urn:baz> .  in RDF/XML?    --  Aaron Swartz [http://www.aaronsw.com]   4FAC4838B7D8D13FA6D92EDB4145521E79F0DF4B  I will be in San Diego for the O'Reilly Open Source Convention the 24-26   July.        

          > Let me try again, although I'm losing the will to live at this point :)    OK that will do.    Jeremy        

        I have sent messages to other WGs as actioned:    "Resolving references against base URIs"  http://lists.w3.org/Archives/Public/uri/2002Apr/0025.html    to complete  2002-03-22#4 jeremy Send mailto:uri@w3.org      and    "Visibility of explicit namespace decls"  http://lists.w3.org/Archives/Public/www-xml-query-comments/2002Apr/0013.html    to complete  ACTION 2002-03-15#9 (jeremy) raise a comment on xquery/xpath      Jeremy        

          I took an action to explain methods of dealing with attachments etc in W3C  lists.    The following describes some policy,    http://www.w3.org/2002/03/email_attachment_formats.html    which in summary is      plain text is best    html or xhtml is second best      The harder case that is not explained in full is what do you do when you  have content in some proprietary format, particularly if the files are  large.  e.g. I had a document in a proprietary format that I wished to send to the  www-rdf-interest list.    Step 1) Create a PDF (if necessary this might been creating a postscript  file and then converting that with ghostview)    Step 2) send PDF as attachment to www-archive@w3.org  This mailing list is public but no natural subscribers, and is intended for  large attachments, amongst other purposes.    Step 3) Find URL of attachement by looking at  http://lists.w3.org/Archives/Public/www-archive/    Step 4) Send URL to the intended mailing list e.g. see  http://lists.w3.org/Archives/Public/www-rdf-interest/2004Feb/0231    where I note the long URL got mangled ...    Reviewing the policy I probably could have created an xhtml version with  only a little more effort than the PDF and that would have been better.    It is particularly important to use this technique of sending to www-archive  when the attachment is large.    If you wish to send something with member confidentiality to a public list  the same technique can be used by sending to w3c-archive@w3.org which is  archived at  http://lists.w3.org/Archives/Member/w3c-archive/    If you have a complex set of interlinked files in the same directory it is  possible to send them all as attachments to www-archive and the links will  be maintained. Example is:    http://lists.w3.org/Archives/Public/www-archive/2004Feb/att-0071/      Jeremy        

          Having declined to make editorial improvements, I have been thinking some  more.    It was not the principle of greater editorial clarity that I minded, more  the specifics that Peter was suggesting.    A possible editorial improvement that I could support is as follows:    At the end of  section 3.4 Literals (informative)  http://www.w3.org/TR/2003/WD-rdf-concepts-20030905/#section-Literals  add the following new para    [[  The string in both plain and typed literals is required to  be in Unicode Normal Form C [NFC]. This requirement is motivated  by [Charmod] particularly section 4 Early Uniform Normalization.  The strings of literals can be considered  <a href=  "http://www.w3.org/TR/charmod/#def-construct">  constructs</a>  in the sense used in that section.  ]]    and add charmod into the informative references.    Jeremy        

      >   > Can't be (a) since the "" content is just a sequence of characters.    Oh, that's interesting. I had been assuming that it was well-balanced xml.    So for you    xml"<"    is a plausible value. (Not representable in RDF/XML)?    That's fine.  If that's the case then:    > b) legal but different from xml("<b>foo</b>") (and not representable in  > RDF/XML?)    looks like the attractive answer to my question.    Jeremy        

      Agreed    -----Original Message-----  From: Patrick Stickler [mailto:patrick.stickler@nokia.com]  Sent: 11 January 2002 16:00  Subject: Re: PD datatyping doc plans        To clarify, I will intend to write up a section on PD comparable to  section 4 of Sergey's document, as well as my changes to section 3  which presume an S-level of resolution, and will then send that to  you for review and the infusion of the math.    How does that sound?    Patrick      On 2002-01-11 16:21, "ext Jeremy Carroll" <jjc@hplb.hpl.hp.com> wrote:    >   >   > Hi Patrick,  >   > note I've moved off-list, but copying to www-archive.  > This allows the conversion to be public domain but not in-your-face for  > the  > rest of the group.  >   > Assuming the telecon OKs the plan we've just agreed, I suggest we  > propose  > that we do our work off-list in this way. This should help reduce RDF  > Core  > bandwidth utilisation.  >   > I like your pictures, I think they are really helpful.  >   > I think we should decide which horse to back and forget the others for  > now.  >   > My reckoning is that S is leading the race, and PL is in the race, and  > both  > are different from the sort of solutions we have been in favour of.  >   > For me, the race will be won on rdf-interest (not rdf-core), hence the  > familiarity of the PD proposal is IMO the key.  >   > So I suggest restricting our write-up to PD, and forgetting, for now, U  > and  > P++.  >   > Any thoughts?  >   >   > On the maths ...  >   > Your suggested framework ...  >   > [[[[[  >   > 1. Take up to section 4.1 as a starting point (rework section 3 and  >  remove sections 4.2 onwards, including section 5).  >   > 2. Add math in or following section 4.1 that states that for any pairing  >   >      (lexical_form, data_type_URIref)  >   >  there is one and only one mapping  >   >      (lexical_form, data_value)  >   >  between the lexical space and value space of that data type.  >   > Surely the math for this is straightforward (I wish I could provide it).  >   > 3. Add final sections detailing the idioms P and D, how they define such  >  pairings of lexical form and data type.  >   > ]]]]]]]  >   > I started thinking about this and got a bit of nervous.  >   > So far, we have decided not to have a processing model for RDF: step 3  > above  > looks like creeping towards one, and overall this looks like an extra  > layer  > in our analysis.  >   > I am beginning to see the attraction of trying to do it all in the model  > theory, which, as far as I understand, Pat made a stab at in:  >   > http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Nov/0011.html  >   > "Datatypes and MT"  >   > I am beginning to feel that I need to bite the bullet and build on top  > of  > Pat's work and actually do some model theory.  >   > Then your diagrams and some text would be the informal part, and we  > simply  > wouldn't have the intermediate level math that would actually be useful  > to  > an implementor!  >   > My understanding is the MT route that we have taken overall is a  > decision to  > leave implementation to implementators and to prioritise being clear  > over  > being at the right level for implementators.  >   > I am flying out to the WebOnt F2F this weekend, I will try and have a  > stab  > at PD model theory on the plane. ("stab" is perhaps an unfortunate turn  > of  > phrase).  >   > Jeremy  >   >   >   >     --                   Patrick Stickler              Phone: +358 50 483 9453  Senior Research Scientist     Fax:   +358 7180 35409  Nokia Research Center         Email: patrick.stickler@nokia.com        

      Thanks for uploading these Dave.      > Furthermore I've looked at these  >   >   nested-bagIDs: OK  >     However tests007 onwards are very complex and I need to study   > them more.  >     I do not believe that these are *unnecessarily* complex, sorry.    Jeremy        

        Sorry I have not been sufficiently clear.  Links included etc.    Dave Beckett wrote:    >>>>Jeremy Carroll said:  >>>>  >>  >>At the telecon I was actioned to bring a new proposal on the reagle issues.  >>This is a sketch intended to allow members of the WG who were absent at the   >>telecon to comment. I will expand the details later (not on semantics - which  >>I intend to leave to Pat's discretion)  >>  >>Changes:  >>  with comments  >>  c14n done in syntax doc  >>  implementation note added to concepts  >>  >>Syntax   >>=====  >>  >   > 7.2.17 http://www.w3.org/TR/2003/WD-rdf-syntax-grammar-20030123/#start  >   >   >>+  7.2.17 changed to indicate that exc-canonicaliztion with comments and with  >>empty  InclusiveNamespaces PrefixList. is performed.    (I think this was clear enough - proposed text is needed)      >>+   add new link from part where it is said that use of N-Triples is not   >>required to implementation note in concepts  >>  >   > I don't understand this.  Link from this section?  To the  > IMPLEMENTATION NOTE you propose below.  >   > There is a bullet point in section 6  >   http://www.w3.org/TR/2003/WD-rdf-syntax-grammar-20030123/#start      Clarification:  in section 6  http://www.w3.org/TR/2003/WD-rdf-syntax-grammar-20030123/#section-Data-Model  replace:  [[This specification does not require that N-Triples be used to represent   an RDF Graph.]]    by  [[  This specification permits any  <a href="rdf-concepts#implementation-note">representation</a>  of an RDF Graph (see [RDF Concepts]); in particular, it  does not require the use of N-Triples.  ]]          >   > Could you add some URLs to what you want to change?  >       Hope the above is clearer.      >   >   >>Concepts  >>=======  >>  >   > In http://www.w3.org/TR/2003/WD-rdf-concepts-20030123/#section-XMLLiteral  >   >   >>+  change lexical space of rdf:XMLLiteral to be strings that are root element  >>content of canonical XML documents  >>  >   > how about:   >   strings that are the contents of the root element of canonical XML documents  >       I was thinking along the lines of first defining value space and the   mapping and then  [[  The lexical space is the set of  (string value) pairs that map into the value space.  ]]  It's sort of cheating.      >   >>+  change mapping of rdf:XMLLiteral to be a string concatenation  >>'<rdf-wrapper xml:lang="'  >>lang  >>'">'  >>string  >>'</rdf-wrapper>'  >>  >   > I should note that I've answered several people who wanted to know  > where the rdf-wrapper element was defined, so maybe a more prominent  > stating that this is arbitrary might help.      Any suggestions as to how - it currently comes right after the first   occurrences.  I guess I could change the value space bullet point from  [[  Have root element tag: <rdf-wrapper>  ]]  to  [[  Have the fixed but arbitrary root element: <rdf-wrapper>  ]]    (One of the xmlschema editorial comments (2.5 in msg 0489) is to delete "tag")      >   >   >>+  add implementation note at end of abstract syntax section  >>  >>IMPLEMENTATION NOTE:  >>This section describes an *abstract* syntax which describes  >>equality of literals and equivalence of graphs. This is the  >>syntax over which the foraml semantics are defined.  >>Implementations are free to represent literals and RDF graphs in   >>any other equivalent form. As a first example: language tags may be  >>represented in their original case, and language tag comparison would  >>then be a case insensitive string comparison. As a second example:  >>literals with datatype rdf:XMLLiterals can be represented in a non-canonical  >>  >   > <tt>rdf:XMLLiteral</tt>s I assume  >     Yes.      >   >>format, and canonicalization performed during the comparison between two  >>such literals. In both of these examples, the comparisons may be   >>being performed either between syntactic structures or  >>between their denotations in the domain of discourse.  >>Implementations that do not require such comparisons can  >>hence be optimized.  >>  >   > This note reminds me, do we canonicalize the language strings to  > lower/uppercase?  I know it has been suggested (from I18N WG?) that  > it is best to preserve this for people but given there is no other  > variation allowed in literal or URI canoncalization, I think we  > should consider picking one and requiring it.  >       Yes; we chose lowercase, mainly to make life easier for Pat.  Tex Texin misunderstood that so the note is intended to clarify ...    http://lists.w3.org/Archives/Public/www-rdf-comments/2003JanMar/0460.html        >   >>Semantics  >>========  >>+ follow concepts as appropriate  >>  (Note: there is still rdf:XMLLiteral as a special case because even though   >>the mapping is simplified, it is still there, and it still requires the lang   >>tag as an argument).  >>  >>   >>  >>********************  >>  >>The first example with language tag case is intended to:  >>- be easy to understand  >>- partially address an issue raised by Tex Texin (possibly on behalf of I18N   >>WG), no ID yet.  >>  >   > Pointer to email?    http://lists.w3.org/Archives/Public/www-rdf-comments/2003JanMar/0460.html    >   >   >>The second example is intended to address part of my action.  >>  >   > Where are these first & second examples?  >     [[  Above, repeat:  As a first example: language tags may be  represented in their original case, and language tag comparison would  then be a case insensitive string comparison. As a second example:  literals with datatype rdf:XMLLiterals can be represented in a non-canonical  format, and canonicalization performed during the comparison between two  such literals.  ]]      >   >>********************  >>  >>The suggested wording for the lexical and value spaces of rdf:XMLLiteral in   >>concepts  permits the following:  >>  >><rdf-wrapper xml:lang="">  >>  <eg:a xmlns:eg="eg:a" xmlns:unused="eg:b"></eg:a>  >></rdf-wrapper>  >>  >>This does not correspond to any RDF/XML document.  >>A more complicated wording:  >>[[  >>CURRENT:  >>The value space  >> is the set of all XML documents that:   >>  >>+ Have root element tag: <rdf-wrapper>  >>  >   > This is the point that has confused some people, looking for a  > definition of rdf-wrapper.  >   >   >>+ Have no attributes on the root element other than xml:lang  >>+ are Canonical XML [XML-C14N] (with comments).  >>  >>ADD:  >>****  >>+ which are unchanged when transformed using the exclusive canonicalization  >>with comments and with empty namespace prefix list  >>****  >>OR  >>******  >>+ which have no namespace declarations that are not visibly used [EXC-C14N]  >>******  >>]]  >>could avoid this.  >>  >   > The latter seems clearer, rather than defining the condition in terms  > of yet another transformation.      Yes, I'll go with that I think.    >   >   >>(The example document would have the declaration for xmlns:unused deleted by   >>such a transform, and hence be excluded from the datatype).  >>Is that better or worse?  >>  >   > If you mean the three line <rdf-wrapper> above, then I'm not sure  > what to answer.  If we are going for a tighter definition of what is  > canonical, then some XML will be transformed to canonical form, so I  > can't really say better or worse.  The group(s) that created these  > canonicalization transformations surely considered this.  >   > Dave  >       The editorial problem is that the inclusive C14N spec defines the term   "canonical XML" which is actually quite useful in defining the value space.  There is no equivalent term in EXC-C14N. The document:    <rdf-wrapper xml:lang="">    <eg:a xmlns:eg="eg:a" xmlns:unused="eg:b"></eg:a>  </rdf-wrapper>      is canonical XML, but not in the corresponding set for exc-c14n.  Choices are:  - use term from inclusive C14N, and modify it (illustrated by my text)  - use only terminology from exc-c14n and construct the concept we really want.        Hope this is a bit clearer ...      Jeremy        

        Patrick:  >Let's try another example that may help separate what is clearly  >obvious to us, knowing about integers, and what is clear to RDF.    >Is <foo:blarg>"xxxyyy" == <foo:blarg>"xxxxyyy"???    >After all, they only differ by having one extra 'x' in the  >second case. How could that really matter? Well, we really                                              ===============  >don't know, because we don't know what the L2V mapping for  ===========================================================  >foo:blarg is,  =============    and why not?  You are making an RDF like "Open World Assumption", where we don't know  things, in an inappropriate context.    It's an xsd datatype, xsd uses the closed world assumption, everything we  need to process this correctly will have been present to the document  author, and they are obliged to provide it to us.    >> RDF closure would be transformed from a fairly easy computation to a  merely  >> theoretical device. Fine for OWL (where we do have to worry about  infinity),  >> unnecessary and a mistake for RDF.    >I'm not going to say anything more about this issue, being woefully  >unqualified. Perhaps Pat or others may wish to offer comments about  >this.    I think you overall approach of saying that datatyping is an external  function works,  but that the approach of making it an internal function is  better; and will more closely correspond to implementations. However, I note  that you stop short of actually doing datatyping like this. Your RDF allows  you to talk about a datatype, but not to actually arrive at something useful  like an integer.    >I.e. the MT will say that <xsd:integer>"10" denotes the member of the  >value space of <xsd:integer> to which the lexical form "10" maps to  >according to the L2V mapping defined for <xsd:integer> but it does NOT  >say that <xsd:integer>"10" denotes the value ten. It cannot say that,  >because it does not include the semantics of <xsd:integer>.    We will have a normative reference to XSD, which, I believe, *does* say that  <xsd:integer>"10" is the number ten.    Let's try for a short summary of the key points where we diverge ...  I don't think either of us is saying that the other's point of view doesn't  work, just that the balance of arguments goes one way or the other.    Jeremy        

      Summary:    A test suite that systematically includes one example of a type error for  each idiom would have 19 files for S, and 5 files for TDL.      Dan wrote:  > Perhaps I don't know what you mean by an implementation.  > Is it different from an RDF 1.0 parser implementation?  > If so, would you please give me a test that a datatypes-capable  > implementation is expected to pass that an RDF 1.0  > parser isn't required to pass?    While parser/processor tests do not exhaust my idea of an implementation it  is a starting point. I try to sketch a test suite for S and a test suite for  TDL, where the test suites are about RDF errors rather more than XML Schema  Datatype errors. e.g. applying two inconsistent type declarations to a  value. Such errors result in an RDF graph that has no models, what a  logician would call an inconsistent graph.    Having said that, it is also clear that there are many possible tests that  are parser oriented, although some will require schema processing.    I will try to list graphs with type errors fairly systematically for both S  and TDL.    (I will use pseudo-ntriple, the ntriple-like language that gets used in our  examples).    I hope these help you understand what I mean by an implementation of S or  TDL.    So an RDF processor, implementing S or TDL as appropriate, with a  pseudo-ntriple parser, and XSD support, and schema support (for those tests  with an rdfs:range) , should reject the following documents:    S error test cases  ==================    [[ (S-A)  _:n <xsd:integer.map> "twenty" .  ]]    [[ (S-B)  _:n <age> "ten" .  <age> <rdfs:range> <xsd:integer.lex> .  ]]    [[ (S-P local)  _:n <age> _:a .  _:a <rdf:type> <xsd:integer.map> .  _:a <rdf:value> "ten" .  ]]    [[ (S-P global)    _:n <age> _:a .  <age> <rdfs:range> <xsd:integer.map> .  _:a <rdf:value> "ten" .  ]]    For each idiom we may have contradictory type information:  [[ (S-A#S-A 1)  _:n <xsd:integer.map> "20" .  _:n <xsd:string.map> "20" .  ]]  [[ (S-A#S-A 2)  _:a <age> _:n .  _:n <xsd:string.map> "20" .  <age> <rdfs:range> <xsd:integer.val> .  ]]  Perhaps this? (Not included in total)  [[ (S-B#S-B)  _:n <age> _:a .  <age> <rdfs:range> <xsd:integer.lex> .  <age> <rdfs:range> <boolean.lex>.  ]]    [[ (S-P local#S-P local)  _:n <age> _:a .  _:a <rdf:type> <xsd:integer.map> .  _:a <rdf:type> <xsd:string.map> .  _:a <rdf:value> "10" .  ]]    [[ (S-P global#S-P local)    _:n <age> _:a .  <age> <rdfs:range> <xsd:integer.map> .  _:a <rdf:type> <xsd:string.map> .  _:a <rdf:value> "10" .  ]]  [[ (S-P global#S-P global)    _:n <age> _:a .  <age> <rdfs:range> <xsd:integer.map> .  <age> <rdf:type> <xsd:string.map> .  ]]      S also has a range of error conditions when two idioms are intermixed.    [[ (S-A#S-B 1)  _:a <age> _:n .  _:n <xsd:integer.map> "20" .  <age> <rdfs:range> <xsd:integer.lex> .  ]]  [[ (S-A#S-B 2)  _:a <age> _:n .  <age> <rdfs:range> <xsd:integer.val> .  <age> <rdfs:range> <xsd:integer.lex> .  ]]  [[ (S-A#S-P global 1)  _:a <age> _:n .  _:n <xsd:integer.map> "20" .  <age> <rdfs:range> <xsd:integer.map> .  ]]  [[ (S-A#S-P global 2)  _:a <age> _:n .  <age> <rdfs:range> <xsd:integer.val> .  <age> <rdfs:range> <xsd:integer.map> .  ]]  [[ (S-A#S-P local1)  _:a <age> _:n .  _:n <xsd:integer.map> "20" .  _:n <rdf:value> _:foo.  ]]  [I find this next one really counterintuitive].  [[ (S-A#S-P local2!!!)  _:a <age> _:n .  _:n <xsd:integer.map> "20" .  _:n <rdf:type> <xsd:integer.map>.  ]]  [[ (S-A#S-P local 3)  _:a <age> _:n .  <age> <rdfs:range> <xsd:integer.val> .  _:n <rdf:type> <xsd:integer.map>.  ]]  [[ (S-B#S-P global 1)  _:n <age> "10" .  <age> <rdfs:range> <xsd:integer.map> .  ]]  [[ (S-B#S-P global 2)  <age> <rdfs:range> <xsd:integer.lex> .  <age> <rdfs:range> <xsd:integer.map> .  _:n <age> _:a.  ]]  [[ (S-B#S-P local1)  _:a <age> _:n .  <age> <rdfs:range> <xsd:integer.lex> .  _:n <rdf:value> _:foo.  ]]  [[ (S-B#S-P local 2 - not included in total)  _:a <age> _:n .  <age> <rdfs:range> <xsd:integer.lex> .  _:n <rdf:type> <xsd:integer.map>.  ]]      TDL error test cases  ====================      [[ (TDL global)  _:n <age> _:a .  <age> <rdfs:range> <xsd:integer> .  _:a <rdf:value> "ten" .  ]]  [[ (TDL local)  _:n <age> _:a .  _:a <rdf:type> <xsd:integer> .  _:a <rdf:value> "ten" .  ]]  [[ (TDL local#TDL local)  _:n <age> _:a .  _:a <rdf:type> <xsd:integer> .  _:a <rdf:type> <xsd:string> .  _:a <rdf:value> "10" .  ]]    [[ (TDL global#TDL local)    _:n <age> _:a .  <age> <rdfs:range> <xsd:integer> .  _:a <rdf:type> <xsd:string> .  _:a <rdf:value> "10" .  ]]  [[ (TDL global#TDL global)    _:n <age> _:a .  <age> <rdfs:range> <xsd:integer> .  <age> <rdf:type> <xsd:string> .  ]]    Both TDL and S-P may have some ill-formed triples with rdf:value and URIref  nodes. Unfortunately neither document is clear enough to say which. The  problems are identical and so plague both proposals equally.    The test cases were generated by:    take each idiom      generate a single instance type error      generate a type error from multiple incompatible type information      take each idiom pair      generate a model theoretic error by making poor combinations of them      (For all the idioms in both proposals, it would be worth having OK test  cases with multiple compatible types. They all permit it).    Jeremy        

        > Oops. Missed this. I had always been thinking 'intensionally'...  ;-)  >  > Patrick    I am not so sure you have - I think I'll make two stabs at the text, one  intensional, the other extensional and we can ponder - and then junk both of  them!    Jeremy        

            Dan Connolly wrote:    > On Fri, 2004-03-19 at 10:20, Graham Klyne wrote:  >   >>[Switching to RDFcore, trimming cc's]  >>  >>At 08:39 19/03/04 -0600, Dan Connolly wrote:  >>  >>>>Speaking for myself, whilst I disagreed with the WG decision at the  >>>>time, it was not and still is not my intention to lodge a formal  >>>>objection.  The record shows accurately that I opposed the decision.  It  >>>>does not show that I objected to it.  >>>>  >>>Odd; I don't understand the difference.  >>>  >>>It seems clear to me that the WG did *not* reach consensus on  >>>this issue. That seems to merit special notice.  >>>  >>>  >>>>  As I recall the process document  >>>>requires me to jump through some hoops to lodge a formal objection.  >>>>  >>>I have never understood it that way. When the chair calls the  >>>question, you either agree, abstain, or object. And if you  >>>object, you object. That's all there is to it.  >>>  >>For what it's worth, I do see a difference between:  >>  >>(a) believing that a certain decision is not the best decision that could   >>be made (grounds for a vote against in a WG meeting), and  >>  >   > To me, that's grounds to abstain, not to object.  >   >   >   >>(b) believing that a decision is sufficiently harmful that it merits a   >>formal objection on the record.  >>  >>At least, that is how I have thought about these matters.  There are   >>several decisions we made that I don't think were the best possible, but   >>not so seriously flawed that I felt compelled to register a formal   >>objection.  Consensus involves some compromise.  >>        My reading of the process document concurs with Graham not Dan ...    http://www.w3.org/2004/02/Process-20040205/tr.html#doc-reviews  [[Reviewers MAY register a formal objection any time they are dissatisfied   with how a Working Group has handled an issue.]]    with formal objection linked to  http://www.w3.org/2004/02/Process-20040205/policies.html#WGArchiveMinorityViews    with text which clearly suggests that a formal objection is a document of   some sort (e.g. an e-mail).      However,  http://www.w3.org/2004/02/Process-20040205/policies.html#Consensus  defines consensus has including the absence of objections - and it is not   clear whether this is or is not intended to mean formal objections.    I act on the assumption that voting against=objection  and these !=formal objection    Jeremy        

      The example did not work; it got scrunched somewhere, I am reposting it in html with utf-8 encoding which worked last time.      > -----Original Message-----  > From: Jeremy Carroll  >  > Graham said that he found the IRI examples not fully compelling    Here is the example again, I hope this works.      <!--  Issue: charmod-literal          Test:  1          Author: Jeremy Carroll, HP          $Header: /w3ccvs/WWW/2000/10/rdf-tests/rdfcore/rdf-containers-syntax-vs-schema/test004.rdf,v 1.4 2001/09/06 21:23:35 barstow Exp $            Example showing two different literals, that display the same.          In a context where there is a unique naming convention, this can          cause confusion, possibly moral and/or legal confusion.                    The use case consists of:          - a site collecting Dublin Core data,            using a unique names convention for individuals.          - One of the editors of Charmod registers himself and his            work.          - Someone else, with the same name, creator of an adult internet            site, registers a different but visually indistinguishable            name; along with his work.          - The consumers of both works get confused and disappointed,            probably to the detriment of at least one of the Martins.          - This file consists of some of the (ill-formed) RDF used by the             metadata site.            -->    <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"           xmlns:eg="http://example.org/">                <!-- An author database uses the property eg:name with a          unique naming convention.     -->          <!-- D??rst registers himself as a creator of the Charmod WD. -->     <rdf:Description rdf:about="http://www.w3.org/TR/2002/WD-charmod-20020220">     <!-- The ?? below is a single character #xFC in NFC -->        <dc:Creator eg:named="D??rst"/>     </rdf:Description>              <!-- Someone else registers himself under the unused name of Du??rst,          along with some other creation as its creator. -->     <rdf:Description rdf:about="http://example.org/adult-content.html">     <!-- The u?? below is two characters a u followed by             #x308. It should be displayed identically to  ??. -->        <dc:Creator eg:named="Du??rst"/>     </rdf:Description>              <!-- Readers of such data will be given no visual indication that     these are two different people despite the unique naming convention.      This example minimally shows significant risk of confusion.     -->        </rdf:RDF>        

        Another tricky issue which we need a simple solution to is time.    Particularly for publishers who are not using signatures, (which is almost   everyone at the moment), we may want to provide vocabulary to time-out an   affirmation. e.g. an affirmation may have a start time and an end time   explicitly associated with it. (or implicitly using OWL semantics say).    Jeremy        

        Dan:  > Brace yourself for mind-bogglinly deep  > formal argument:  >  > premise:  > <http://www.w3.org/> dc:title "W3C".  > conclusion:  > <http://www.w3.org/> dc:title "W3C".  >  > That's it.*  >    IMO we want this case to hold, but that it is not necessarily the case that  we always want "W3C" = "W3C".    For instance, if we allow literals as subjects, and say use xml:lang to  generate triples (which I think some members of the group would like) then  in general a string in one lang is not the same as the same string in  another lang.    There is also my example where the string "100" in a context in which base  10 is understood is different from the string "100" in which base 2 is  understood.    More strictly I should say 'the interpretation of the string "100" is  different'.    Now, Dan's example is interesting because the two contexts are identical and  hence the entailment is desired.    This looks quite like the bNode case    <http://www.w3.org/> dc:title _:a.    entails    <http://www.w3.org/> dc:title _:b.    (Dan's example is only interesting when the two nodes labelled "W3C" are  different).    Thus I think the patch to the TDL model theory is likely to change the  interpretation of literal nodes (Unicode string nodes) to be like that of  bNodes: i.e. involving an existential qualifier. This is likely to be over  the possible literal-value pairs that meet the type and string constraints.    I will work on it next week.    Jeremy        

        Roy T. Fielding wrote:    > On Thursday, February 19, 2004, at 03:36  PM, Graham Klyne wrote:  >   >> Further to my earlier message [1], I've discussed the issue of URI   >> normalization with some colleagues and we'd like to propose the   >> following small change of wording with respect to [2].  >>  >> ...  >>  >> Section 6.1, para 2, final sentence:  >>  >> The suggested change is to this sentence:  >> [[  >> Therefore, comparison methods are designed to minimize false negatives   >> while strictly avoiding false positives.  >> ]]  >>  >> To be:  >> [[  >> Therefore, comparison methods are designed to minimize false negatives   >> while strictly avoiding false positives when used for purposes of   >> retrieval.  >> ]]  >>  >> Rationale:  >>  >> This reinforces the earlier comment that "URI comparison is performed   >> in respect to some particular purpose" [section 6 intro], and I think   >> provides the necessary get-out for those purposes other than retrieval   >> for which the normalization processes described can result in false   >> URI-equivalence (i.e. in circumstances where existing applications may   >> legitimately deliver differing results).  >   >   > Umm, no.  Aside from being difficult to understand due to the trailing  > qualifier, it is factually incorrect.  URI comparison has nothing  > to do with retrieval.  False negatives are false regardless of purpose.  > The purpose being discussed before that is the goal for which the  > cost/benefit trade-off is balanced, which could be different for each  > of a hundred different types of retrieval.  >   > ....Roy  >     Notwithstanding worries about the phrase  "when used for purposes of retrieval."  without any such qualifier the sentence is false.    For example, if a URI http:/example.org/namespace is used as an XML   Namespace the similar URIs HTTP:/example.org/namespace or  http:/example.org:80/namespace are not names for the same XML namespace.    Thus techniques on the comparison ladder other than byte-for-byte   comparison do not work for comparing namespace URIs when used for the   purpose of naming namespaces. This counterexample (and others, for example   from RDF), indicates that the sentence is false.    I believe I discussed Graham's proposed modification with him, and I felt   that it attempts to allude to these issues without making too big a deal of   it. Some change is necessary.    Jeremy        

            text/html attachment: rc.html          

          NO    The problem of eliminating such blank nodes is plausibly NP complete.    Certainly GI complete, i.e. exponential.    (See related work on irredunancy of conceptual graphs  [[[   Michel Chien et Marie-Laure Mugnier, Conceptual Graphs: fundamental notions   in Revue d'Intelligence Atificielle, Vol 5, no 4, 1992, pp 365-406.  ]]  most applicable to RDFS though)    Jeremy      pat hayes wrote:    > While fixing a silly mistake in the MT document, I noticed the   > following. We require that RDF graphs contain no redundancies in the   > sense that the same triple cannot occur more than once in the graph.   > However, they can contain redundancies in the sense that a triple with a   > bnode in it can be duplicated with a different bnode, even though the   > resulting triples would look the same in a graph diagram. The resulting   > graph has no extra information in it, but this quirk allows an RDF graph   > to have infinitely many consequences. For example, a single triple  >   > a p b .  >   > has infinitely many consequences;  >   > _:x p b .  > a p _:y .  > _:z1 p _:z2 .  > _:z3 p _:z4 .  > -:z5 p _:z6 .  > ....  >   > where all these bnodes are distinct; see attached jpeg.  >   > My question is, does the WG feel that it might be worth ruling this out   > as a syntactic possibility? If this kind of bnode-duplication were ruled   > out, then the set of graphs simply entailed by any RDF graph would be   > finite.  That would generalize the no-duplicate-triples condition   > implicit in our definition of a graph as a set, to treat triples which   > 'look' the same when you erase the bnode labels as though they literally   > were the same.  >   > Pat  >   >         

         IRI-everywhere  I am the issue owner of http://www.w3.org/2000/03/rdf-tracking/#rdf-charmod-uris, and wished to share some of the analysis that I did in applying the lessons of Charmod to URIs in RDF.  The main function of a URI/IRI in RDF is as a name, just like in XML namespaces.  Being able to retrieve a URL is of less interest.    Three levels of IRI definition  Allow (nearly) any Unicode  The XLink href text, and the XML System Literal text (though erratum) provide a working definition of an IRI that allows any Unicode string that would %-escape to a URI.    Disallow non-NFC  A theme in charmod is the important of NFC, and early uniform normalization.  We analyzed this and found security issues when two XLink style URIs differ only in normalization (two different names look the same, and hence cannot be visually distinguished: see:  http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Mar/0027.html  The two strings:  "http://example.org/Andr%c3%a9"   "http://example.org/Andre%cc%81"   are not identical but look the same.  )  Hence, in the IRI draft and in the current RDF WDs the identifiers must be in NFC.  In XML Namespaces 1.1, when used within XML 1.1, this restriction (that IRIs must be in NFC) is implicit. While XML Namespaces 1.1 does not mention normalization, since an XML 1.1 document must be fully normalized, all attribute values are in NFC, including those for xmlns attributes.    Disallow certain BiDi  The IRI draft also considers problems to do with BiDi text. I don't pretend to understand these. Further Unicode character sequences, which involve right-to-left characters and other bidi markup, which are legal under XLink href, are not legal as IRIs according to the IRI draft. This part of the IRI draft, is, as far as I am aware, still cooking.    IRI equality  The definition of equality between identifiers is important for any system like XML Namespaces or RDF which uses URIs/IRIs as names rather than as URLs. This notion of equality differs from operational equivalence. (Note the HTTP spec, when discussing equality of http URLs, is essentially discussing operational equivalence, rather than abstract equality of names).    Identity - Character by Character  The simplest notion of equality is found in the XML Namespaces spec (both 1.0 and 1.1) i.e. character by character equality. This is good from an implementors point of view; and easy to explain to users.    Same Resource? Scheme specifc equality  Another intuitive sense of equality is that the two URIs/IRIs identify the same resource. Attempting to capture this would involve both generic processing to do with case, %-escapes, IANA protocol numbers, etc. and scheme specific processing. Even then, such an implementation would not fully capture this intuitively appealing concept of equality.    Same URI - (ASCII) URI as value space for anyURI  When faced with IRIs as a migration from URIs it is tempting to define equality of IRIs as two IRIs are equal if their URIs are equal. This essentially punts the question, and typical involves URI character-by-character equality. It also raises stupid questions about %7E and %7e ...  From an application point of view, defining equality in this way creates work:      a.. the original characters (the IRI) must be retained, in order to redisplay the identifier to the user in the manner they expect.    b.. either the %-escaping must be repeatedly performed or the value cached, both of which adds significant overhead.    c.. When two different IRIs %-escape to the same URI (possible when one IRI is already, perhaps partially, %-escaped) and the associated concepts get merged, the application will probably retain one, and arbitratily discard t he other, leading to potential user confusion.    d.. It may be necessary to normalize case of hexadecimal characters in % escape sequences, this runs counter to the lack of case normalization in URI comparison.    Proposed Actions  I think there are good arguments, presented in Charmod, for requiring NFC.  I think there are good arguments for, when an IRI is being used as an identifier, then equality of IRIs should be character-by-character comparison.  I think the sooner an I18N-WG recommendation has normative text defining IRIs the better.  I think this should not be made dependent on resolving the bidi issues that are hard.     Current State-of-Art=Disallow non-NFC  In the specs that are already at full recommendation we have IRI support allowing any unicode. In specs such as Namespaces 1.1 (within XML 1.1) we have the proposal that IRIs should be in NFC. I think that the W3C should have this as the current expectation on WGs - the specs should support IRIs (without the BiDi) and should require full normalization.     Replace Charmod Section 8 with explicit text    I understand that charmod is currently held up, partly because of its dependence on IRI-draft.  Thus I propose to modify charmod as follows, and move it to Candidate/Proposed Rec.  - delete normative text in section 8 Character Encoding in URI References  - add text defining an IRI, similar to that in XML Namespaces 1.1, XLink, or  the RDF concepts WD, with the explicit constraint that IRIs are in NFC.  - add an eratum to the charmod erratum page with fragID #IRI and text - "No IRI erratum at present."  - add a note to section 8 of charmod suggesting that the reader refer to that erratum  - add a constraint in section 8 that documents and implementations SHOULD not use right to left or bidi characters in IRIs   - add a note explaining that IRI-draft does address bidi, but this is still in development    Once IRI-draft is a recommendation, then update the erratum against charmod replacing section 8 with:  [[Note: this section is deleted. However,  specs, implementations and documents MUST conform with IRI]]  This will allow XML Namespaces 1.1 and other documents to normatively refer to a definition of IRI. Moreover, once bidi in IRI is cooked, new specs will be able to refer to IRI.      Jeremy Carroll.        

          Here are error002 ==> test015            error003 ==> test016      Jeremy          application/x-zip-compressed attachment: xmlbase.zip          

      >  > 1.  can I legally create a container resource (say, a Bag) without using  > any special syntax, simply by using the ordinary RDF/XML techniques for  > creating a blank node, and giving it the appropriate properties  > (including the type property pointing to the pre-defined rdf:Bag  > resource, and the various li (or explicit _number) properties)?    Yes - this is the point of the resolution along time ago of    rdf-containers-syntax-vs-schema    >  > 2.  can I also legally create a container resource that has a URI (i.e.,  > that *isn't* a blank node), by using the ordinary RDF/XML techniques for  > creating a new resource with an ID, and giving it those same appropriate  > properties (e.g., a type property pointing to one of the pre-defined  > container type resources)?    Yes    >  > Note 1:  since the above involves essentially the "manual" creation of  > container resources, if this is legit, ought we to have a constraint  > that says that the same container can't have multiple rdf:type  > properties that have inconsistent values (like the same container being  > both a bag and an alt;  on the other hand, how would we enforce it?)      It is not inconsistent (said with a straight face!).    A Bag indicates that here is a container with possibly multiple repeat  entries (i.e. a multiset)  Applications may wish to read Bags with conjunctive semantics    An Alt indicates that here is a container with possibly multiple repeat  entries (i.e. a multiset). The first element is distinguished (value of  rdf:_1).  Applciations may wish to read Alt with disjunctive semantics.    Seq indicates that here is a container with possibly multiple repeat entries  (i.e. a multiset). The elements of the container are ordered.    Something that is both a Bag and an Alt is from the RDF Model Theory point  of view just fine. From an application point of view, sometimes a  disjunctive reading should be taken sometimes a conjunctive reading - not  particularly helpful, but possible.    We have decided not to formalise these differences. I am assuming the  normative text like that in M&S that states these things informally will go  into the model theory. Such text will leave open issue like is    <rdf:Seq rdf:_1="a" rdf:_2="b"/>    intended as the same as or different from    <rdf:Seq rdf:_3="a" rdf:_4="b"/>    (at the model theory level these are clearly different).    > Also, please don't refer  > me to prior RDF Core documented resolutions on containers.  I've read  > them, and can't figure out what they mean    I understood the WG decision to close #rdf-containers-otherapproaches as a  decision to not clarify these questions.      Jeremy        

          Frank:  >  > Just to clarify:  the "model" I'm referring to is that software that  > purports to support a given datatype is responsible for being able to  > determine the validity of lexical forms for the datatype and, given a  > lexical form, determine the proper value according to that datatype (at  > least, that's what I understand the "model" to be).  What I'm suggesting  > breaks the model in the case of rdf:XMLLiteral isn't that RDF parsers  > would "pay it special attention" (the "model" *requires* that it be paid  > special attention), it's that it would be *optional*.  In other words,  > if RDF software works for "its" datatype (rdf:XMLLiteral) the way I  > understand other software is supposed to work for "their" datatypes, RDF  > software ought to check the validity of lexical forms for rdf:XMLLiteral.  >  > Conversely, would we consider it legitimate according to our model for  > RDF datatypes if software that purported to support xsd:integer got the  > typed literal "pumpkin"^^xsd:integer for John Smith's age (to quote an  > example from the Primer) and failed to complain (or even check)?  >      I think that's a good point - I'll try and ensure that Jena does check ...    I don't think we need particularly to add test cases, but we might want to  note it in an implementation report.    Jeremy        

        Thanks Dave.  >   > They are:  >     Triple  >     http://www.w3.org/TR/rdf-concepts/#xtocid103646  >   >     RDF Graph  >     http://www.w3.org/TR/rdf-concepts/#xtocid48021  >   >     5.1 Character normalization  >     http://www.w3.org/TR/rdf-concepts/#xtocid48034  >   > Dave  >         

              RDF Datatyping.htm        text/html attachment: RDF_Datatyping.htm          

          (note I am not copying i18n et al.)    Brian McBride wrote:      >   - RDFCore considered retaining the wrapper element, but decided not to  > because it is more complicated for *implementors* (I note i18n's  > arguments are more user centred)  >       I am not convinced by the "*implementors*" part here.    At the time I got the impression that the rest of the group just found what   I was advocating (retaining the wrapper element) too complicated.    I don't think we discussed "too complicated" for whom.    After, as I was contemplating the arguments made by the rest of the group   it seemed that really this "too complicated" is too complicated for someone   beginning RDF, it's a dirty hack whose inelegance is such that it will put   people off understanding this construct.    Since, as Pat so rightly points out, we take the G view, we are unwilling   to have a hack that messes that up badly.    Jeremy        

        Purpose  =======    Clarify conformance between the RDF working drafts and charmod (and any  other I18N issues).      I would build an agenda around an intro to the RDF graph for the I18N people  and then the three I18N issues that we have identified:  - xmllang  - normalization of string literals (NFC)  - IURI, IRI, URI in rdf    There is a further topic which is N-triples and what are its I18N needs.  DaveB, can you give a five minute intro to N-triples at our meeting - what  its purpose and scope are, rather more than what the syntax is.    Jeremy        > -----Original Message-----  > From: w3c-rdfcore-wg-request@w3.org  > [mailto:w3c-rdfcore-wg-request@w3.org]On Behalf Of Brian McBride  > Sent: 21 February 2002 13:20  > To: Misha.Wolf@reuters.com; danbri@w3.org; brian_mcbride@hp.com  > Cc: w3c-rdfcore-wg@w3.org; w3c-i18n-wg@w3.org  > Subject: RE: Outstanding Issues - rdfms-xmllang  >  >  > In principal, I think that would be an excellent idea.  >  > Jeremy, please could you suggest a statement of purpose for the  > meeting and  > objectives, and possibly an agenda.  >  > Do we do this a small subgroup from RDFCore meeting with the i18n  > folks or  > as the whole WG.  Who from RDFCore would like to participate in such a  > discussion on RDF conformance to charmod?  >  > Misha, can you suggest times when it might be possible to meet.  >  > Brian  >  > At 11:51 21/02/2002 +0000, Misha.Wolf@reuters.com wrote:  >  > >[I'm copying w3c-i18n-wg, rather than w3c-i18n-ig, as this  > >is a process mail, not a technical one]  > >  > >Are you folks interested in meeting with the I18N WG  > >at the Plenary to discuss outstanding issues?  > >  > >Misha Wolf  > >I18N WG Chair  > >  > >  > >On 20/02/2002 11:11:07 Jeremy Carroll wrote:  > > > > rdfms-xmllang: Why isn't xml:lang information represented  > within the RDF  > > > data model?  > > >  > > > > This was put on hold whilst we looked at datatypes.  > > > > Model and Syntax says that lang is part of the literal;  > that no triples  > > > are  > > > > generated for an xml:lang.  We can choose to stick with that or  > > change it.  > > > > Does anyone have a compelling reason to change it?  > > >  > > >  > > >  > > > My proposal before we put it on hold was in the overly long:  > > >  > > > http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Sep/0378.html  > > >  > > > [[[  > > > [1]  > > > An RDF Literal is a Unicode string, optionally paired with a  > > > language tag (as defined in RFC3066).  > > > ]]]  > > >  > > > in that thread we identified equally rules as follows:  > > >  > > > http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Oct/0375.html  > > >  > > > suggesting that such pairs are equal  > > >   if and only if  > > >   the unicode strings are equal  > > > and  > > >    the lang tags are either both absent, or both present and  > equal (as lang  > > > tags, i.e. case insensitive).  > > >  > > >  > > >  > > >  > > > This then works orthogonally with:  > > > - the graph syntax  > > > - model theory  > > > - datatyping  > > > - any treatment of Unicode string normalization  > > >  > > >  > > > Jeremy  > > >  > > >  > >  > >  > >  > >-------------------------------------------------------------- --  > >         Visit our Internet site at http://www.reuters.com  > >  > >Any views expressed in this message are those of  the  individual  > >sender,  except  where  the sender specifically states them to be  > >the views of Reuters Ltd.  >  >        

